
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Country Information</title>    
    <link rel="icon" href="../../assets/icons/alex.ico" type="image/x-icon">
    
    <!-- Leaflet CSS for OpenStreetMap -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet JS for OpenStreetMap -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <!-- ECharts Library -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    
    <style>
    .tooltip {
      position: fixed;
      pointer-events: none;
      background: rgba(30,30,30,0.95);
      color: #fff;
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 13px;
      z-index: 1000;
      white-space: normal;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
      display: none;
      max-width: 300px;
      line-height: 1.5;
    }
    
    .tooltip strong {
      display: block;
      margin-bottom: 8px;
      font-size: 15px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
      padding-bottom: 5px;
    }
    
    svg {
      width: 100%;
      max-width: 900px;
      height: auto;
      display: block;
      margin: 0 auto;
      cursor: pointer;
    }
    
    .country-hover {
      stroke: #222;
      stroke-width: 1.5;
      filter: drop-shadow(0 0 4px #0006);
      cursor: pointer;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      max-width: 100%;
      overflow-x: hidden;
    }
    
    /* Container for main content */
    .main-container {
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
    }
    
    /* Responsive adjustments for large screens */
    @media (min-width: 1400px) {
      .main-container {
        max-width: 1600px;
      }
      
      .tab-container,
      .stats-selector,
      .color-legend,
      #svg-container {
        max-width: 1200px;
      }
      
      .card-container {
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      }
      
      .bar-chart {
        height: 500px;
      }
    }
    
    @media (min-width: 1600px) {
      .tab-container,
      .stats-selector,
      .color-legend,
      #svg-container {
        max-width: 1400px;
      }
      
      .card-container {
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      }
      
      .bar-chart {
        height: 600px;
      }
    }
    
    #svg-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 15px;
      margin-top: 20px;
    }
    
    .header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .header h1 {
      color: #333;
      margin-bottom: 10px;
    }
    
    .header p {
      color: #666;
      font-size: 16px;
    }
    
    .stats-selector {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 15px;
      margin: 20px auto;
      max-width: 900px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .stats-selector label {
      font-weight: 600;
      color: #333;
      font-size: 16px;
    }
    
    .stats-selector select {
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      font-size: 16px;
      background-color: white;
      cursor: pointer;
    }
    
    @media (min-width: 768px) {
      .stats-selector {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
      
      .stats-selector label {
        margin-bottom: 0;
        flex: 1;
      }
      
      .stats-selector select {
        flex: 2;
      }
    }
    
    .color-legend {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 15px;
      margin: 20px auto;
      max-width: 900px;
    }
    
    .legend-title {
      font-weight: 600;
      color: #333;
      font-size: 16px;
      margin-bottom: 10px;
    }
    
    .legend-scale {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .legend-low, .legend-high {
      font-size: 14px;
      color: #666;
      width: 40px;
      text-align: center;
    }
    
    .legend-gradient {
      flex: 1;
      height: 20px;
      background: linear-gradient(to right, 
        rgb(255, 255, 200),  /* Light yellow for very low values */
        rgb(155, 255, 155),  /* Light green for low values */
        rgb(155, 255, 255),  /* Light cyan for low-mid values */
        rgb(155, 155, 255),  /* Light blue for mid values */
        rgb(255, 192, 203),  /* Pink for mid-high values */
        rgb(255, 165, 0),    /* Orange for high values */
        rgb(255, 0, 0)       /* Red for very high values */
      );
      border-radius: 4px;
    }
    
    .legend-values {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      color: #666;
    }
    
    /* Tab Styles */
    .tab-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin: 20px auto;
      max-width: 900px;
      overflow: hidden;
    }
    
    .tab-nav {
      display: flex;
      background-color: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
    }
    
    .tab-button {
      flex: 1;
      padding: 12px 15px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      color: #495057;
      transition: all 0.3s ease;
      border-bottom: 3px solid transparent;
    }
    
    .tab-button:hover {
      background-color: #e9ecef;
    }
    
    .tab-button.active {
      color: #007bff;
      border-bottom-color: #007bff;
      background-color: white;
    }
    
    .tab-content {
      position: relative;
    }
    
    .tab-pane {
      display: none;
      padding: 20px;
    }
    
    .tab-pane.active {
      display: block;
    }
    
    .card-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    
    .country-card {
      background-color: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: flex;
      flex-direction: column;
      cursor: pointer;
      text-align: center;
    }
    
    .country-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    
    .country-card .country-name {
      margin-top: 0;
      color: #333;
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 10px;
    }
    
    .country-card .country-flag-container {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }
    
    .country-card .country-flag {
      width: 80px;
      height: 50px;
      object-fit: contain;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    .country-card .country-info {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .country-card .country-common-name {
      color: #6c757d;
      font-size: 14px;
    }
    
    .country-card .country-capital {
      color: #495057;
      font-size: 14px;
    }
    
    .map-container {
      height: 500px;
      position: relative;
      background-color: #f8f9fa;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #6c757d;
    }
    
    /* Card Controls Styles */
    .card-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .search-container {
      flex: 1;
      min-width: 250px;
    }
    
    .filter-container {
      flex: 0 0 auto;
      min-width: 150px;
    }
    
    #country-search {
      width: 100%;
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
      box-sizing: border-box;
    }
    
    #region-filter, #subregion-filter {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
      background-color: white;
      box-sizing: border-box;
    }
    
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.5);
    }
    
    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 90%;
      max-width: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close:hover,
    .close:focus {
      color: black;
      text-decoration: none;
    }
    
    .modal-header {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #ddd;
    }
    
    .modal-flag {
  width: 60px;
  height: 40px;
  margin-right: 15px;
  object-fit: contain;
}

.modal-coat-of-arms {
  display: flex;
  justify-content: center;
  margin: 15px 0;
  padding: 10px;
  border-bottom: 1px solid #eee;
  background-color: transparent;
  background: transparent;
}

.modal-coat-of-arms img {
  max-width: 150px;
  max-height: 150px;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  transition: transform 0.2s ease;
  background-color: transparent;
  background: transparent;
}

.modal-coat-of-arms img:hover {
  transform: scale(1.05);
}
    
    .modal-title {
      font-size: 24px;
      font-weight: bold;
    }
    
    .modal-details {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .detail-item {
      margin-bottom: 8px;
    }
    
    .detail-label {
      font-weight: bold;
      color: #555;
    }
    
    .detail-value {
      color: #333;
    }
    
    /* Style for links in modal */
    .detail-value a {
      color: #0066cc;
      text-decoration: none;
      font-weight: 500;
    }
    
    .detail-value a:hover {
      text-decoration: underline;
    }
    
    /* Style for images in modal */
    .detail-value img {
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: transform 0.2s ease;
    }
    
    .detail-value img:hover {
      transform: scale(1.05);
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .tab-button {
        font-size: 14px;
        padding: 10px 5px;
      }
      
      .card-container {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: 15px;
      }
      
      .card-controls {
        flex-direction: column;
      }
      
      .search-container, .filter-container {
        width: 100%;
      }
      
      .modal-details {
        grid-template-columns: 1fr;
      }
      
      .modal-content {
        width: 95%;
        margin: 10% auto;
        padding: 15px;
      }
      
      .modal-header {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .modal-flag {
        margin-right: 0;
        margin-bottom: 10px;
      }
      
      .country-card .country-name {
        font-size: 16px;
      }
      
      .country-card .country-flag {
        width: 60px;
        height: 40px;
      }
      
      /* Responsive adjustments for modal images */
      .detail-value img {
        max-width: 80px;
        max-height: 80px;
      }
      
      .modal-coat-of-arms img {
        max-width: 120px;
        max-height: 120px;
        background-color: transparent;
        background: transparent;
      }
      
      /* Map View Styles */
      .map-controls {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-bottom: 20px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      
      .location-search-container {
        display: flex;
        gap: 10px;
      }
      
      #location-search {
        flex: 1;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 16px;
      }
      
      #search-button {
        padding: 10px 20px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
      }
      
      #search-button:hover {
        background-color: #45a049;
      }
      
      .map-mode-toggle {
        display: flex;
        gap: 10px;
      }
      
      .mode-button {
        flex: 1;
        padding: 10px;
        background-color: #f1f1f1;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s;
      }
      
      .mode-button.active {
        background-color: #4CAF50;
        color: white;
        border-color: #4CAF50;
      }
      
      .mode-button:hover:not(.active) {
        background-color: #e1e1e1;
      }
      
      #map {
        height: 500px;
        width: 100%;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      
      .search-results {
        margin-top: 15px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        max-height: 200px;
        overflow-y: auto;
      }
      
      .search-result-item {
        padding: 10px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .search-result-item:hover {
        background-color: #f5f5f5;
      }
      
      .search-result-item:last-child {
        border-bottom: none;
      }
      
      .search-result-name {
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      .search-result-details {
        font-size: 14px;
        color: #666;
      }
      
      /* Responsive Design for Map View */
      @media (max-width: 768px) {
        .map-controls {
          padding: 10px;
          gap: 10px;
        }
        
        .location-search-container {
          flex-direction: column;
        }
        
        #location-search {
          font-size: 14px;
          padding: 8px;
        }
        
        #search-button {
          padding: 8px 16px;
          font-size: 14px;
        }
        
        .mode-button {
          padding: 8px;
          font-size: 14px;
        }
        
        #map {
          height: 400px;
        }
        
        .search-results {
          max-height: 150px;
          padding: 10px;
        }
        
        .search-result-item {
          padding: 8px;
        }
        
        .search-result-name {
          font-size: 14px;
        }
        
        .search-result-details {
          font-size: 12px;
        }
      }
      
      @media (max-width: 480px) {
        .map-controls {
          padding: 8px;
          gap: 8px;
        }
        
        #location-search {
          font-size: 12px;
          padding: 6px;
        }
        
        #search-button {
          padding: 6px 12px;
          font-size: 12px;
        }
        
        .mode-button {
          padding: 6px;
          font-size: 12px;
        }
        
        #map {
          height: 300px;
        }
        
        .search-results {
          max-height: 120px;
          padding: 8px;
        }
        
        .search-result-item {
          padding: 6px;
        }
        
        .search-result-name {
          font-size: 12px;
        }
        
        .search-result-details {
          font-size: 10px;
        }
      }
      
      /* Bar Chart Styles */
      .chart-container {
        margin-top: 30px;
        padding: 20px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      
      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .chart-header h3 {
        margin: 0;
        font-size: 18px;
        color: #333;
      }
      
      .chart-info {
        font-size: 14px;
        color: #666;
      }
      
      .bar-chart {
        width: 100%;
        height: 400px;
      }
      
      /* Responsive Design for Bar Chart */
      @media (max-width: 768px) {
        .chart-container {
          padding: 15px;
          margin-top: 20px;
        }
        
        .chart-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }
        
        .chart-header h3 {
          font-size: 16px;
        }
        
        .chart-info {
          font-size: 12px;
        }
        
        .bar-chart {
          height: 300px;
        }
      }
      
      @media (max-width: 480px) {
        .chart-container {
          padding: 10px;
          margin-top: 15px;
        }
        
        .chart-header h3 {
          font-size: 14px;
        }
        
        .chart-info {
          font-size: 11px;
        }
        
        .bar-chart {
          height: 250px;
        }
      }
    }
    
    @media (max-width: 480px) {
      .card-container {
        grid-template-columns: 1fr;
      }
      
      .tab-button {
        font-size: 12px;
        padding: 8px 4px;
      }
      
      .header h1 {
        font-size: 20px;
      }
      
      .header p {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <!-- Header -->
    <div class="header">
      <h1>Interactive World Map with Country Statistics</h1>
      <p>Hover over any country to view detailed statistics and information</p>
    </div>
  
  <!-- Modal for country details -->
  <div id="country-modal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <div class="modal-header">
        <img id="modal-flag" class="modal-flag" src="" alt="Flag">
        <div id="modal-title" class="modal-title"></div>
      </div>
      <div id="modal-coat-of-arms" class="modal-coat-of-arms">
        <!-- Coat of Arms will be displayed here -->
      </div>
      <div id="modal-details" class="modal-details">
        <!-- Details will be populated dynamically -->
      </div>
    </div>
  </div>
  
  <!-- Tab Navigation -->
  <div class="tab-container">
    <div class="tab-nav">
      <button class="tab-button active" data-tab="svg-view">SVG View</button>
      <button class="tab-button" data-tab="card-view">Card View</button>
      <button class="tab-button" data-tab="map-view">Map View</button>
    </div>
    
    <!-- Tab Content -->
    <div class="tab-content">
      <!-- SVG View Tab -->
      <div id="svg-view" class="tab-pane active">
        <!-- Statistics Selector -->
        <div class="stats-selector">
          <label for="stat-select">Select Statistic to Visualize:</label>
          <select id="stat-select">
            <option value="">-- Select a statistic --</option>
          </select>
        </div>
        
        <!-- Color Legend -->
        <div class="color-legend">
          <div class="legend-title">Color Scale:</div>
          <div class="legend-scale">
            <div class="legend-low">Low</div>
            <div class="legend-gradient"></div>
            <div class="legend-high">High</div>
          </div>
          <div class="legend-values" id="legend-values">
            <span id="legend-min">0</span>
            <span id="legend-max">100</span>
          </div>
        </div>
        
        <!-- Tooltip -->
        <div id="tooltip" class="tooltip"></div>

        <!-- SVG Map (paste your SVG content below) -->
        <div id="svg-container">
          <!-- SVG will be injected here -->
        </div>
        
        <!-- Bar Chart Container -->
        <div class="chart-container">
          <div class="chart-header">
            <div class="chart-info" id="chart-info">
              <!-- Chart information will be displayed here -->
            </div>
          </div>
          <div id="bar-chart" class="bar-chart">
            <!-- ECharts bar chart will be rendered here -->
          </div>
        </div>
      </div>
      
      <!-- Card View Tab -->
      <div id="card-view" class="tab-pane">
        <div class="card-controls">
          <!-- Search Field -->
          <div class="search-container">
            <input type="text" id="country-search" placeholder="Search by country code, name, or Chinese name...">
          </div>
          
          <!-- Region Filter -->
          <div class="filter-container">
            <select id="region-filter">
              <option value="">All Regions</option>
            </select>
          </div>
          
          <!-- Subregion Filter -->
          <div class="filter-container">
            <select id="subregion-filter">
              <option value="">All Subregions</option>
            </select>
          </div>
        </div>
        
        <div class="card-container">
          <!-- Cards will be dynamically generated here -->
        </div>
      </div>
      
      <!-- Map View Tab -->
      <div id="map-view" class="tab-pane">
        <div class="map-controls">
          <!-- Location Search Field -->
          <div class="location-search-container">
            <input type="text" id="location-search" placeholder="Search location by name (Chinese/English)...">
            <button id="search-button">Search</button>
          </div>
          
          <!-- Map Mode Toggle -->
          <div class="map-mode-toggle">
            <button id="normal-mode" class="mode-button active">Normal</button>
            <button id="satellite-mode" class="mode-button">Satellite</button>
          </div>
        </div>
        
        <div id="map" class="map-container">
          <!-- OpenStreetMap will be rendered here -->
        </div>
        
        <!-- Search Results -->
        <div id="search-results" class="search-results">
          <!-- Search results will be displayed here -->
        </div>
      </div>
    </div>
  </div>
  
  

  <script>
    // Test if JavaScript is running
    console.log('JavaScript is executing');
    
    // Global variable to store country statistics
    let countryStats = {};
    // Global variable to store available statistics
    let availableStats = [];
    // Global variable to store the currently selected statistic
    let selectedStatistic = '';
    // Sample data for testing - we'll replace this with the full JSON loading later
    const sampleCountryStats = {
      "US": {
        "name": "United States",
        "region": "Northern America",
        "gdp": 21433226.0,
        "population": 331002.0,
        "gdp_per_capita": 65280.0,
        "life_expectancy_male": 76.3,
        "life_expectancy_female": 81.3,
        "unemployment": 3.9,
        "forested_area": 33.9
      },
      "CN": {
        "name": "China",
        "region": "Eastern Asia",
        "gdp": 14342903.0,
        "population": 1439324.0,
        "gdp_per_capita": 9961.0,
        "life_expectancy_male": 75.0,
        "life_expectancy_female": 77.9,
        "unemployment": 3.8,
        "forested_area": 22.3
      },
      "DE": {
        "name": "Germany",
        "region": "Western Europe",
        "gdp": 3845630.0,
        "population": 83784.0,
        "gdp_per_capita": 45888.0,
        "life_expectancy_male": 78.7,
        "life_expectancy_female": 83.4,
        "unemployment": 3.2,
        "forested_area": 32.7
      },
      "JP": {
        "name": "Japan",
        "region": "Eastern Asia",
        "gdp": 5081770.0,
        "population": 125508.0,
        "gdp_per_capita": 40498.0,
        "life_expectancy_male": 81.6,
        "life_expectancy_female": 87.3,
        "unemployment": 2.4,
        "forested_area": 68.5
      },
      "AU": {
        "name": "Australia",
        "region": "Oceania",
        "gdp": 1453871.0,
        "population": 25500.0,
        "gdp_per_capita": 58392.7,
        "life_expectancy_male": 81.2,
        "life_expectancy_female": 85.2,
        "unemployment": 5.3,
        "forested_area": 16.2
      }
    };
    
    // Function to load country statistics from JSON
    async function loadCountryStats() {
      try {
        console.log('Attempting to load country statistics...');
        
        // Performance optimization: Add timeout to prevent long waits
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        const response = await fetch('/assets/data/geography/country_stats.json', {
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        console.log('Response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        // Performance optimization: Use response cloning for better memory management
        const data = await response.clone().json();
        countryStats = data;
        console.log('Country statistics loaded successfully. Sample data:', Object.keys(countryStats).slice(0, 5));
        
        // Extract available statistics from the first country
        if (Object.keys(countryStats).length > 0) {
          const firstCountry = Object.keys(countryStats)[0];
          console.log('First country:', firstCountry);
          console.log('First country data:', countryStats[firstCountry]);
          
          // Performance optimization: Cache the filtered stats
          availableStats = Object.keys(countryStats[firstCountry])
            .filter(key => !['name', 'region'].includes(key)); // Exclude non-numeric fields
          
          console.log('Available statistics:', availableStats);
          
          // Populate the dropdown with available statistics
          populateStatsDropdown();
          
          // Performance optimization: Pre-process data for faster access
          preprocessCountryData();
        } else {
          console.error('No country data found');
          throw new Error('No country data found in JSON');
        }
      } catch (error) {
        console.error('Error loading country statistics:', error);
        
        // Check if it's an abort error (timeout)
        if (error.name === 'AbortError') {
          console.log('Request timed out, using sample data for testing');
        } else {
          console.log('Using sample data for testing');
        }
        
        // Use sample data for testing
        countryStats = sampleCountryStats;
        
        // Extract available statistics from the sample data
        const firstCountry = Object.keys(sampleCountryStats)[0];
        console.log('Sample first country:', firstCountry);
        console.log('Sample first country data:', sampleCountryStats[firstCountry]);
        
        availableStats = Object.keys(sampleCountryStats[firstCountry])
          .filter(key => !['name', 'region'].includes(key)); // Exclude non-numeric fields
        
        console.log('Available statistics from sample data:', availableStats);
        
        // Populate the dropdown with available statistics
        populateStatsDropdown();
        
        // Pre-process sample data as well
        preprocessCountryData();
      }
    }
    
    // Performance optimization: Pre-process country data for faster access
    function preprocessCountryData() {
      console.log('Pre-processing country data for performance...');
      
      // Create a lookup table for regions and subregions
      const regions = new Set();
      const subregions = new Set();
      
      // Pre-calculate min/max values for each statistic
      const statRanges = {};
      
      // Process each country
      for (const countryCode in countryStats) {
        const country = countryStats[countryCode];
        
        // Collect regions and subregions
        if (country.region) {
          regions.add(country.region);
        }
        if (country.subregion) {
          subregions.add(country.subregion);
        }
        
        // Calculate min/max for each statistic
        for (const stat of availableStats) {
          if (!statRanges[stat]) {
            statRanges[stat] = { min: Infinity, max: -Infinity };
          }
          
          const value = parseFloat(country[stat]);
          if (!isNaN(value)) {
            statRanges[stat].min = Math.min(statRanges[stat].min, value);
            statRanges[stat].max = Math.max(statRanges[stat].max, value);
          }
        }
      }
      
      // Store pre-processed data for later use
      window.preprocessedData = {
        regions: Array.from(regions).sort(),
        subregions: Array.from(subregions).sort(),
        statRanges: statRanges
      };
      
      console.log('Data pre-processing complete');
      console.log('Found', regions.size, 'regions and', subregions.size, 'subregions');
    }
    
    // Function to populate the statistics dropdown
    function populateStatsDropdown() {
      console.log('Populating dropdown with available stats:', availableStats);
      
      const selectElement = document.getElementById('stat-select');
      if (!selectElement) {
        console.error('Dropdown element not found');
        return;
      }
      
      // Clear existing options except the default one
      while (selectElement.options.length > 1) {
        selectElement.remove(1);
      }
      
      // Add new options for each available statistic
      availableStats.forEach(stat => {
        const option = document.createElement('option');
        option.value = stat;
        // Format the statistic name for display (e.g., gdp_per_capita -> GDP Per Capita)
        option.textContent = stat.split('_').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        selectElement.appendChild(option);
        console.log('Added option:', stat);
      });
      
      // Add event listener for selection changes
      selectElement.addEventListener('change', handleStatisticSelection);
      console.log('Dropdown populated with', availableStats.length, 'options');
    }
    
    // Function to handle statistic selection
    function handleStatisticSelection() {
      const selectElement = document.getElementById('stat-select');
      selectedStatistic = selectElement.value;
      
      console.log('Selected statistic:', selectedStatistic);
      
      if (selectedStatistic) {
        // Apply color scale to the map based on the selected statistic
        applyColorScale();
        // Update the bar chart with the selected statistic
        updateBarChart();
      } else {
        // Reset the map colors if no statistic is selected
        resetMapColors();
        // Clear the bar chart if no statistic is selected
        clearBarChart();
      }
    }
    
    // Function to apply color scale based on selected statistic
    function applyColorScale() {
      if (!selectedStatistic || Object.keys(countryStats).length === 0) {
        console.log('Cannot apply color scale: no statistic selected or no data available');
        return;
      }
      
      console.log('Applying color scale for statistic:', selectedStatistic);
      
      // Performance optimization: Use pre-calculated min/max values if available
      let minValue, maxValue;
      
      if (window.preprocessedData && window.preprocessedData.statRanges && 
          window.preprocessedData.statRanges[selectedStatistic]) {
        // Use pre-calculated values
        const range = window.preprocessedData.statRanges[selectedStatistic];
        minValue = range.min;
        maxValue = range.max;
        console.log(`Using pre-calculated value range for ${selectedStatistic}: ${minValue} to ${maxValue}`);
      } else {
        // Fallback to calculating on the fly
        console.log('Pre-calculated ranges not available, calculating on the fly...');
        minValue = Infinity;
        maxValue = -Infinity;
        
        Object.values(countryStats).forEach(country => {
          const value = country[selectedStatistic];
          if (value !== undefined && value !== null && !isNaN(value)) {
            minValue = Math.min(minValue, parseFloat(value));
            maxValue = Math.max(maxValue, parseFloat(value));
          }
        });
        
        console.log(`Calculated value range for ${selectedStatistic}: ${minValue} to ${maxValue}`);
      }
      
      // Handle edge case where all values are the same
      if (minValue === maxValue) {
        maxValue = minValue + 1; // Add a small difference to avoid division by zero
      }
      
      const valueRange = maxValue - minValue;
      
      // Update the legend values
      document.getElementById('legend-min').textContent = formatLegendValue(minValue);
      document.getElementById('legend-max').textContent = formatLegendValue(maxValue);
      
      // Performance optimization: Use requestAnimationFrame for better performance with many paths
      requestAnimationFrame(() => {
        // Apply colors to each country path
        const paths = document.querySelectorAll('path[class*="highcharts-key-"]');
        console.log('Found', paths.length, 'country paths to color');
        
        // Process paths in batches for better performance
        const batchSize = 50;
        let processed = 0;
        
        function processBatch() {
          const end = Math.min(processed + batchSize, paths.length);
          
          for (let i = processed; i < end; i++) {
            const path = paths[i];
            
            // Extract country code from classes
            const classes = path.className.baseVal.split(' ');
            const keyClass = classes.find(cls => cls.startsWith('highcharts-key-'));
            
            if (keyClass) {
              let countryCode = keyClass.replace('highcharts-key-', '').toUpperCase();
              
              // Get the value for this country
              const countryData = countryStats[countryCode];
              if (countryData && countryData[selectedStatistic] !== undefined && 
                  countryData[selectedStatistic] !== null && !isNaN(countryData[selectedStatistic])) {
                const value = parseFloat(countryData[selectedStatistic]);
                
                // Calculate color based on value (0-100 scale)
                const normalizedValue = (value - minValue) / valueRange;
                const colorValue = Math.round(normalizedValue * 100);
                
                // Generate color from blue (low) to red (high)
                const color = getColorForValue(colorValue);
                
                // Apply the color to the path
                path.style.fill = color;
                
                // Store the original fill color if not already stored
                if (!path.dataset.originalFill) {
                  path.dataset.originalFill = path.style.fill || '';
                }
              } else {
                // If no data for this country, use a neutral color
                path.style.fill = '#cccccc';
              }
            }
          }
          
          processed = end;
          
          // Continue processing if there are more paths
          if (processed < paths.length) {
            requestAnimationFrame(processBatch);
          } else {
            console.log('Color scale application complete');
          }
        }
        
        // Start processing batches
        processBatch();
      });
    }
    
    // Function to format legend values
    function formatLegendValue(value) {
      // Display raw numerical value without any formatting or units
      return value.toString();
    }
    
    // Function to reset map colors
    function resetMapColors() {
      const paths = document.querySelectorAll('path[class*="highcharts-key-"]');
      
      paths.forEach(path => {
        // Restore original fill color if it was stored
        if (path.dataset.originalFill) {
          path.style.fill = path.dataset.originalFill;
        } else {
          // Default color if no original was stored
          path.style.fill = '';
        }
      });
    }
    
    // Function to get color based on value (0-100)
 function getColorForValue(value) {
   // Clamp value between 0 and 100
   value = Math.max(0, Math.min(100, value));
   
   // Define color stops for our multi-color gradient
   // Each color stop is at a specific position (0-100) and has an RGB value
   const colorStops = [
     { pos: 0, r: 255, g: 255, b: 200 },   // Light yellow
     { pos: 17, r: 155, g: 255, b: 155 },  // Light green
     { pos: 33, r: 155, g: 255, b: 255 },  // Light cyan
     { pos: 50, r: 155, g: 155, b: 255 },  // Light blue
     { pos: 67, r: 255, g: 192, b: 203 },  // Pink
     { pos: 83, r: 255, g: 165, b: 0 },    // Orange
     { pos: 100, r: 255, g: 0, b: 0 }      // Red
   ];
   
   // Find the two color stops that our value falls between
   let lowerStop = colorStops[0];
   let upperStop = colorStops[colorStops.length - 1];
   
   for (let i = 0; i < colorStops.length - 1; i++) {
     if (value >= colorStops[i].pos && value <= colorStops[i + 1].pos) {
       lowerStop = colorStops[i];
       upperStop = colorStops[i + 1];
       break;
     }
   }
   
   // Calculate the position between the two stops
   const segmentRange = upperStop.pos - lowerStop.pos;
   const segmentPos = (value - lowerStop.pos) / segmentRange;
   
   // Interpolate between the two colors
   const r = Math.round(lowerStop.r + (upperStop.r - lowerStop.r) * segmentPos);
   const g = Math.round(lowerStop.g + (upperStop.g - lowerStop.g) * segmentPos);
   const b = Math.round(lowerStop.b + (upperStop.b - lowerStop.b) * segmentPos);
   
   return `rgb(${r}, ${g}, ${b})`;
 }
    
    // Function to load SVG from file path
    async function loadSVGFromPath() {
      try {
        console.log('loadSVGFromPath function called');
        console.log('Attempting to load SVG from: /assets/data/geography/world_countries.svg');
        const response = await fetch('/assets/data/geography/world_countries.svg');
        console.log('SVG Response status:', response.status);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const svgContent = await response.text();
        console.log('SVG content length:', svgContent.length);
        
        // Inject SVG content into the container
        const svgContainer = document.getElementById('svg-container');
        if (!svgContainer) {
          console.error('SVG container not found');
          return;
        }
        svgContainer.innerHTML = svgContent;
        console.log('SVG content injected into container');
        
        // Initialize tooltip functionality after SVG is loaded
        console.log('SVG loaded, initializing tooltips...');
        initializeTooltips();
        
        // Reapply color scale if a statistic is already selected
        if (selectedStatistic) {
          console.log('Reapplying color scale for selected statistic:', selectedStatistic);
          applyColorScale();
        }
      } catch (error) {
        console.error('Error loading SVG:', error);
        const svgContainer = document.getElementById('svg-container');
        if (svgContainer) {
          svgContainer.innerHTML = '<p>Error loading map. Please try again later.</p>';
        }
      }
    }
    
    // Function to format statistics for display
function formatCountryStats(countryCode) {
  console.log('Formatting stats for country code:', countryCode);
  const stats = countryStats[countryCode];
  console.log('Stats found:', stats ? 'Yes' : 'No');
  if (!stats) return `No data available for ${countryCode}`;
  
  // Always display country and region
  const formattedStats = [
    `Country: ${stats.name || 'N/A'}`,
    `Region: ${stats.region || 'N/A'}`
  ];
  
  // If a statistic is selected, display only that value
  if (selectedStatistic) {
    const value = stats[selectedStatistic];
    if (value !== undefined) {
      // Format the statistic name for display
      const statName = selectedStatistic.split('_').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
      
      formattedStats.push(`${statName}: ${value}`);
    } else {
      // Format the statistic name for display
      const statName = selectedStatistic.split('_').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
      
      formattedStats.push(`${statName}: No data available`);
    }
  }
  
  const result = formattedStats.join('<br>');
  console.log('Formatted stats:', result);
  return result;
}
    
    // Function to initialize the ECharts bar chart
    let barChart = null;
    let chartInitialized = false;
    
    function initializeBarChart() {
      console.log('Initializing bar chart...');
      const chartDom = document.getElementById('bar-chart');
      if (!chartDom) {
        console.error('Bar chart container not found');
        return;
      }
      
      // Check if chart is already initialized
      if (chartInitialized && barChart) {
        console.log('Bar chart already initialized, resizing...');
        barChart.resize();
        return;
      }
      
      // Initialize ECharts instance with performance optimizations
      barChart = echarts.init(chartDom, null, {
        renderer: 'canvas', // Use canvas renderer for better performance
        useDirtyRect: false // Disable dirty rect for better compatibility
      });
      
      console.log('Bar chart initialized');
      chartInitialized = true;
      
      // Set initial empty chart
      const option = {
        title: {
          text: 'Select a statistic to view data',
          left: 'center',
          textStyle: {
            fontSize: 16,
            fontWeight: 'normal'
          }
        },
        tooltip: {
          trigger: 'axis',
          axisPointer: {
            type: 'shadow'
          },
          confine: true // Keep tooltip within chart area
        },
        grid: {
          left: '3%',
          right: '4%',
          bottom: '3%',
          containLabel: true
        },
        xAxis: {
          type: 'category',
          data: [],
          axisLabel: {
            interval: 0,
            rotate: 30,
            fontSize: 12
          }
        },
        yAxis: {
          type: 'value'
        },
        series: [{
          name: 'Value',
          type: 'bar',
          data: [],
          animation: false // Disable animation for initial load
        }]
      };
      
      // Use setOption with notMerge option for better performance
      barChart.setOption(option, { notMerge: true });
      
      // Add debounced resize handler for responsive design
      let resizeTimeout;
      const debouncedResize = function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          barChart && barChart.resize();
        }, 200); // Debounce resize events
      };
      
      window.addEventListener('resize', debouncedResize);
      
      // Add visibility change handler to optimize performance when tab is not visible
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          // Pause animations when tab is not visible
          if (barChart) {
            barChart.dispatchAction({
              type: 'hideTip'
            });
          }
        } else {
          // Resume when tab becomes visible again
          if (barChart) {
            barChart.resize();
          }
        }
      });
    }
    
    // Function to update the bar chart with the selected statistic
    function updateBarChart() {
      if (!barChart) {
        console.log('Bar chart not initialized, initializing now...');
        initializeBarChart();
      }
      
      if (!selectedStatistic || Object.keys(countryStats).length === 0) {
        console.log('Cannot update bar chart: no statistic selected or no data available');
        return;
      }
      
      console.log('Updating bar chart for statistic:', selectedStatistic);
      
      // Performance optimization: Use a more efficient sorting method
      const countries = Object.entries(countryStats)
        .filter(([code, data]) => {
          const value = data[selectedStatistic];
          return value !== undefined && value !== null && !isNaN(value);
        })
        .sort((a, b) => {
          const aValue = parseFloat(a[1][selectedStatistic]);
          const bValue = parseFloat(b[1][selectedStatistic]);
          return bValue - aValue; // Descending order
        })
        .slice(0, 20); // Limit to top 20 countries for better performance
      
      if (countries.length === 0) {
        console.log('No data available for the selected statistic');
        clearBarChart();
        return;
      }
      
      // Extract country names and values for the chart with performance optimizations
      const countryNames = countries.map(([code, data]) => data.name || code);
      const values = countries.map(([code, data]) => parseFloat(data[selectedStatistic]));
      
      // Format the statistic name for display
      const statName = selectedStatistic.split('_').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
      
      // Update chart info if element exists
      const chartInfo = document.getElementById('chart-info');
      if (chartInfo) {
        chartInfo.textContent = `Showing top ${countries.length} countries`;
      }
      
      // Pre-calculate min and max values for color scaling
      const allValues = values;
      const minValue = Math.min(...allValues);
      const maxValue = Math.max(...allValues);
      const valueRange = maxValue - minValue || 1; // Avoid division by zero
      
      // Set chart options with performance optimizations
      const option = {
        title: {
          text: `Top 20 Countries by ${statName}`,
          left: 'center',
          textStyle: {
            fontSize: 18,
            fontWeight: 'bold'
          }
        },
        tooltip: {
          trigger: 'axis',
          axisPointer: {
            type: 'shadow'
          },
          formatter: function(params) {
            const countryName = params[0].axisValue;
            const value = params[0].value;
            return `${countryName}<br/>${statName}: ${value.toLocaleString()}`;
          },
          confine: true
        },
        grid: {
          left: '3%',
          right: '4%',
          bottom: '15%',
          containLabel: true
        },
        xAxis: {
          type: 'category',
          data: countryNames,
          axisLabel: {
            interval: 0,
            rotate: 45,
            fontSize: 10,
            width: 80,
            overflow: 'truncate',
            ellipsis: '...'
          }
        },
        yAxis: {
          type: 'value',
          name: statName,
          axisLabel: {
            formatter: function(value) {
              return value.toLocaleString();
            }
          }
        },
        series: [{
          name: statName,
          type: 'bar',
          data: values,
          itemStyle: {
            color: function(params) {
              // Use pre-calculated min/max for better performance
              const normalizedValue = (params.value - minValue) / valueRange;
              const colorValue = Math.round(normalizedValue * 100);
              return getColorForValue(colorValue);
            }
          },
          animation: true, // Enable animation for updates
          animationDuration: 500, // Faster animation for better UX
          animationEasing: 'cubicOut' // Smooth easing function
        }],
        dataZoom: [
          {
            type: 'inside',
            start: 0,
            end: 100,
            zoomLock: true // Prevent zooming for better performance
          }
        ]
      };
      
      // Use setOption with notMerge for better performance
      barChart.setOption(option, { notMerge: true });
      console.log('Bar chart updated with', countries.length, 'countries');
    }
    
    // Function to clear the bar chart
    function clearBarChart() {
      if (!barChart) {
        console.log('Bar chart not initialized');
        return;
      }
      
      console.log('Clearing bar chart');
      
      // Clear chart info
      const chartInfo = document.getElementById('chart-info');
      if (chartInfo) {
        chartInfo.textContent = 'No data to display';
      }
      
      // Set empty chart options with performance optimizations
      const option = {
        title: {
          text: 'Select a statistic to view data',
          left: 'center',
          textStyle: {
            fontSize: 18,
            fontWeight: 'bold'
          }
        },
        tooltip: {
          show: false // Disable tooltip for empty chart
        },
        grid: {
          left: '3%',
          right: '4%',
          bottom: '3%',
          containLabel: true
        },
        xAxis: {
          type: 'category',
          data: [],
          show: false // Hide x-axis for cleaner empty state
        },
        yAxis: {
          type: 'value',
          show: false // Hide y-axis for cleaner empty state
        },
        series: [{
          name: 'Value',
          type: 'bar',
          data: [],
          animation: false // Disable animation for empty state
        }]
      };
      
      // Use notMerge option for complete replacement
      barChart.setOption(option, { notMerge: true });
    }
    
    // Function to initialize tooltips after SVG is loaded
    function initializeTooltips() {
      console.log('Initializing tooltips...');
      console.log('Country stats available:', Object.keys(countryStats).length);
      
      const tooltip = document.getElementById('tooltip');
      const paths = document.querySelectorAll('path[class*="highcharts-key-"]');
      
      console.log('Found', paths.length, 'country paths');
      
      // Performance optimization: Use event delegation for better performance with many elements
      const svgContainer = document.querySelector('#svg-container');
      if (!svgContainer) {
        console.error('SVG container not found');
        return;
      }
      
      // Add event delegation to the container instead of individual paths
      svgContainer.addEventListener('mouseover', function(e) {
        const path = e.target.closest('path[class*="highcharts-key-"]');
        if (!path) return;
        
        // Extract country code from classes
        const classes = path.className.baseVal.split(' ');
        const keyClass = classes.find(cls => cls.startsWith('highcharts-key-'));
        
        if (keyClass) {
          let countryCode = keyClass.replace('highcharts-key-', '');
          // Convert to uppercase to match the countryStats keys
          countryCode = countryCode.toUpperCase();
          console.log('Hovering over country:', countryCode);
          console.log('Country stats available for this country:', countryStats[countryCode] ? 'Yes' : 'No');
          
          // Get country name from the name class if available
          const nameClass = classes.find(cls => cls.startsWith('highcharts-name-'));
          let countryName = '';
          if (nameClass) {
            countryName = nameClass.replace('highcharts-name-', '').replace(/-/g, ' ');
            countryName = countryName.replace(/\b\w/g, l => l.toUpperCase());
          }
          
          console.log('Country name:', countryName || 'Not available');
          
          // Format the tooltip content with country statistics
          let tooltipContent = '';
          if (countryName) {
            tooltipContent = `<strong>${countryName} (${countryCode})</strong><br>`;
          } else {
            tooltipContent = `<strong>${countryCode}</strong><br>`;
          }
          
          tooltipContent += formatCountryStats(countryCode);
          
          // Display the tooltip
          tooltip.innerHTML = tooltipContent;
          tooltip.style.display = 'block';
          console.log('Tooltip displayed');
          
          // Add hover effect
          path.classList.add('country-hover');
        }
      });
      
      // Use event delegation for mousemove
      svgContainer.addEventListener('mousemove', function(e) {
        const path = e.target.closest('path[class*="highcharts-key-"]');
        if (!path) return;
        
        if (tooltip.style.display === 'block') {
          tooltip.style.left = e.clientX + 10 + 'px';
          tooltip.style.top = e.clientY + 10 + 'px';
        }
      });
      
      // Use event delegation for mouseleave
      svgContainer.addEventListener('mouseout', function(e) {
        const path = e.target.closest('path[class*="highcharts-key-"]');
        if (!path) return;
        
        // Check if we're actually leaving the path, not just moving to a child element
        if (!e.relatedTarget || !path.contains(e.relatedTarget)) {
          tooltip.style.display = 'none';
          path.classList.remove('country-hover');
        }
      });
      
      // Add touch support for mobile devices
      svgContainer.addEventListener('touchstart', function(e) {
        const path = e.target.closest('path[class*="highcharts-key-"]');
        if (!path) return;
        
        // Extract country code from classes
        const classes = path.className.baseVal.split(' ');
        const keyClass = classes.find(cls => cls.startsWith('highcharts-key-'));
        
        if (keyClass) {
          let countryCode = keyClass.replace('highcharts-key-', '');
          countryCode = countryCode.toUpperCase();
          
          // Get country name from the name class if available
          const nameClass = classes.find(cls => cls.startsWith('highcharts-name-'));
          let countryName = '';
          if (nameClass) {
            countryName = nameClass.replace('highcharts-name-', '').replace(/-/g, ' ');
            countryName = countryName.replace(/\b\w/g, l => l.toUpperCase());
          }
          
          // Format the tooltip content with country statistics
          let tooltipContent = '';
          if (countryName) {
            tooltipContent = `<strong>${countryName} (${countryCode})</strong><br>`;
          } else {
            tooltipContent = `<strong>${countryCode}</strong><br>`;
          }
          
          tooltipContent += formatCountryStats(countryCode);
          
          // Display the tooltip at touch position
          const touch = e.touches[0];
          tooltip.innerHTML = tooltipContent;
          tooltip.style.display = 'block';
          tooltip.style.left = touch.clientX + 10 + 'px';
          tooltip.style.top = touch.clientY + 10 + 'px';
          
          // Add hover effect
          path.classList.add('country-hover');
          
          // Prevent default touch behavior
          e.preventDefault();
        }
      });
      
      // Add touch end support
      svgContainer.addEventListener('touchend', function(e) {
        tooltip.style.display = 'none';
        document.querySelectorAll('.country-hover').forEach(path => {
          path.classList.remove('country-hover');
        });
      });
    }
    
    // Load data and SVG when page loads with performance optimizations
    window.onload = async function() {
      console.log('Window loaded, starting data loading...');
      
      // Use requestIdleCallback for non-critical tasks if available
      const loadNonCriticalTasks = () => {
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => {
            console.log('Loading non-critical tasks during idle time...');
            // Preload resources that might be needed later
            const preloadLinks = [
              { rel: 'preload', href: '/assets/data/geography/country_basics.json', as: 'fetch' },
              { rel: 'preload', href: '/assets/data/geography/country_stats.json', as: 'fetch' }
            ];
            
            preloadLinks.forEach(linkProps => {
              const link = document.createElement('link');
              Object.assign(link, linkProps);
              document.head.appendChild(link);
            });
          });
        }
      };
      
      try {
        // First load country statistics with timeout
        const statsPromise = Promise.race([
          loadCountryStats(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Country stats loading timeout')), 10000)
          )
        ]);
        
        await statsPromise;
        console.log('Country stats loaded successfully');
        
        // Then load the SVG map with timeout
        const svgPromise = Promise.race([
          new Promise(resolve => {
            loadSVGFromPath();
            resolve();
          }),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('SVG loading timeout')), 10000)
          )
        ]);
        
        await svgPromise;
        console.log('SVG map loaded successfully');
        
        // Load non-critical tasks
        loadNonCriticalTasks();
        
      } catch (error) {
        console.error('Error during page initialization:', error);
        
        // Show user-friendly error message
        const errorContainer = document.createElement('div');
        errorContainer.className = 'error-message';
        errorContainer.innerHTML = `
          <p>Some resources failed to load. Please refresh the page to try again.</p>
          <p class="error-details">Error: ${error.message}</p>
        `;
        
        // Insert error message at the top of the main container
        const mainContainer = document.querySelector('.main-container');
        if (mainContainer) {
          mainContainer.insertBefore(errorContainer, mainContainer.firstChild);
        }
      }
    };
    
    // Function to test dropdown population
    function testDropdown() {
      console.log('Test dropdown function called');
      console.log('Country stats available:', Object.keys(countryStats).length);
      
      if (Object.keys(countryStats).length > 0) {
        const firstCountry = Object.keys(countryStats)[0];
        console.log('First country:', firstCountry);
        console.log('First country data:', countryStats[firstCountry]);
        
        availableStats = Object.keys(countryStats[firstCountry])
          .filter(key => !['name', 'region'].includes(key)); // Exclude non-numeric fields
        
        console.log('Available statistics:', availableStats);
        
        // Populate the dropdown with available statistics
        populateStatsDropdown();
      } else {
        console.error('No country data found');
        alert('No country data found');
      }
    }
    
    // Tab functionality with performance optimizations
    function initializeTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      
      // Use event delegation for better performance
      const tabsContainer = document.querySelector('.tabs');
      if (tabsContainer) {
        tabsContainer.addEventListener('click', (e) => {
          const button = e.target.closest('.tab-button');
          if (!button) return;
          
          // Remove active class from all buttons and panes
          document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
          document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
          
          // Add active class to clicked button
          button.classList.add('active');
          
          // Show corresponding tab pane
          const tabId = button.getAttribute('data-tab');
          const tabPane = document.getElementById(tabId);
          if (tabPane) {
            tabPane.classList.add('active');
            
            // Use requestAnimationFrame for smoother transitions
            requestAnimationFrame(() => {
              // If card view is selected, initialize it
              if (tabId === 'card-view') {
                initializeCardView();
              }
              
              // If map view is selected, initialize it
              else if (tabId === 'map-view') {
                initializeMap();
              }
              
              // If SVG view is selected, initialize the bar chart
              else if (tabId === 'svg-view') {
                initializeBarChart();
              }
            });
          }
        });
      }
      
      // Add keyboard navigation for accessibility
      tabButtons.forEach(button => {
        button.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            button.click();
          }
        });
      });
    }
    
    // Global variable to store country basics data
    let countryBasics = {};
    
    // Function to load country basics from JSON
    async function loadCountryBasics() {
      try {
        console.log('Attempting to load country basics...');
        const response = await fetch('/assets/data/geography/country_basics.json');
        console.log('Response status:', response.status);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        countryBasics = await response.json();
        console.log('Country basics loaded successfully. Sample data:', Object.keys(countryBasics).slice(0, 5));
        
        // Populate region and subregion filters
        populateFilters();
        
        // Initialize card view
        populateCardView();
      } catch (error) {
        console.error('Error loading country basics:', error);
        const cardContainer = document.querySelector('.card-container');
        if (cardContainer) {
          cardContainer.innerHTML = '<p>Error loading country data. Please try again later.</p>';
        }
      }
    }
    
    // Function to populate region and subregion filters
    function populateFilters() {
      const regions = new Set();
      const subregions = new Set();
      
      Object.values(countryBasics).forEach(country => {
        if (country.region && country.region !== "NaN") {
          regions.add(country.region);
        }
        if (country.subregion && country.subregion !== "NaN") {
          subregions.add(country.subregion);
        }
      });
      
      // Populate region filter
      const regionFilter = document.getElementById('region-filter');
      Array.from(regions).sort().forEach(region => {
        const option = document.createElement('option');
        option.value = region;
        option.textContent = region;
        regionFilter.appendChild(option);
      });
      
      // Populate subregion filter
      const subregionFilter = document.getElementById('subregion-filter');
      Array.from(subregions).sort().forEach(subregion => {
        const option = document.createElement('option');
        option.value = subregion;
        option.textContent = subregion;
        subregionFilter.appendChild(option);
      });
    }
    
    // Function to populate card view with performance optimizations
    function populateCardView() {
      console.log('Populating card view...');
      const cardContainer = document.querySelector('.card-container');
      if (!cardContainer) {
        console.error('Card container not found');
        return;
      }
      
      // Clear existing cards
      cardContainer.innerHTML = '';
      
      // If countryBasics is empty, show loading message
      if (Object.keys(countryBasics).length === 0) {
        cardContainer.innerHTML = '<p>Loading country data...</p>';
        return;
      }
      
      const searchTerm = document.getElementById('country-search')?.value.toLowerCase() || '';
      const regionFilter = document.getElementById('region-filter')?.value || '';
      const subregionFilter = document.getElementById('subregion-filter')?.value || '';
      
      console.log('Filters applied:', { searchTerm, regionFilter, subregionFilter });
      
      // Use document fragment for better performance when adding multiple elements
      const fragment = document.createDocumentFragment();
      let visibleCards = 0;
      
      // Pre-filter countries to avoid repeated DOM operations
      const filteredCountries = Object.entries(countryBasics).filter(([code, country]) => {
        // Apply filters
        if (searchTerm && !matchesSearch(country, searchTerm)) {
          return false;
        }
        
        if (regionFilter && country.region !== regionFilter) {
          return false;
        }
        
        if (subregionFilter && country.subregion !== subregionFilter) {
          return false;
        }
        
        return true;
      });
      
      // Process in batches to avoid blocking the main thread
      const batchSize = 50;
      let currentIndex = 0;
      
      function processBatch() {
        const endIndex = Math.min(currentIndex + batchSize, filteredCountries.length);
        
        for (let i = currentIndex; i < endIndex; i++) {
          const [code, country] = filteredCountries[i];
          
          // Create card
          const card = document.createElement('div');
          card.className = 'country-card';
          card.dataset.countryCode = code;
          
          // Card content
          card.innerHTML = `
            <div class="country-name">${country['name.official.chn'] || country['name.common'] || code}</div>
            <div class="country-flag-container">
              <img class="country-flag" src="${country['flags.svg'] || ''}" alt="${country['name.common'] || code} flag" loading="lazy">
            </div>
            <div class="country-info">
              <div class="country-common-name"><strong>${country['name.common'] || code}</strong></div>
              <div class="country-capital">Capital: ${country.capital || 'N/A'}</div>
            </div>
          `;
          
          // Add click event to show modal
          card.addEventListener('click', () => showCountryModal(code, country), { passive: true });
          
          fragment.appendChild(card);
          visibleCards++;
        }
        
        currentIndex = endIndex;
        
        // Add processed cards to DOM
        if (fragment.hasChildNodes()) {
          cardContainer.appendChild(fragment);
          fragment.innerHTML = ''; // Clear fragment for next batch
        }
        
        // Continue processing if there are more items
        if (currentIndex < filteredCountries.length) {
          requestAnimationFrame(processBatch);
        } else if (visibleCards === 0) {
          // If no cards match the filters, show a message
          cardContainer.innerHTML = '<p>No countries match your search criteria. Please try different filters.</p>';
        } else {
          console.log(`Displayed ${visibleCards} country cards`);
        }
      }
      
      // Start processing batches
      if (filteredCountries.length > 0) {
        processBatch();
      } else {
        cardContainer.innerHTML = '<p>No countries match your search criteria. Please try different filters.</p>';
      }
    }
    
    // Function to check if country matches search term
    function matchesSearch(country, searchTerm) {
      return (
        (country.cca3 && country.cca3.toLowerCase().includes(searchTerm)) ||
        (country.cioc && country.cioc.toLowerCase().includes(searchTerm)) ||
        (country['name.common'] && country['name.common'].toLowerCase().includes(searchTerm)) ||
        (country['name.official'] && country['name.official'].toLowerCase().includes(searchTerm)) ||
        (country['name.common.chn'] && country['name.common.chn'].toLowerCase().includes(searchTerm)) ||
        (country['name.official.chn'] && country['name.official.chn'].toLowerCase().includes(searchTerm))
      );
    }
    
    // Function to show country modal
    function showCountryModal(code, country) {
      const modal = document.getElementById('country-modal');
      const modalFlag = document.getElementById('modal-flag');
      const modalTitle = document.getElementById('modal-title');
      const modalCoatOfArms = document.getElementById('modal-coat-of-arms');
      const modalDetails = document.getElementById('modal-details');
      
      // Set modal content
      modalFlag.src = country['flags.svg'] || '';
      modalFlag.alt = `${country['name.common'] || code} flag`;
      modalTitle.textContent = country['name.official.chn'] || country['name.common'] || code;
      
      // Set Coat of Arms
      if (country['coatOfArms.svg'] && country['coatOfArms.svg'] !== "NaN") {
        modalCoatOfArms.innerHTML = `<img src="${country['coatOfArms.svg']}" alt="${country['name.common'] || code} Coat of Arms">`;
        modalCoatOfArms.style.display = 'flex';
      } else {
        modalCoatOfArms.innerHTML = '';
        modalCoatOfArms.style.display = 'none';
      }
      
      // Clear and populate details
      modalDetails.innerHTML = '';
      
      // Helper function to add detail item
      function addDetail(label, value) {
        if (value && value !== "NaN") {
          const item = document.createElement('div');
          item.className = 'detail-item';
          item.innerHTML = `
            <span class="detail-label">${label}:</span>
            <span class="detail-value">${value}</span>
          `;
          modalDetails.appendChild(item);
        }
      }
      
      // Helper function to add clickable link
      function addLink(label, url, linkText) {
        if (url && url !== "NaN") {
          const item = document.createElement('div');
          item.className = 'detail-item';
          item.innerHTML = `
            <span class="detail-label">${label}:</span>
            <span class="detail-value"><a href="${url}" target="_blank">${linkText || 'View'}</a></span>
          `;
          modalDetails.appendChild(item);
        }
      }
      
      // Helper function to add image
      function addImage(label, src, alt) {
        if (src && src !== "NaN") {
          const item = document.createElement('div');
          item.className = 'detail-item';
          item.innerHTML = `
            <span class="detail-label">${label}:</span>
            <span class="detail-value"><img src="${src}" alt="${alt}" style="max-width: 100px; max-height: 100px; border: 1px solid #ddd; border-radius: 4px;"></span>
          `;
          modalDetails.appendChild(item);
        }
      }
      
      // Add all country details
      addDetail('Country Code', code);
      addDetail('CCA3', country.cca3);
      addDetail('CIOC', country.cioc);
      addDetail('CCN3', country.ccn3);
      addDetail('Official Name', country['name.official']);
      addDetail('Common Name', country['name.common']);
      addDetail('Official Name (Chinese)', country['name.official.chn']);
      addDetail('Common Name (Chinese)', country['name.common.chn']);
      addDetail('Region', country.region);
      addDetail('Subregion', country.subregion);
      addDetail('Capital', country.capital);
      addDetail('Population', country.population ? country.population.toLocaleString() : '');
      addDetail('Area', country.area ? `${country.area.toLocaleString()} km` : '');
      addDetail('Continents', country.continents);
      addDetail('Language', country.language);
      addDetail('Currency', country.currency);
      addDetail('Borders', country.borders);
      addDetail('Latitude/Longitude', country.latlng);
      addDetail('Capital Coordinates', country['capitalInfo.latlng']);
      
      // Add map links
      addLink('Google Maps', country['maps.googleMaps'], 'View on Google Maps');
      addLink('OpenStreet Maps', country['maps.openStreetMaps'], 'View on OpenStreet Maps');
      
      // Show modal
      modal.style.display = 'block';
    }
    
    // Initialize card view when tab is activated with performance optimizations
    function initializeCardView() {
      console.log('Initializing card view...');
      
      // Add event listeners for search and filters with passive event listeners for better performance
      const countrySearch = document.getElementById('country-search');
      const regionFilter = document.getElementById('region-filter');
      const subregionFilter = document.getElementById('subregion-filter');
      
      // Use debounce for search input to improve performance
      let searchTimeout;
      if (countrySearch) {
        countrySearch.addEventListener('input', () => {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(populateCardView, 300);
        }, { passive: true });
      }
      
      if (regionFilter) {
        regionFilter.addEventListener('change', populateCardView, { passive: true });
      }
      
      if (subregionFilter) {
        subregionFilter.addEventListener('change', populateCardView, { passive: true });
      }
      
      // Modal close functionality
      const modal = document.getElementById('country-modal');
      const closeBtn = document.querySelector('.close');
      
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          modal.style.display = 'none';
        }, { passive: true });
      }
      
      // Use event delegation for modal close on outside click
      if (modal) {
        modal.addEventListener('click', (event) => {
          if (event.target === modal) {
            modal.style.display = 'none';
          }
        }, { passive: true });
      }
      
      // Load country basics data if not already loaded
      if (Object.keys(countryBasics).length === 0) {
        loadCountryBasics();
      } else {
        // If data is already loaded, populate the card view
        requestAnimationFrame(populateCardView);
      }
    }
    
    // Initialize tabs and other components when DOM is ready with performance optimizations
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM content loaded, initializing components...');
      
      // Use requestAnimationFrame for non-blocking initialization
      requestAnimationFrame(() => {
        // Initialize tabs first as they control the main UI
        initializeTabs();
        
        // Pre-initialize components that will be needed when tabs are activated
        // This reduces initialization time when switching tabs
        const preInitComponents = () => {
          // Pre-load event listeners for elements that exist in the DOM
          const searchInput = document.getElementById('country-search');
          const regionFilter = document.getElementById('region-filter');
          const subregionFilter = document.getElementById('subregion-filter');
          
          // Add passive event listeners for better scroll performance
          if (searchInput) {
            searchInput.addEventListener('input', () => {
              // This will be properly debounced in initializeCardView
              // Just adding the listener now to improve perceived performance
            }, { passive: true });
          }
          
          if (regionFilter) {
            regionFilter.addEventListener('change', () => {
              // This will be properly handled in initializeCardView
            }, { passive: true });
          }
          
          if (subregionFilter) {
            subregionFilter.addEventListener('change', () => {
              // This will be properly handled in initializeCardView
            }, { passive: true });
          }
          
          // Pre-initialize map container if it exists
          const mapContainer = document.getElementById('map');
          if (mapContainer) {
            // Set initial dimensions to prevent layout shifts
            mapContainer.style.height = '500px';
            mapContainer.style.width = '100%';
          }
          
          // Pre-initialize chart container if it exists
          const chartContainer = document.getElementById('bar-chart');
          if (chartContainer) {
            // Set initial dimensions to prevent layout shifts
            chartContainer.style.height = '500px';
            chartContainer.style.width = '100%';
          }
        };
        
        // Run pre-initialization
        preInitComponents();
        
        // Use requestIdleCallback for non-critical pre-initialization if available
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => {
            console.log('Performing non-critical pre-initialization during idle time...');
            
            // Pre-load images that will be needed
            const imagesToPreload = [
              '/assets/images/loading.svg',
              '/assets/images/error.svg'
            ];
            
            imagesToPreload.forEach(src => {
              const img = new Image();
              img.src = src;
            });
          });
        }
      });
    });
    
    // Map functionality
    let map;
    let markers = [];
    let currentMapMode = 'normal';
    
    // Initialize map when map tab is activated with performance optimizations
    function initializeMap() {
      console.log('Initializing map...');
      
      // Check if map is already initialized
      if (map) {
        return;
      }
      
      // Initialize the map with optimized settings
      map = L.map('map', {
        center: [30, 0],
        zoom: 2,
        zoomControl: true,
        attributionControl: true,
        preferCanvas: true // Use canvas renderer for better performance with many markers
      });
      
      // Add the default tile layer (normal mode)
      updateMapTileLayer('normal');
      
      // Use event delegation for map controls to reduce event listeners
      const mapControls = document.querySelector('.map-controls');
      if (mapControls) {
        mapControls.addEventListener('click', (e) => {
          const target = e.target;
          
          // Handle search button click
          if (target.id === 'search-button' || target.closest('#search-button')) {
            performLocationSearch();
          }
          
          // Handle map mode buttons
          if (target.id === 'normal-mode' || target.closest('#normal-mode')) {
            switchMapMode('normal');
          }
          
          if (target.id === 'satellite-mode' || target.closest('#satellite-mode')) {
            switchMapMode('satellite');
          }
        }, { passive: true });
        
        // Handle Enter key in search input
        const locationSearch = document.getElementById('location-search');
        if (locationSearch) {
          locationSearch.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              performLocationSearch();
            }
          }, { passive: true });
        }
      }
      
      // Optimize map performance
      if (map) {
        // Disable animations for better performance on mobile devices
        if (window.innerWidth < 768) {
          map.options.zoomAnimation = false;
          map.options.fadeAnimation = false;
          map.options.markerZoomAnimation = false;
        }
        
        // Add touch support for mobile devices
        map.addHandler('touchExtend', L.Handler.TouchExtend);
      }
    }
    
    // Update map tile layer based on mode
    function updateMapTileLayer(mode) {
      if (!map) return;
      
      // Remove existing tile layers
      map.eachLayer(function(layer) {
        if (layer instanceof L.TileLayer) {
          map.removeLayer(layer);
        }
      });
      
      // Add new tile layer based on mode
      if (mode === 'normal') {
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
          maxZoom: 19
        }).addTo(map);
      } else if (mode === 'satellite') {
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
          maxZoom: 19
        }).addTo(map);
      }
    }
    
    // Switch between normal and satellite map modes
    function switchMapMode(mode) {
      if (!map) return;
      
      currentMapMode = mode;
      
      // Update button states
      document.getElementById('normal-mode').classList.toggle('active', mode === 'normal');
      document.getElementById('satellite-mode').classList.toggle('active', mode === 'satellite');
      
      // Update tile layer
      updateMapTileLayer(mode);
    }
    
    // Perform location search using Nominatim API with performance optimizations
    async function performLocationSearch() {
      const searchInput = document.getElementById('location-search');
      const searchResults = document.getElementById('search-results');
      
      if (!searchInput || !searchResults) {
        console.error('Search elements not found');
        return;
      }
      
      const query = searchInput.value.trim();
      
      if (!query) {
        searchResults.innerHTML = '<p>Please enter a location name to search.</p>';
        return;
      }
      
      // Show loading message
      searchResults.innerHTML = '<p>Searching...</p>';
      
      try {
        // Use AbortController for timeout handling
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        // Use Nominatim API for geocoding
        const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&accept-language=en,zh`, {
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        
        const data = await response.json();
        
        if (data.length === 0) {
          searchResults.innerHTML = '<p>No results found for your search.</p>';
          return;
        }
        
        // Clear existing markers
        clearMarkers();
        
        // Use document fragment for better performance when adding multiple elements
        const fragment = document.createDocumentFragment();
        
        // Create a bounds object to fit all markers
        const bounds = L.latLngBounds();
        
        // Process results in batches to avoid blocking the main thread
        const batchSize = 5; // Small batch size since we're only showing 5 results max
        let currentIndex = 0;
        
        function processBatch() {
          const endIndex = Math.min(currentIndex + batchSize, data.length);
          
          for (let i = currentIndex; i < endIndex; i++) {
            const result = data[i];
            
            // Create result item
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            
            const displayName = result.display_name;
            const lat = parseFloat(result.lat);
            const lon = parseFloat(result.lon);
            
            resultItem.innerHTML = `
              <div class="search-result-name">${result.display_name.split(',')[0]}</div>
              <div class="search-result-details">${result.display_name}</div>
            `;
            
            // Add click event to focus on this location
            resultItem.addEventListener('click', function() {
              focusOnLocation(lat, lon, displayName);
            }, { passive: true });
            
            fragment.appendChild(resultItem);
            
            // Add marker to map
            const marker = L.marker([lat, lon], {
              title: displayName,
              alt: displayName
            }).addTo(map);
            
            marker.bindPopup(`<strong>${displayName}</strong><br>Lat: ${lat.toFixed(4)}<br>Lon: ${lon.toFixed(4)}`);
            
            // Add marker to array for later removal
            markers.push(marker);
            
            // Extend bounds to include this marker
            bounds.extend([lat, lon]);
          }
          
          currentIndex = endIndex;
          
          // Add processed results to DOM
          if (fragment.hasChildNodes()) {
            searchResults.innerHTML = ''; // Clear previous results
            searchResults.appendChild(fragment);
          }
          
          // Fit map to show all markers
          if (data.length > 1) {
            map.fitBounds(bounds, { 
              padding: [20, 20],
              animate: window.innerWidth >= 768 // Only animate on larger screens
            });
          } else {
            // If only one result, center on it with appropriate zoom
            map.setView([data[0].lat, data[0].lon], 12, {
              animate: window.innerWidth >= 768 // Only animate on larger screens
            });
          }
        }
        
        // Start processing batches
        processBatch();
        
      } catch (error) {
        console.error('Error searching for location:', error);
        
        if (error.name === 'AbortError') {
          searchResults.innerHTML = '<p>Search timed out. Please try again.</p>';
        } else {
          searchResults.innerHTML = '<p>Error searching for location. Please try again later.</p>';
        }
      }
    }
    
    // Focus map on a specific location with performance optimizations
    function focusOnLocation(lat, lon, name) {
      if (!map) return;
      
      // Use optimized view settings based on device
      const viewOptions = {
        center: [lat, lon],
        zoom: 15,
        animate: window.innerWidth >= 768 // Only animate on larger screens
      };
      
      map.setView(viewOptions.center, viewOptions.zoom, viewOptions);
      
      // Find and open the popup for this location with optimized search
      requestAnimationFrame(() => {
        // Use a more efficient search algorithm for finding markers
        for (let i = 0; i < markers.length; i++) {
          const marker = markers[i];
          const markerLat = marker.getLatLng().lat;
          const markerLon = marker.getLatLng().lng;
          
          // Use a small epsilon for floating point comparison
          if (Math.abs(markerLat - lat) < 0.0001 && Math.abs(markerLon - lon) < 0.0001) {
            marker.openPopup();
            break; // Exit loop once found
          }
        }
      });
    }
    
    // Clear all markers from the map with performance optimizations
    function clearMarkers() {
      if (!map) return;
      
      // Use batch removal for better performance with many markers
      const batchSize = 50;
      let currentIndex = 0;
      
      function removeBatch() {
        const endIndex = Math.min(currentIndex + batchSize, markers.length);
        
        for (let i = currentIndex; i < endIndex; i++) {
          map.removeLayer(markers[i]);
        }
        
        currentIndex = endIndex;
        
        // Continue processing if there are more markers
        if (currentIndex < markers.length) {
          requestAnimationFrame(removeBatch);
        } else {
          // Clear the markers array after all have been removed
          markers = [];
        }
      }
      
      // Start removing batches if there are markers
      if (markers.length > 0) {
        removeBatch();
      }
    }
  </script>
</div>
</body>
</html>
