<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ªé˜³ç³» - å¤©æ–‡å­¦ä¹ åŠ©æ‰‹</title>
    <link rel="icon" href="../../assets/icons/logo_btrfly.ico" type="image/x-icon">
    <link rel="stylesheet" href="../../css/common.css">
    <link rel="stylesheet" href="../../css/components.css">
    <link rel="stylesheet" href="../../css/utilities.css">
    <link rel="stylesheet" href="../../css/responsive.css">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        .solar-system-page {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 50%, #2d1b69 100%);
            min-height: 100vh;
            color: #fff;
        }

        .planet-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        .planet-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border-radius: 20px;
            padding: 2rem;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .planet-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(67, 97, 238, 0.3);
        }

        .planet-header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .planet-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            position: relative;
        }

        .planet-mercury { background: linear-gradient(135deg, #8C7853, #FFC649); }
        .planet-venus { background: linear-gradient(135deg, #FFC649, #FFB347); }
        .planet-earth { background: linear-gradient(135deg, #6B93D6, #4F94CD); }
        .planet-mars { background: linear-gradient(135deg, #CD5C5C, #A0522D); }
        .planet-jupiter { background: linear-gradient(135deg, #D2691E, #CD853F); }
        .planet-saturn { background: linear-gradient(135deg, #FAD5A5, #DEB887); }
        .planet-uranus { background: linear-gradient(135deg, #4FD0E7, #3CB371); }
        .planet-neptune { background: linear-gradient(135deg, #4169E1, #0000CD); }

        .planet-info h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #fff;
        }

        .planet-subtitle {
            color: #a8dadc;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .planet-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .stat-item {
            background: rgba(0,0,0,0.2);
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: #4361ee;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .planet-description {
            line-height: 1.6;
            margin-bottom: 1.5rem;
            opacity: 0.9;
        }

        .planet-features {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .feature-badge {
            background: rgba(67, 97, 238, 0.2);
            color: #a8dadc;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            border: 1px solid rgba(67, 97, 238, 0.3);
        }

        .solar-system-model {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 2rem;
            margin: 3rem 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        #solar-system-container {
            width: 100%;
            height: 600px;
            margin: 2rem auto;
            border-radius: 20px;
            background: radial-gradient(circle at center, rgba(255, 215, 0, 0.1) 0%, transparent 70%);
            position: relative;
            overflow: hidden;
        }

        .solar-system-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .solar-system-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .solar-system-btn:hover {
            background: white;
            transform: scale(1.05);
        }

        .solar-system-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            color: #333;
            backdrop-filter: blur(5px);
            z-index: 100;
            max-width: 200px;
        }

        .planet-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            z-index: 100;
        }

        .planet-selector select {
            background: transparent;
            border: none;
            color: #333;
            font-size: 14px;
            cursor: pointer;
        }

        /* 3D Solar System Styles */
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 10;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* è‡ªç„¶ç°è±¡æ¼”ç¤ºåŒºåŸŸ */
        .phenomena-section {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 2rem;
            margin: 3rem 0;
        }

        .phenomena-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 3rem;
            margin: 2rem 0;
        }

        .phenomenon-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
            border-radius: 20px;
            padding: 2rem;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* 3D Phenomena containers */
        #seasons-3d-container,
        #day-night-3d-container,
        #tidal-3d-container {
            position: relative;
            overflow: hidden;
        }

        .comparison-section {
            background: rgba(0,0,0,0.2);
            border-radius: 20px;
            padding: 2rem;
            margin: 3rem 0;
        }

        .size-comparison {
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .size-planet {
            text-align: center;
            margin: 0.5rem;
        }

        .size-circle {
            border-radius: 50%;
            margin: 0 auto 0.5rem;
        }

        .size-label {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        .explanation-box {
            background: rgba(67, 97, 238, 0.1);
            border: 1px solid rgba(67, 97, 238, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .explanation-box h4 {
            color: #4361ee;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .explanation-box p {
            line-height: 1.6;
            opacity: 0.9;
        }

        /* å¤©æ–‡ç°è±¡3Dæ¼”ç¤ºæ ·å¼ */
        .phenomena-section {
            margin: 4rem 0;
            padding: 2rem;
            background: rgba(0,0,0,0.2);
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .phenomena-section h2 {
            text-align: center;
            margin-bottom: 1rem;
            color: #4361ee;
            font-size: 2rem;
        }

        .phenomena-section > p {
            text-align: center;
            opacity: 0.8;
            margin-bottom: 2rem;
        }

        .phenomena-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }

        .phenomenon-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border-radius: 20px;
            padding: 1.5rem;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .phenomenon-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(67, 97, 238, 0.2);
        }

        .phenomenon-card h3 {
            color: #4361ee;
            margin-bottom: 1rem;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .phenomenon-3d-container {
            width: 100%;
            height: 350px;
            background: linear-gradient(135deg, #000011 0%, #001122 50%, #002244 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            margin-bottom: 1rem;
            border: 2px solid rgba(67, 97, 238, 0.3);
        }

        .phenomenon-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
            align-items: center;
        }

        .phenomenon-btn {
            width: 35px;
            height: 35px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #333;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .phenomenon-btn:hover {
            background: white;
            transform: scale(1.05);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 12px;
            color: #333;
        }

        .speed-control label {
            font-weight: 600;
        }

        .speed-control input[type="range"] {
            width: 60px;
            height: 4px;
        }

        .speed-control span {
            font-weight: 600;
            min-width: 25px;
        }

        .phenomenon-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            color: #333;
            z-index: 100;
            min-width: 150px;
        }

        .phenomenon-info div {
            margin-bottom: 3px;
        }

        .phenomenon-info span {
            font-weight: 600;
            color: #4361ee;
        }

        @media (max-width: 768px) {
            .solar-system-page {
                padding: 1rem 0;
            }
            
            .planet-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            #solar-system-container {
                height: 400px;
                margin: 1rem auto;
            }
            
            .phenomena-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .phenomenon-3d-container {
                height: 300px !important;
            }
            
            .phenomenon-controls {
                flex-direction: column;
                gap: 3px;
            }
            
            .speed-control {
                padding: 3px 6px;
                font-size: 10px;
            }
            
            .speed-control input[type="range"] {
                width: 50px;
            }
            
            .solar-system-controls {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 3px;
            }
            
            .solar-system-btn {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }
            
            .planet-selector {
                top: auto;
                bottom: 10px;
                right: 10px;
                padding: 8px;
            }
            
            .planet-selector select {
                font-size: 12px;
            }
            
            .solar-system-info {
                font-size: 11px;
                padding: 8px;
                max-width: 150px;
            }
            
            .planet-card {
                padding: 1.5rem;
            }
            
            .planet-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }
            
            .stat-item {
                padding: 0.75rem;
            }
        }

        @media (max-width: 480px) {
            #solar-system-container {
                height: 300px;
            }
            
            .phenomenon-3d-container {
                height: 250px !important;
            }
            
            .phenomenon-controls {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 2px;
            }
            
            .phenomenon-btn {
                width: 30px;
                height: 30px;
                font-size: 12px;
            }
            
            .speed-control {
                padding: 2px 4px;
                font-size: 9px;
            }
            
            .solar-system-controls {
                gap: 2px;
            }
            
            .solar-system-btn {
                width: 30px;
                height: 30px;
                font-size: 12px;
            }
            
            .planet-selector select {
                font-size: 11px;
            }
            
            .solar-system-info {
                font-size: 10px;
                padding: 6px;
                max-width: 120px;
            }
            
            .planet-stats {
                grid-template-columns: 1fr;
            }
        }

        @media (min-width: 768px) {
            .planet-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            #solar-system-container {
                height: 600px;
            }
        }

        @media (min-width: 1024px) {
            .planet-grid {
                grid-template-columns: repeat(2, 1fr);
                max-width: 1200px;
                margin: 2rem auto;
            }
            
            #solar-system-container {
                height: 700px;
            }
        }
    </style>
</head>
<body>
    <header class="main-header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <a href="../../index.html">
                        <i class="fas fa-graduation-cap" style="background: linear-gradient(90deg, #4361ee, #7209b7); -webkit-background-clip: text; background-clip: text; color: transparent;"></i>
                        <span>Alexçš„å­¦ä¹ åŠ©æ‰‹</span>
                    </a>
                </div>
                <nav class="main-nav">
                    <ul>
                        <li><a href="../../index.html">é¦–é¡µ</a></li>
                        <li><a href="main.html">å¤©æ–‡</a></li>
                        <li><a href="#" class="active">å¤ªé˜³ç³»</a></li>
                        <li><a href="../../tts.html">è¯­éŸ³</a></li>
                        <li><a href="../../draw.html">ç»˜å›¾</a></li>
                    </ul>
                </nav>
                <button class="mobile-menu-toggle" aria-label="åˆ‡æ¢èœå•">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
        </div>
    </header>

    <main class="solar-system-page">
        <section class="hero-section">
            <div class="container">
                <div class="hero-content">
                    <h1><i class="fas fa-sun"></i> å¤ªé˜³ç³»æ¢ç´¢</h1>
                    <p>æ¢ç´¢æˆ‘ä»¬çš„å¤ªé˜³ç³»ï¼Œäº†è§£å…«å¤§è¡Œæ˜Ÿçš„ç‰¹å¾å’Œè¿åŠ¨è§„å¾‹</p>
                </div>
            </div>
        </section>

        <section class="container">
            <div class="solar-system-model">
                <h2>3D å¤ªé˜³ç³»è½¨é“æ¨¡å‹</h2>
                <p>æ¢ç´¢çœŸå®çš„3Då¤ªé˜³ç³»ï¼Œè§‚å¯Ÿè¡Œæ˜Ÿå›´ç»•å¤ªé˜³çš„è½¨é“è¿åŠ¨</p>
                
                <div id="solar-system-container">
                    <div class="solar-system-controls">
                        <button class="solar-system-btn" id="play-pause" title="æ’­æ”¾/æš‚åœ">â¸ï¸</button>
                        <button class="solar-system-btn" id="speed-up" title="åŠ é€Ÿ">â©</button>
                        <button class="solar-system-btn" id="speed-down" title="å‡é€Ÿ">âª</button>
                        <button class="solar-system-btn" id="reset-view" title="é‡ç½®è§†å›¾">ğŸ </button>
                        <button class="solar-system-btn" id="toggle-orbits" title="æ˜¾ç¤º/éšè—è½¨é“">ğŸ”„</button>
                    </div>
                    
                    <div class="planet-selector">
                        <select id="planet-focus">
                            <option value="overview">å¤ªé˜³ç³»å…¨æ™¯</option>
                            <option value="sun">å¤ªé˜³</option>
                            <option value="mercury">æ°´æ˜Ÿ</option>
                            <option value="venus">é‡‘æ˜Ÿ</option>
                            <option value="earth">åœ°çƒ</option>
                            <option value="mars">ç«æ˜Ÿ</option>
                            <option value="jupiter">æœ¨æ˜Ÿ</option>
                            <option value="saturn">åœŸæ˜Ÿ</option>
                            <option value="uranus">å¤©ç‹æ˜Ÿ</option>
                            <option value="neptune">æµ·ç‹æ˜Ÿ</option>
                        </select>
                    </div>
                    
                    <div class="solar-system-info">
                        <div id="current-planet-info">
                            <strong>å¤ªé˜³ç³»å…¨æ™¯</strong><br>
                            æ‹–æ‹½æ—‹è½¬è§†è§’<br>
                            æ»šè½®ç¼©æ”¾è·ç¦»<br>
                            é€‰æ‹©è¡Œæ˜Ÿèšç„¦è§‚å¯Ÿ
                        </div>
                    </div>
                    
                    <div class="loading-indicator" id="solar-system-loading">
                        <div class="loading-spinner"></div>
                        <div>åŠ è½½3Då¤ªé˜³ç³»æ¨¡å‹ä¸­...</div>
                    </div>
                </div>

                <div class="explanation-box">
                    <h4><i class="fas fa-info-circle"></i> è½¨é“è¿åŠ¨è¯´æ˜</h4>
                    <p>è¡Œæ˜Ÿå›´ç»•å¤ªé˜³çš„è½¨é“è¿åŠ¨éµå¾ªå¼€æ™®å‹’å®šå¾‹ã€‚è·ç¦»å¤ªé˜³è¶Šè¿‘çš„è¡Œæ˜Ÿï¼Œå…¬è½¬é€Ÿåº¦è¶Šå¿«ï¼Œå…¬è½¬å‘¨æœŸè¶ŠçŸ­ã€‚æ°´æ˜Ÿå…¬è½¬ä¸€å‘¨åªéœ€88å¤©ï¼Œè€Œæµ·ç‹æ˜Ÿéœ€è¦165å¹´ã€‚åŠ¨ç”»ä¸­çš„é€Ÿåº¦æ¯”ä¾‹å·²ç»è°ƒæ•´ï¼Œä¾¿äºè§‚å¯Ÿå„è¡Œæ˜Ÿçš„ç›¸å¯¹è¿åŠ¨å…³ç³»ã€‚</p>
                </div>
            </div>

            <div class="phenomena-section">
                <h2>è‡ªç„¶ç°è±¡å½¢æˆåŸç†</h2>
                <p>äº†è§£åœ°çƒä¸Šå››å­£ã€æ—¥å¤œã€æ½®æ±ç­‰è‡ªç„¶ç°è±¡çš„å¤©æ–‡æˆå› </p>
                
                <div class="phenomena-grid">
                    <!-- å››å­£å½¢æˆ -->
                    <div class="phenomenon-card">
                        <h3><i class="fas fa-leaf"></i> å››å­£å½¢æˆ</h3>
                        <div id="seasons-3d-container" style="width: 100%; height: 400px; background: radial-gradient(circle at center, rgba(255, 215, 0, 0.1) 0%, transparent 70%); border-radius: 15px; position: relative;">
                            <div class="loading-indicator" id="seasons-loading">
                                <div class="loading-spinner"></div>
                                <div>åŠ è½½3Då››å­£æ¼”ç¤ºä¸­...</div>
                            </div>
                        </div>
                        <div class="explanation-box">
                            <h4>å½¢æˆåŸç†</h4>
                            <p>å››å­£çš„å½¢æˆæ˜¯ç”±äºåœ°çƒè‡ªè½¬è½´ç›¸å¯¹äºå…¬è½¬è½¨é“å¹³é¢å€¾æ–œ23.5Â°ã€‚å½“åœ°çƒå…¬è½¬åˆ°ä¸åŒä½ç½®æ—¶ï¼Œå—åŒ—åŠçƒæ¥å—å¤ªé˜³è¾å°„çš„è§’åº¦å’Œæ—¶é•¿ä¸åŒï¼Œä»è€Œå½¢æˆå››å­£å˜åŒ–ã€‚å¤è‡³æ—¶åŒ—åŠçƒå€¾å‘å¤ªé˜³ï¼Œå†¬è‡³æ—¶èƒŒç¦»å¤ªé˜³ã€‚</p>
                        </div>
                    </div>

                    <!-- æ—¥å¤œäº¤æ›¿ -->
                    <div class="phenomenon-card">
                        <h3><i class="fas fa-moon"></i> æ—¥å¤œäº¤æ›¿</h3>
                        <div id="day-night-3d-container" style="width: 100%; height: 400px; background: linear-gradient(90deg, #FFD700 0%, #87CEEB 50%, #191970 100%); border-radius: 15px; position: relative;">
                            <div class="loading-indicator" id="day-night-loading">
                                <div class="loading-spinner"></div>
                                <div>åŠ è½½3Dæ—¥å¤œæ¼”ç¤ºä¸­...</div>
                            </div>
                        </div>
                        <div class="explanation-box">
                            <h4>å½¢æˆåŸç†</h4>
                            <p>æ—¥å¤œäº¤æ›¿æ˜¯ç”±åœ°çƒè‡ªè½¬é€ æˆçš„ã€‚åœ°çƒç»•è‡ªè½¬è½´æ—‹è½¬ä¸€å‘¨çº¦24å°æ—¶ï¼Œé¢å‘å¤ªé˜³çš„ä¸€é¢æ˜¯ç™½å¤©ï¼ŒèƒŒç¦»å¤ªé˜³çš„ä¸€é¢æ˜¯é»‘å¤œã€‚åœ°çƒè‡ªè½¬ä½¿å¾—åœ°è¡¨å„ç‚¹è½®æµæ¥å—å¤ªé˜³ç…§å°„ï¼Œå½¢æˆæ˜¼å¤œå¾ªç¯ã€‚</p>
                        </div>
                    </div>

                    <!-- æ½®æ±ç°è±¡ -->
                    <div class="phenomenon-card">
                        <h3><i class="fas fa-water"></i> æ½®æ±ç°è±¡</h3>
                        <div id="tidal-3d-container" style="width: 100%; height: 400px; background: linear-gradient(180deg, #87CEEB 0%, #4682B4 100%); border-radius: 15px; position: relative;">
                            <div class="loading-indicator" id="tidal-loading">
                                <div class="loading-spinner"></div>
                                <div>åŠ è½½3Dæ½®æ±æ¼”ç¤ºä¸­...</div>
                            </div>
                        </div>
                        <div class="explanation-box">
                            <h4>å½¢æˆåŸç†</h4>
                            <p>æ½®æ±æ˜¯ç”±æœˆçƒå’Œå¤ªé˜³çš„å¼•åŠ›ä½œç”¨å¼•èµ·çš„ã€‚æœˆçƒå¼•åŠ›ä½¿é¢å‘æœˆçƒçš„æµ·æ°´è¢«æ‹‰èµ·å½¢æˆé«˜æ½®ï¼ŒåŒæ—¶åœ°çƒèƒŒé¢ç”±äºæƒ¯æ€§åŠ›ä¹Ÿå½¢æˆé«˜æ½®ã€‚æœˆçƒç»•åœ°çƒå…¬è½¬ä½¿æ½®æ±ä½ç½®ä¸æ–­å˜åŒ–ï¼Œä¸€å¤©å†…é€šå¸¸æœ‰ä¸¤æ¬¡é«˜æ½®å’Œä¸¤æ¬¡ä½æ½®ã€‚</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="planet-grid">
                <!-- æ°´æ˜Ÿ -->
                <div class="planet-card">
                    <div class="planet-header">
                        <div class="planet-icon planet-mercury">
                            <i class="fas fa-circle"></i>
                        </div>
                        <div class="planet-info">
                            <h3>æ°´æ˜Ÿ Mercury</h3>
                            <div class="planet-subtitle">è·ç¦»å¤ªé˜³æœ€è¿‘çš„è¡Œæ˜Ÿ</div>
                        </div>
                    </div>
                    
                    <div class="planet-stats">
                        <div class="stat-item">
                            <div class="stat-value">0.39 AU</div>
                            <div class="stat-label">è·ç¦»å¤ªé˜³</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">88å¤©</div>
                            <div class="stat-label">å…¬è½¬å‘¨æœŸ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">4,879km</div>
                            <div class="stat-label">ç›´å¾„</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">427Â°C</div>
                            <div class="stat-label">æœ€é«˜æ¸©åº¦</div>
                        </div>
                    </div>
                    
                    <div class="planet-description">
                        æ°´æ˜Ÿæ˜¯å¤ªé˜³ç³»ä¸­æœ€å°çš„è¡Œæ˜Ÿï¼Œä¹Ÿæ˜¯è·ç¦»å¤ªé˜³æœ€è¿‘çš„è¡Œæ˜Ÿã€‚ç”±äºæ²¡æœ‰å¤§æ°”å±‚ä¿æŠ¤ï¼Œæ°´æ˜Ÿè¡¨é¢æ¸©å·®æå¤§ï¼Œç™½å¤©å¯è¾¾427Â°Cï¼Œå¤œæ™šå¯é™è‡³-173Â°Cã€‚
                    </div>
                    
                    <div class="planet-features">
                        <span class="feature-badge">æ— å¤§æ°”å±‚</span>
                        <span class="feature-badge">æç«¯æ¸©å·®</span>
                        <span class="feature-badge">å¤šé™¨çŸ³å‘</span>
                        <span class="feature-badge">é“æ ¸å æ¯”å¤§</span>
                    </div>
                </div>

                <!-- é‡‘æ˜Ÿ -->
                <div class="planet-card">
                    <div class="planet-header">
                        <div class="planet-icon planet-venus">
                            <i class="fas fa-circle"></i>
                        </div>
                        <div class="planet-info">
                            <h3>é‡‘æ˜Ÿ Venus</h3>
                            <div class="planet-subtitle">å¤ªé˜³ç³»æœ€çƒ­çš„è¡Œæ˜Ÿ</div>
                        </div>
                    </div>
                    
                    <div class="planet-stats">
                        <div class="stat-item">
                            <div class="stat-value">0.72 AU</div>
                            <div class="stat-label">è·ç¦»å¤ªé˜³</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">225å¤©</div>
                            <div class="stat-label">å…¬è½¬å‘¨æœŸ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">12,104km</div>
                            <div class="stat-label">ç›´å¾„</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">462Â°C</div>
                            <div class="stat-label">è¡¨é¢æ¸©åº¦</div>
                        </div>
                    </div>
                    
                    <div class="planet-description">
                        é‡‘æ˜Ÿè¢«ç§°ä¸ºåœ°çƒçš„"å§Šå¦¹æ˜Ÿ"ï¼Œå¤§å°ç›¸è¿‘ä½†ç¯å¢ƒæˆªç„¶ä¸åŒã€‚æµ“åšçš„äºŒæ°§åŒ–ç¢³å¤§æ°”å±‚é€ æˆå¼ºçƒˆçš„æ¸©å®¤æ•ˆåº”ï¼Œä½¿å…¶æˆä¸ºå¤ªé˜³ç³»æœ€çƒ­çš„è¡Œæ˜Ÿã€‚
                    </div>
                    
                    <div class="planet-features">
                        <span class="feature-badge">æµ“åšå¤§æ°”</span>
                        <span class="feature-badge">æ¸©å®¤æ•ˆåº”</span>
                        <span class="feature-badge">é€†å‘è‡ªè½¬</span>
                        <span class="feature-badge">ç¡«é…¸äº‘å±‚</span>
                    </div>
                </div>

                <!-- åœ°çƒ -->
                <div class="planet-card">
                    <div class="planet-header">
                        <div class="planet-icon planet-earth">
                            <i class="fas fa-globe"></i>
                        </div>
                        <div class="planet-info">
                            <h3>åœ°çƒ Earth</h3>
                            <div class="planet-subtitle">æˆ‘ä»¬çš„å®¶å›­</div>
                        </div>
                    </div>
                    
                    <div class="planet-stats">
                        <div class="stat-item">
                            <div class="stat-value">1.00 AU</div>
                            <div class="stat-label">è·ç¦»å¤ªé˜³</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">365å¤©</div>
                            <div class="stat-label">å…¬è½¬å‘¨æœŸ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">12,756km</div>
                            <div class="stat-label">ç›´å¾„</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">15Â°C</div>
                            <div class="stat-label">å¹³å‡æ¸©åº¦</div>
                        </div>
                    </div>
                    
                    <div class="planet-description">
                        åœ°çƒæ˜¯å¤ªé˜³ç³»ä¸­å”¯ä¸€å·²çŸ¥å­˜åœ¨ç”Ÿå‘½çš„è¡Œæ˜Ÿã€‚æ‹¥æœ‰æ¶²æ€æ°´ã€é€‚å®œçš„å¤§æ°”å±‚å’Œç£åœºä¿æŠ¤ï¼Œä¸ºç”Ÿå‘½çš„å­˜åœ¨å’Œæ¼”åŒ–æä¾›äº†å®Œç¾çš„æ¡ä»¶ã€‚
                    </div>
                    
                    <div class="planet-features">
                        <span class="feature-badge">æ¶²æ€æ°´</span>
                        <span class="feature-badge">ç”Ÿå‘½å­˜åœ¨</span>
                        <span class="feature-badge">ç£åœºä¿æŠ¤</span>
                        <span class="feature-badge">æ¿å—è¿åŠ¨</span>
                    </div>
                </div>

                <!-- ç«æ˜Ÿ -->
                <div class="planet-card">
                    <div class="planet-header">
                        <div class="planet-icon planet-mars">
                            <i class="fas fa-circle"></i>
                        </div>
                        <div class="planet-info">
                            <h3>ç«æ˜Ÿ Mars</h3>
                            <div class="planet-subtitle">çº¢è‰²æ˜Ÿçƒ</div>
                        </div>
                    </div>
                    
                    <div class="planet-stats">
                        <div class="stat-item">
                            <div class="stat-value">1.52 AU</div>
                            <div class="stat-label">è·ç¦»å¤ªé˜³</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">687å¤©</div>
                            <div class="stat-label">å…¬è½¬å‘¨æœŸ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">6,792km</div>
                            <div class="stat-label">ç›´å¾„</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">-65Â°C</div>
                            <div class="stat-label">å¹³å‡æ¸©åº¦</div>
                        </div>
                    </div>
                    
                    <div class="planet-description">
                        ç«æ˜Ÿå› å…¶çº¢è‰²å¤–è§‚è€Œå¾—åï¼Œè¿™æ˜¯ç”±äºè¡¨é¢å¯Œå«æ°§åŒ–é“ã€‚ç«æ˜Ÿæ‹¥æœ‰å¤ªé˜³ç³»æœ€å¤§çš„ç«å±±å’Œå³¡è°·ï¼Œæ˜¯äººç±»æœªæ¥ç§»æ°‘çš„é‡è¦å€™é€‰åœ°ã€‚
                    </div>
                    
                    <div class="planet-features">
                        <span class="feature-badge">æåœ°å†°å¸½</span>
                        <span class="feature-badge">å¥¥æ—åŒ¹æ–¯å±±</span>
                        <span class="feature-badge">æ°´æ‰‹å³¡è°·</span>
                        <span class="feature-badge">ä¸¤é¢—å«æ˜Ÿ</span>
                    </div>
                </div>

                <!-- æœ¨æ˜Ÿ -->
                <div class="planet-card">
                    <div class="planet-header">
                        <div class="planet-icon planet-jupiter">
                            <i class="fas fa-circle"></i>
                        </div>
                        <div class="planet-info">
                            <h3>æœ¨æ˜Ÿ Jupiter</h3>
                            <div class="planet-subtitle">æ°”æ€å·¨è¡Œæ˜Ÿ</div>
                        </div>
                    </div>
                    
                    <div class="planet-stats">
                        <div class="stat-item">
                            <div class="stat-value">5.20 AU</div>
                            <div class="stat-label">è·ç¦»å¤ªé˜³</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">12å¹´</div>
                            <div class="stat-label">å…¬è½¬å‘¨æœŸ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">142,984km</div>
                            <div class="stat-label">ç›´å¾„</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">79é¢—</div>
                            <div class="stat-label">å·²çŸ¥å«æ˜Ÿ</div>
                        </div>
                    </div>
                    
                    <div class="planet-description">
                        æœ¨æ˜Ÿæ˜¯å¤ªé˜³ç³»æœ€å¤§çš„è¡Œæ˜Ÿï¼Œè´¨é‡è¶…è¿‡å…¶ä»–æ‰€æœ‰è¡Œæ˜Ÿçš„æ€»å’Œã€‚å®ƒçš„å¤§çº¢æ–‘æ˜¯ä¸€ä¸ªæŒç»­äº†æ•°ç™¾å¹´çš„å·¨å¤§é£æš´ï¼Œæ¯”åœ°çƒè¿˜è¦å¤§ã€‚
                    </div>
                    
                    <div class="planet-features">
                        <span class="feature-badge">å¤§çº¢æ–‘</span>
                        <span class="feature-badge">ä¼½åˆ©ç•¥å«æ˜Ÿ</span>
                        <span class="feature-badge">ç¯ç³»ç»Ÿ</span>
                        <span class="feature-badge">è¾å°„å¸¦</span>
                    </div>
                </div>

                <!-- åœŸæ˜Ÿ -->
                <div class="planet-card">
                    <div class="planet-header">
                        <div class="planet-icon planet-saturn">
                            <i class="fas fa-circle"></i>
                        </div>
                        <div class="planet-info">
                            <h3>åœŸæ˜Ÿ Saturn</h3>
                            <div class="planet-subtitle">ç¯ä¹‹ç‹</div>
                        </div>
                    </div>
                    
                    <div class="planet-stats">
                        <div class="stat-item">
                            <div class="stat-value">9.58 AU</div>
                            <div class="stat-label">è·ç¦»å¤ªé˜³</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">29å¹´</div>
                            <div class="stat-label">å…¬è½¬å‘¨æœŸ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">120,536km</div>
                            <div class="stat-label">ç›´å¾„</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">82é¢—</div>
                            <div class="stat-label">å·²çŸ¥å«æ˜Ÿ</div>
                        </div>
                    </div>
                    
                    <div class="planet-description">
                        åœŸæ˜Ÿä»¥å…¶å£®è§‚çš„ç¯ç³»ç»Ÿè€Œé—»åï¼Œè¿™äº›ç¯ä¸»è¦ç”±å†°å—å’Œå²©çŸ³ç¢ç‰‡ç»„æˆã€‚åœŸæ˜Ÿçš„å¯†åº¦å¾ˆä½ï¼Œå¦‚æœæœ‰è¶³å¤Ÿå¤§çš„æµ·æ´‹ï¼Œå®ƒç”šè‡³èƒ½æµ®åœ¨æ°´é¢ä¸Šã€‚
                    </div>
                    
                    <div class="planet-features">
                        <span class="feature-badge">å£®è§‚ç¯ç³»ç»Ÿ</span>
                        <span class="feature-badge">æ³°å¦å«æ˜Ÿ</span>
                        <span class="feature-badge">ä½å¯†åº¦</span>
                        <span class="feature-badge">å…­è¾¹å½¢é£æš´</span>
                    </div>
                </div>

                <!-- å¤©ç‹æ˜Ÿ -->
                <div class="planet-card">
                    <div class="planet-header">
                        <div class="planet-icon planet-uranus">
                            <i class="fas fa-circle"></i>
                        </div>
                        <div class="planet-info">
                            <h3>å¤©ç‹æ˜Ÿ Uranus</h3>
                            <div class="planet-subtitle">ä¾§èººçš„è¡Œæ˜Ÿ</div>
                        </div>
                    </div>
                    
                    <div class="planet-stats">
                        <div class="stat-item">
                            <div class="stat-value">19.20 AU</div>
                            <div class="stat-label">è·ç¦»å¤ªé˜³</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">84å¹´</div>
                            <div class="stat-label">å…¬è½¬å‘¨æœŸ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">51,118km</div>
                            <div class="stat-label">ç›´å¾„</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">27é¢—</div>
                            <div class="stat-label">å·²çŸ¥å«æ˜Ÿ</div>
                        </div>
                    </div>
                    
                    <div class="planet-description">
                        å¤©ç‹æ˜Ÿæ˜¯ä¸€é¢—ç‹¬ç‰¹çš„è¡Œæ˜Ÿï¼Œå®ƒå‡ ä¹æ˜¯ä¾§èººç€ç»•å¤ªé˜³å…¬è½¬çš„ã€‚è¿™ç§æç«¯çš„å€¾æ–œå¯èƒ½æ˜¯ç”±äºæ—©æœŸä¸å…¶ä»–å¤©ä½“çš„ç¢°æ’é€ æˆçš„ã€‚
                    </div>
                    
                    <div class="planet-features">
                        <span class="feature-badge">æç«¯å€¾æ–œ</span>
                        <span class="feature-badge">å†°å·¨è¡Œæ˜Ÿ</span>
                        <span class="feature-badge">å¾®å¼±ç¯ç³»ç»Ÿ</span>
                        <span class="feature-badge">ç”²çƒ·å¤§æ°”</span>
                    </div>
                </div>

                <!-- æµ·ç‹æ˜Ÿ -->
                <div class="planet-card">
                    <div class="planet-header">
                        <div class="planet-icon planet-neptune">
                            <i class="fas fa-circle"></i>
                        </div>
                        <div class="planet-info">
                            <h3>æµ·ç‹æ˜Ÿ Neptune</h3>
                            <div class="planet-subtitle">é£æš´ä¹‹ç‹</div>
                        </div>
                    </div>
                    
                    <div class="planet-stats">
                        <div class="stat-item">
                            <div class="stat-value">30.05 AU</div>
                            <div class="stat-label">è·ç¦»å¤ªé˜³</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">165å¹´</div>
                            <div class="stat-label">å…¬è½¬å‘¨æœŸ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">49,528km</div>
                            <div class="stat-label">ç›´å¾„</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">14é¢—</div>
                            <div class="stat-label">å·²çŸ¥å«æ˜Ÿ</div>
                        </div>
                    </div>
                    
                    <div class="planet-description">
                        æµ·ç‹æ˜Ÿæ˜¯å¤ªé˜³ç³»æœ€å¤–å±‚çš„è¡Œæ˜Ÿï¼Œæ‹¥æœ‰å¤ªé˜³ç³»æœ€å¼ºçš„é£æš´ï¼Œé£é€Ÿå¯è¾¾æ¯å°æ—¶2100å…¬é‡Œã€‚å®ƒçš„æ·±è“è‰²æ¥è‡ªå¤§æ°”ä¸­çš„ç”²çƒ·ã€‚
                    </div>
                    
                    <div class="planet-features">
                        <span class="feature-badge">æœ€å¼ºé£æš´</span>
                        <span class="feature-badge">æµ·å«ä¸€</span>
                        <span class="feature-badge">æ·±è“è‰²</span>
                        <span class="feature-badge">æ•°å­¦å‘ç°</span>
                    </div>
                </div>
            </div>

            <div class="comparison-section">
                <h2>è¡Œæ˜Ÿå¤§å°æ¯”è¾ƒ</h2>
                <p>ç›´è§‚æ¯”è¾ƒå¤ªé˜³ç³»å„è¡Œæ˜Ÿçš„ç›¸å¯¹å¤§å°</p>
                
                <div class="size-comparison">
                    <div class="size-planet">
                        <div class="size-circle" style="width: 8px; height: 8px; background: #8C7853;"></div>
                        <div class="size-label">æ°´æ˜Ÿ</div>
                    </div>
                    <div class="size-planet">
                        <div class="size-circle" style="width: 12px; height: 12px; background: #FFC649;"></div>
                        <div class="size-label">é‡‘æ˜Ÿ</div>
                    </div>
                    <div class="size-planet">
                        <div class="size-circle" style="width: 13px; height: 13px; background: #6B93D6;"></div>
                        <div class="size-label">åœ°çƒ</div>
                    </div>
                    <div class="size-planet">
                        <div class="size-circle" style="width: 10px; height: 10px; background: #CD5C5C;"></div>
                        <div class="size-label">ç«æ˜Ÿ</div>
                    </div>
                    <div class="size-planet">
                        <div class="size-circle" style="width: 40px; height: 40px; background: #D2691E;"></div>
                        <div class="size-label">æœ¨æ˜Ÿ</div>
                    </div>
                    <div class="size-planet">
                        <div class="size-circle" style="width: 35px; height: 35px; background: #FAD5A5;"></div>
                        <div class="size-label">åœŸæ˜Ÿ</div>
                    </div>
                    <div class="size-planet">
                        <div class="size-circle" style="width: 18px; height: 18px; background: #4FD0E7;"></div>
                        <div class="size-label">å¤©ç‹æ˜Ÿ</div>
                    </div>
                    <div class="size-planet">
                        <div class="size-circle" style="width: 17px; height: 17px; background: #4169E1;"></div>
                        <div class="size-label">æµ·ç‹æ˜Ÿ</div>
                    </div>
                </div>
            </div>

            <!-- å¤©æ–‡ç°è±¡3Dæ¼”ç¤º -->
            <div class="phenomena-section">
                <h2><i class="fas fa-globe"></i> å¤©æ–‡ç°è±¡3Dæ¼”ç¤º</h2>
                <p>é€šè¿‡çœŸå®çš„3Dæ¨¡æ‹Ÿç†è§£åœ°çƒä¸Šçš„å¤©æ–‡ç°è±¡</p>
                
                <div class="phenomena-grid">
                    <!-- å››å­£å½¢æˆ -->
                    <div class="phenomenon-card">
                        <h3><i class="fas fa-leaf"></i> å››å­£å½¢æˆ</h3>
                        <div id="seasons-3d-container" class="phenomenon-3d-container">
                            <div class="phenomenon-controls">
                                <button id="seasons-play-pause" class="phenomenon-btn">â¸ï¸</button>
                                <button id="seasons-reset" class="phenomenon-btn">ğŸ”„</button>
                                <div class="speed-control">
                                    <label>é€Ÿåº¦:</label>
                                    <input type="range" id="seasons-speed" min="0.1" max="3" step="0.1" value="1">
                                    <span id="seasons-speed-value">1x</span>
                                </div>
                            </div>
                            <div class="phenomenon-info" id="seasons-info">
                                <div>å½“å‰å­£èŠ‚: <span id="current-season">æ˜¥åˆ†</span></div>
                                <div>åœ°è½´å€¾æ–œ: 23.5Â°</div>
                                <div>å¤ªé˜³ç›´å°„ç‚¹: <span id="sun-position">èµ¤é“</span></div>
                            </div>
                        </div>
                        <div class="explanation-box">
                            <h4>å½¢æˆåŸç†</h4>
                            <p>å››å­£çš„å½¢æˆæ˜¯ç”±äºåœ°çƒè‡ªè½¬è½´ç›¸å¯¹äºå…¬è½¬è½¨é“å¹³é¢å€¾æ–œ23.5Â°ã€‚å½“åœ°çƒç»•å¤ªé˜³å…¬è½¬æ—¶ï¼Œä¸åŒåœ°åŒºæ¥å—å¤ªé˜³è¾å°„çš„è§’åº¦å’Œæ—¶é•¿å‘ç”Ÿå˜åŒ–ï¼Œå½¢æˆæ˜¥å¤ç§‹å†¬å››å­£ã€‚</p>
                        </div>
                    </div>

                    <!-- æ—¥å¤œäº¤æ›¿ -->
                    <div class="phenomenon-card">
                        <h3><i class="fas fa-moon"></i> æ—¥å¤œäº¤æ›¿</h3>
                        <div id="day-night-3d-container" class="phenomenon-3d-container">
                            <div class="phenomenon-controls">
                                <button id="daynight-play-pause" class="phenomenon-btn">â¸ï¸</button>
                                <button id="daynight-reset" class="phenomenon-btn">ğŸ”„</button>
                                <div class="speed-control">
                                    <label>é€Ÿåº¦:</label>
                                    <input type="range" id="daynight-speed" min="0.1" max="5" step="0.1" value="2">
                                    <span id="daynight-speed-value">2x</span>
                                </div>
                            </div>
                            <div class="phenomenon-info" id="daynight-info">
                                <div>å½“å‰æ—¶é—´: <span id="current-time">12:00</span></div>
                                <div>è‡ªè½¬å‘¨æœŸ: 24å°æ—¶</div>
                                <div>æ˜¼å¤œåˆ†ç•Œçº¿: <span id="terminator-position">ç§»åŠ¨ä¸­</span></div>
                            </div>
                        </div>
                        <div class="explanation-box">
                            <h4>å½¢æˆåŸç†</h4>
                            <p>æ—¥å¤œäº¤æ›¿æ˜¯ç”±åœ°çƒè‡ªè½¬é€ æˆçš„ã€‚åœ°çƒç»•è‡ªè½¬è½´æ—‹è½¬ä¸€å‘¨çº¦24å°æ—¶ï¼Œé¢å‘å¤ªé˜³çš„ä¸€é¢æ˜¯ç™½å¤©ï¼ŒèƒŒç¦»å¤ªé˜³çš„ä¸€é¢æ˜¯é»‘å¤œã€‚åœ°çƒè‡ªè½¬ä½¿å¾—åœ°è¡¨å„ç‚¹è½®æµæ¥å—å¤ªé˜³ç…§å°„ï¼Œå½¢æˆæ˜¼å¤œå¾ªç¯ã€‚</p>
                        </div>
                    </div>

                    <!-- æ½®æ±ç°è±¡ -->
                    <div class="phenomenon-card">
                        <h3><i class="fas fa-water"></i> æ½®æ±ç°è±¡</h3>
                        <div id="tidal-3d-container" class="phenomenon-3d-container">
                            <div class="phenomenon-controls">
                                <button id="tidal-play-pause" class="phenomenon-btn">â¸ï¸</button>
                                <button id="tidal-reset" class="phenomenon-btn">ğŸ”„</button>
                                <div class="speed-control">
                                    <label>é€Ÿåº¦:</label>
                                    <input type="range" id="tidal-speed" min="0.1" max="4" step="0.1" value="1.5">
                                    <span id="tidal-speed-value">1.5x</span>
                                </div>
                            </div>
                            <div class="phenomenon-info" id="tidal-info">
                                <div>æ½®æ±çŠ¶æ€: <span id="tidal-state">æ¶¨æ½®</span></div>
                                <div>æœˆçƒä½ç½®: <span id="moon-phase">æ–°æœˆ</span></div>
                                <div>æ½®å·®: <span id="tidal-range">2.5ç±³</span></div>
                            </div>
                        </div>
                        <div class="explanation-box">
                            <h4>å½¢æˆåŸç†</h4>
                            <p>æ½®æ±æ˜¯ç”±æœˆçƒå’Œå¤ªé˜³çš„å¼•åŠ›ä½œç”¨å¼•èµ·çš„ã€‚æœˆçƒå¼•åŠ›ä½¿é¢å‘æœˆçƒçš„æµ·æ°´è¢«æ‹‰èµ·å½¢æˆé«˜æ½®ï¼ŒåŒæ—¶åœ°çƒèƒŒé¢ç”±äºæƒ¯æ€§åŠ›ä¹Ÿå½¢æˆé«˜æ½®ã€‚æœˆçƒç»•åœ°çƒå…¬è½¬ä½¿æ½®æ±ä½ç½®ä¸æ–­å˜åŒ–ï¼Œä¸€å¤©å†…é€šå¸¸æœ‰ä¸¤æ¬¡é«˜æ½®å’Œä¸¤æ¬¡ä½æ½®ã€‚</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="main-footer">
        <div class="container">
            <div class="footer-content">
                <p class="copyright-text">study-llm.meåŸŸåä¸ºAlexæ‰€æœ‰ã€‚ä¿ç•™æ‰€æœ‰æƒåˆ©ã€‚</p>
            </div>
        </div>
    </footer>

    <script src="../../js/common.js"></script>
    <script src="../../js/navigation.js"></script>
    <script>
        // 3D Solar System Implementation
        class SolarSystem3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.planets = {};
                this.orbits = {};
                this.isPlaying = true;
                this.speed = 1;
                this.showOrbits = true;
                this.focusedPlanet = 'overview';
                
                // Real astronomical data (scaled for visualization)
                this.planetData = {
                    sun: { distance: 0, size: 2, color: 0xFFD700, period: 0, texture: 'sun' },
                    mercury: { distance: 8, size: 0.3, color: 0x8C7853, period: 88, texture: 'mercury' },
                    venus: { distance: 12, size: 0.4, color: 0xFFC649, period: 225, texture: 'venus' },
                    earth: { distance: 16, size: 0.4, color: 0x6B93D6, period: 365, texture: 'earth' },
                    mars: { distance: 20, size: 0.35, color: 0xCD5C5C, period: 687, texture: 'mars' },
                    jupiter: { distance: 28, size: 1.2, color: 0xD2691E, period: 4333, texture: 'jupiter' },
                    saturn: { distance: 36, size: 1.0, color: 0xFAD5A5, period: 10759, texture: 'saturn' },
                    uranus: { distance: 44, size: 0.7, color: 0x4FD0E7, period: 30687, texture: 'uranus' },
                    neptune: { distance: 52, size: 0.7, color: 0x4169E1, period: 60190, texture: 'neptune' }
                };
                
                this.init();
            }

            async init() {
                try {
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLights();
                    this.setupControls();
                    
                    await this.createSolarSystem();
                    this.setupEventListeners();
                    this.animate();
                    
                    document.getElementById('solar-system-loading').style.display = 'none';
                } catch (error) {
                    console.error('Failed to initialize 3D solar system:', error);
                    this.showFallbackMessage();
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000011);
                this.createStarField();
            }

            setupCamera() {
                const container = document.getElementById('solar-system-container');
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.set(0, 30, 60);
            }

            setupRenderer() {
                const container = document.getElementById('solar-system-container');
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                container.appendChild(this.renderer.domElement);
            }

            setupLights() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(ambientLight);
                
                // Point light (sun)
                const sunLight = new THREE.PointLight(0xFFFFFF, 2, 200);
                sunLight.position.set(0, 0, 0);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                this.scene.add(sunLight);
            }

            setupControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = 5;
                this.controls.maxDistance = 200;
                
                // Enable touch controls for mobile
                this.controls.touches = {
                    ONE: THREE.TOUCH.ROTATE,
                    TWO: THREE.TOUCH.DOLLY_PAN
                };
                
                // Smooth controls
                this.controls.enableZoom = true;
                this.controls.enablePan = true;
                this.controls.enableRotate = true;
                
                // Auto-rotate when idle (optional)
                this.controls.autoRotate = false;
                this.controls.autoRotateSpeed = 0.5;
            }

            createStarField() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
                
                const starsVertices = [];
                for (let i = 0; i < 10000; i++) {
                    const x = (Math.random() - 0.5) * 2000;
                    const y = (Math.random() - 0.5) * 2000;
                    const z = (Math.random() - 0.5) * 2000;
                    starsVertices.push(x, y, z);
                }
                
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(stars);
            }

            async createSolarSystem() {
                // Create planets
                for (const [name, data] of Object.entries(this.planetData)) {
                    await this.createPlanet(name, data);
                }
                
                // Create orbit lines
                this.createOrbitLines();
                
                // Create asteroid belt
                this.createAsteroidBelt();
                
                // Add some comets
                this.createComets();
            }

            async createPlanet(name, data) {
                const geometry = new THREE.SphereGeometry(data.size, 32, 32);
                
                // Load planet texture
                const texture = await this.loadPlanetTexture(name);
                const material = new THREE.MeshPhongMaterial({ 
                    map: texture,
                    color: texture ? 0xffffff : data.color, // Use color as fallback
                    shininess: name === 'sun' ? 0 : 30,
                    transparent: name === 'sun',
                    opacity: name === 'sun' ? 0.9 : 1.0,
                    emissive: name === 'sun' ? 0xFFAA00 : 0x000000,
                    emissiveIntensity: name === 'sun' ? 0.8 : 0
                });
                
                const planet = new THREE.Mesh(geometry, material);
                
                if (name === 'sun') {
                    // Enhanced 3D Sun at center with multiple glow layers
                    planet.position.set(0, 0, 0);
                    
                    // Add multiple glow layers for realistic sun effect
                    const glowGeometry1 = new THREE.SphereGeometry(data.size * 1.15, 32, 32);
                    const glowMaterial1 = new THREE.MeshBasicMaterial({
                        color: 0xFFD700,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.BackSide
                    });
                    const glow1 = new THREE.Mesh(glowGeometry1, glowMaterial1);
                    planet.add(glow1);
                    
                    const glowGeometry2 = new THREE.SphereGeometry(data.size * 1.4, 32, 32);
                    const glowMaterial2 = new THREE.MeshBasicMaterial({
                        color: 0xFF6600,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.BackSide
                    });
                    const glow2 = new THREE.Mesh(glowGeometry2, glowMaterial2);
                    planet.add(glow2);
                    
                    // Add corona effect
                    const coronaGeometry = new THREE.SphereGeometry(data.size * 1.8, 32, 32);
                    const coronaMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFDD44,
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.BackSide
                    });
                    const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                    planet.add(corona);
                    
                    // Add solar flares (particle system)
                    this.createSolarFlares(planet);
                } else {
                    // Planets start at their orbital distance
                    planet.position.set(data.distance, 0, 0);
                    planet.castShadow = true;
                    planet.receiveShadow = true;
                }
                
                // Add to scene and store reference
                this.scene.add(planet);
                this.planets[name] = {
                    mesh: planet,
                    data: data,
                    angle: Math.random() * Math.PI * 2, // Random starting position
                    group: new THREE.Group()
                };
                
                // Create planet group for orbital motion
                if (name !== 'sun') {
                    this.planets[name].group.add(planet);
                    this.scene.add(this.planets[name].group);
                }
                
                // Special handling for Saturn's rings
                if (name === 'saturn') {
                    this.createSaturnRings(planet);
                }
            }

            createSolarFlares(sun) {
                // Create solar flare particles
                const flareCount = 150;
                const flareGeometry = new THREE.BufferGeometry();
                const flarePositions = [];
                const flareSizes = [];
                
                for (let i = 0; i < flareCount; i++) {
                    // Random positions around the sun
                    const radius = 2.2 + Math.random() * 1.5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    flarePositions.push(x, y, z);
                    flareSizes.push(Math.random() * 0.15 + 0.05);
                }
                
                flareGeometry.setAttribute('position', new THREE.Float32BufferAttribute(flarePositions, 3));
                flareGeometry.setAttribute('size', new THREE.Float32BufferAttribute(flareSizes, 1));
                
                const flareMaterial = new THREE.PointsMaterial({
                    color: 0xFFAA00,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const flares = new THREE.Points(flareGeometry, flareMaterial);
                sun.add(flares);
                
                // Store reference for animation
                this.solarFlares = flares;
            }

            createSaturnRings(saturn) {
                const ringGeometry = new THREE.RingGeometry(1.2, 2.0, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFAD5A5,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                rings.rotation.x = Math.PI / 2;
                saturn.add(rings);
            }

            createOrbitLines() {
                for (const [name, data] of Object.entries(this.planetData)) {
                    if (name === 'sun') continue;
                    
                    const points = [];
                    const segments = 64;
                    
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        points.push(new THREE.Vector3(
                            Math.cos(angle) * data.distance,
                            0,
                            Math.sin(angle) * data.distance
                        ));
                    }
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: 0x444444,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    const orbit = new THREE.Line(geometry, material);
                    this.scene.add(orbit);
                    this.orbits[name] = orbit;
                }
            }

            createAsteroidBelt() {
                // Create asteroid belt between Mars and Jupiter
                const asteroidCount = 200;
                const innerRadius = 22; // Between Mars (20) and Jupiter (28)
                const outerRadius = 26;
                
                this.asteroids = [];
                
                for (let i = 0; i < asteroidCount; i++) {
                    const geometry = new THREE.SphereGeometry(0.02 + Math.random() * 0.03, 8, 8);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x666666,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const asteroid = new THREE.Mesh(geometry, material);
                    
                    // Random position in belt
                    const angle = Math.random() * Math.PI * 2;
                    const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                    const height = (Math.random() - 0.5) * 2; // Some vertical spread
                    
                    asteroid.position.set(
                        Math.cos(angle) * distance,
                        height,
                        Math.sin(angle) * distance
                    );
                    
                    this.scene.add(asteroid);
                    this.asteroids.push({
                        mesh: asteroid,
                        angle: angle,
                        distance: distance,
                        speed: 0.001 + Math.random() * 0.002
                    });
                }
            }

            createComets() {
                // Create a few comets with elliptical orbits
                this.comets = [];
                const cometCount = 3;
                
                for (let i = 0; i < cometCount; i++) {
                    // Comet head
                    const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0xaaaaff,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const comet = new THREE.Mesh(geometry, material);
                    
                    // Comet tail (simple line)
                    const tailGeometry = new THREE.BufferGeometry();
                    const tailPoints = [];
                    for (let j = 0; j < 20; j++) {
                        tailPoints.push(new THREE.Vector3(0, 0, -j * 0.5));
                    }
                    tailGeometry.setFromPoints(tailPoints);
                    
                    const tailMaterial = new THREE.LineBasicMaterial({
                        color: 0x88aaff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const tail = new THREE.Line(tailGeometry, tailMaterial);
                    comet.add(tail);
                    
                    this.scene.add(comet);
                    this.comets.push({
                        mesh: comet,
                        angle: Math.random() * Math.PI * 2,
                        eccentricity: 0.7 + Math.random() * 0.2,
                        semiMajorAxis: 40 + Math.random() * 20,
                        speed: 0.005 + Math.random() * 0.01
                    });
                }
            }

            async loadPlanetTexture(planetName) {
                // Use multiple fallback sources for planet textures
                const textureUrls = {
                    sun: [
                        'https://threejs.org/examples/textures/planets/sun.jpg',
                        'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/sun.jpg',
                        'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/textures/planets/sun.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_sun.jpg'
                    ],
                    mercury: [
                        'https://threejs.org/examples/textures/planets/mercury.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_mercury.jpg'
                    ],
                    venus: [
                        'https://threejs.org/examples/textures/planets/venus_surface.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_venus_surface.jpg'
                    ],
                    earth: [
                        'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_earth_daymap.jpg',
                        'https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg'
                    ],
                    earth_night: [
                        'https://www.solarsystemscope.com/textures/download/2k_earth_nightmap.jpg',
                        'https://threejs.org/examples/textures/planets/earth_lights_2048.png'
                    ],
                    earth_clouds: [
                        'https://www.solarsystemscope.com/textures/download/2k_earth_clouds.jpg',
                        'https://threejs.org/examples/textures/planets/earth_clouds_1024.png'
                    ],
                    moon: [
                        'https://www.solarsystemscope.com/textures/download/2k_moon.jpg',
                        'https://threejs.org/examples/textures/planets/moon_1024.jpg'
                    ],
                    mars: [
                        'https://threejs.org/examples/textures/planets/mars_1k_color.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_mars.jpg'
                    ],
                    jupiter: [
                        'https://threejs.org/examples/textures/planets/jupiter_2k.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_jupiter.jpg'
                    ],
                    saturn: [
                        'https://threejs.org/examples/textures/planets/saturn_2k.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_saturn.jpg'
                    ],
                    uranus: [
                        'https://threejs.org/examples/textures/planets/uranus_2k.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_uranus.jpg'
                    ],
                    neptune: [
                        'https://threejs.org/examples/textures/planets/neptune_2k.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_neptune.jpg'
                    ]
                };
                
                const urls = textureUrls[planetName] || textureUrls.earth;
                
                return new Promise((resolve) => {
                    const loader = new THREE.TextureLoader();
                    
                    const tryLoadTexture = (urlIndex = 0) => {
                        if (urlIndex >= urls.length) {
                            console.log(`Failed to load texture for ${planetName}, using fallback color`);
                            resolve(null);
                            return;
                        }
                        
                        loader.load(
                            urls[urlIndex],
                            (texture) => {
                                console.log(`Successfully loaded texture for ${planetName} from source ${urlIndex + 1}`);
                                resolve(texture);
                            },
                            undefined,
                            (error) => {
                                console.log(`Failed to load texture for ${planetName} from source ${urlIndex + 1}, trying next...`);
                                tryLoadTexture(urlIndex + 1);
                            }
                        );
                    };
                    
                    tryLoadTexture();
                });
            }

            // Create realistic Earth with day/night textures and clouds
            async createRealisticEarth(size = 1.2, position = [0, 0, 0]) {
                const earthGroup = new THREE.Group();
                
                // Load textures
                const dayTexture = await this.loadPlanetTexture('earth');
                const nightTexture = await this.loadPlanetTexture('earth_night');
                const cloudsTexture = await this.loadPlanetTexture('earth_clouds');
                
                // Earth sphere with day texture
                const earthGeometry = new THREE.SphereGeometry(size, 64, 64);
                const earthMaterial = new THREE.MeshPhongMaterial({
                    map: dayTexture,
                    bumpMap: dayTexture,
                    bumpScale: 0.05,
                    specularMap: dayTexture,
                    specular: new THREE.Color('grey'),
                    shininess: 100
                });
                
                const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earth.castShadow = true;
                earth.receiveShadow = true;
                earthGroup.add(earth);
                
                // Apply 23.5 degree axial tilt
                earthGroup.rotation.z = Math.PI * 23.5 / 180;
                
                // Cloud layer
                if (cloudsTexture) {
                    const cloudGeometry = new THREE.SphereGeometry(size * 1.02, 64, 64);
                    const cloudMaterial = new THREE.MeshPhongMaterial({
                        map: cloudsTexture,
                        transparent: true,
                        opacity: 0.3
                    });
                    const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    earthGroup.add(clouds);
                    
                    // Store cloud reference for animation
                    earthGroup.clouds = clouds;
                }
                
                // Atmosphere glow
                const atmosphereGeometry = new THREE.SphereGeometry(size * 1.05, 32, 32);
                const atmosphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                earthGroup.add(atmosphere);
                
                earthGroup.position.set(...position);
                return earthGroup;
            }

            // Create realistic Sun with surface texture and corona
            async createRealisticSun(size = 2, position = [0, 0, 0]) {
                const sunGroup = new THREE.Group();
                
                // Load sun texture
                const sunTexture = await this.loadPlanetTexture('sun');
                
                // Sun sphere with realistic surface
                const sunGeometry = new THREE.SphereGeometry(size, 64, 64);
                const sunMaterial = new THREE.MeshPhongMaterial({
                    map: sunTexture,
                    emissive: 0xFFAA00,
                    emissiveIntensity: 0.8,
                    emissiveMap: sunTexture
                });
                
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                sunGroup.add(sun);
                
                // Corona layers for realistic glow
                const coronaLayers = [
                    { size: size * 1.1, color: 0xFFD700, opacity: 0.4 },
                    { size: size * 1.3, color: 0xFF6600, opacity: 0.2 },
                    { size: size * 1.6, color: 0xFFDD44, opacity: 0.1 }
                ];
                
                coronaLayers.forEach(layer => {
                    const coronaGeometry = new THREE.SphereGeometry(layer.size, 32, 32);
                    const coronaMaterial = new THREE.MeshBasicMaterial({
                        color: layer.color,
                        transparent: true,
                        opacity: layer.opacity,
                        side: THREE.BackSide
                    });
                    const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                    sunGroup.add(corona);
                });
                
                // Solar flares particle system
                this.createEnhancedSolarFlares(sunGroup, size);
                
                sunGroup.position.set(...position);
                return sunGroup;
            }

            // Create realistic Moon with surface details
            async createRealisticMoon(size = 0.6, position = [0, 0, 0]) {
                const moonGroup = new THREE.Group();
                
                // Load moon texture
                const moonTexture = await this.loadPlanetTexture('moon');
                
                // Moon sphere with realistic surface
                const moonGeometry = new THREE.SphereGeometry(size, 64, 64);
                const moonMaterial = new THREE.MeshPhongMaterial({
                    map: moonTexture,
                    bumpMap: moonTexture,
                    bumpScale: 0.1,
                    shininess: 1
                });
                
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.castShadow = true;
                moon.receiveShadow = true;
                moonGroup.add(moon);
                
                // Subtle glow for moon
                const glowGeometry = new THREE.SphereGeometry(size * 1.1, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xC0C0C0,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                moonGroup.add(glow);
                
                moonGroup.position.set(...position);
                return moonGroup;
            }

            createEnhancedSolarFlares(sunGroup, sunSize) {
                // Create more realistic solar flare particles
                const flareCount = 200;
                const flareGeometry = new THREE.BufferGeometry();
                const flarePositions = [];
                const flareSizes = [];
                const flareColors = [];
                
                for (let i = 0; i < flareCount; i++) {
                    // Random positions around the sun surface
                    const radius = sunSize + Math.random() * (sunSize * 0.5);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    flarePositions.push(x, y, z);
                    flareSizes.push(Math.random() * 0.2 + 0.1);
                    
                    // Vary colors from yellow to orange to red
                    const colorVariation = Math.random();
                    if (colorVariation < 0.4) {
                        flareColors.push(1, 1, 0); // Yellow
                    } else if (colorVariation < 0.7) {
                        flareColors.push(1, 0.5, 0); // Orange
                    } else {
                        flareColors.push(1, 0.2, 0); // Red-orange
                    }
                }
                
                flareGeometry.setAttribute('position', new THREE.Float32BufferAttribute(flarePositions, 3));
                flareGeometry.setAttribute('size', new THREE.Float32BufferAttribute(flareSizes, 1));
                flareGeometry.setAttribute('color', new THREE.Float32BufferAttribute(flareColors, 3));
                
                const flareMaterial = new THREE.PointsMaterial({
                    size: 0.15,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true
                });
                
                const flares = new THREE.Points(flareGeometry, flareMaterial);
                sunGroup.add(flares);
                
                // Store reference for animation
                sunGroup.solarFlares = flares;
                return flares;
            }

            setupEventListeners() {
                // Control buttons
                document.getElementById('play-pause').addEventListener('click', () => {
                    this.togglePlayPause();
                });
                
                document.getElementById('speed-up').addEventListener('click', () => {
                    this.speed = Math.min(this.speed * 2, 16);
                    this.updateSpeedDisplay();
                });
                
                document.getElementById('speed-down').addEventListener('click', () => {
                    this.speed = Math.max(this.speed / 2, 0.125);
                    this.updateSpeedDisplay();
                });
                
                document.getElementById('reset-view').addEventListener('click', () => {
                    this.resetView();
                });
                
                document.getElementById('toggle-orbits').addEventListener('click', () => {
                    this.toggleOrbits();
                });
                
                document.getElementById('planet-focus').addEventListener('change', (e) => {
                    this.focusOnPlanet(e.target.value);
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.onWindowResize();
                });
                
                // Planet click interaction
                this.renderer.domElement.addEventListener('click', (event) => {
                    this.onPlanetClick(event);
                });
                
                // Planet hover interaction
                this.renderer.domElement.addEventListener('mousemove', (event) => {
                    this.onPlanetHover(event);
                });
            }

            togglePlayPause() {
                this.isPlaying = !this.isPlaying;
                const button = document.getElementById('play-pause');
                button.textContent = this.isPlaying ? 'â¸ï¸' : 'â–¶ï¸';
                button.style.background = this.isPlaying ? 
                    'rgba(255, 255, 255, 0.95)' : 'rgba(67, 97, 238, 0.9)';
                button.style.color = this.isPlaying ? '#333' : 'white';
            }

            updateSpeedDisplay() {
                const info = document.getElementById('current-planet-info');
                const speedText = `é€Ÿåº¦: ${this.speed}x`;
                info.innerHTML = info.innerHTML.split('<br>')[0] + '<br>' + speedText + '<br>æ‹–æ‹½æ—‹è½¬è§†è§’<br>æ»šè½®ç¼©æ”¾è·ç¦»';
            }

            resetView() {
                this.camera.position.set(0, 30, 60);
                this.controls.reset();
                this.focusedPlanet = 'overview';
                document.getElementById('planet-focus').value = 'overview';
                this.updatePlanetInfo('overview');
            }

            toggleOrbits() {
                this.showOrbits = !this.showOrbits;
                Object.values(this.orbits).forEach(orbit => {
                    orbit.visible = this.showOrbits;
                });
                
                const button = document.getElementById('toggle-orbits');
                button.style.background = this.showOrbits ? 
                    'rgba(255, 255, 255, 0.95)' : 'rgba(67, 97, 238, 0.9)';
                button.style.color = this.showOrbits ? '#333' : 'white';
            }

            focusOnPlanet(planetName) {
                this.focusedPlanet = planetName;
                
                if (planetName === 'overview') {
                    this.resetView();
                    return;
                }
                
                const planet = this.planets[planetName];
                if (planet) {
                    const position = planet.mesh.position.clone();
                    const distance = planet.data.size * 8;
                    
                    this.camera.position.set(
                        position.x + distance,
                        position.y + distance/2,
                        position.z + distance
                    );
                    this.controls.target.copy(position);
                    this.controls.update();
                    
                    this.updatePlanetInfo(planetName);
                }
            }

            updatePlanetInfo(planetName) {
                const info = document.getElementById('current-planet-info');
                const planetNames = {
                    overview: 'å¤ªé˜³ç³»å…¨æ™¯',
                    sun: 'å¤ªé˜³',
                    mercury: 'æ°´æ˜Ÿ',
                    venus: 'é‡‘æ˜Ÿ',
                    earth: 'åœ°çƒ',
                    mars: 'ç«æ˜Ÿ',
                    jupiter: 'æœ¨æ˜Ÿ',
                    saturn: 'åœŸæ˜Ÿ',
                    uranus: 'å¤©ç‹æ˜Ÿ',
                    neptune: 'æµ·ç‹æ˜Ÿ'
                };
                
                if (planetName === 'overview') {
                    info.innerHTML = `
                        <strong>${planetNames[planetName]}</strong><br>
                        é€Ÿåº¦: ${this.speed}x<br>
                        æ‹–æ‹½æ—‹è½¬è§†è§’<br>
                        æ»šè½®ç¼©æ”¾è·ç¦»<br>
                        é€‰æ‹©è¡Œæ˜Ÿèšç„¦è§‚å¯Ÿ
                    `;
                } else {
                    const data = this.planetData[planetName];
                    info.innerHTML = `
                        <strong>${planetNames[planetName]}</strong><br>
                        è·ç¦»: ${data.distance} AU<br>
                        å¤§å°: ${data.size} å€åœ°çƒ<br>
                        å…¬è½¬å‘¨æœŸ: ${data.period} å¤©
                    `;
                }
            }

            onWindowResize() {
                const container = document.getElementById('solar-system-container');
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            onPlanetClick(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                
                const planetMeshes = Object.values(this.planets).map(p => p.mesh);
                const intersects = raycaster.intersectObjects(planetMeshes);
                
                if (intersects.length > 0) {
                    const clickedPlanet = intersects[0].object;
                    const planetName = Object.keys(this.planets).find(
                        name => this.planets[name].mesh === clickedPlanet
                    );
                    
                    if (planetName) {
                        this.focusOnPlanet(planetName);
                        document.getElementById('planet-focus').value = planetName;
                    }
                }
            }

            onPlanetHover(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                
                const planetMeshes = Object.values(this.planets).map(p => p.mesh);
                const intersects = raycaster.intersectObjects(planetMeshes);
                
                if (intersects.length > 0) {
                    this.renderer.domElement.style.cursor = 'pointer';
                    
                    const hoveredPlanet = intersects[0].object;
                    const planetName = Object.keys(this.planets).find(
                        name => this.planets[name].mesh === hoveredPlanet
                    );
                    
                    if (planetName && planetName !== this.focusedPlanet) {
                        this.showPlanetTooltip(event, planetName);
                    }
                } else {
                    this.renderer.domElement.style.cursor = 'grab';
                    this.hidePlanetTooltip();
                }
            }

            showPlanetTooltip(event, planetName) {
                const planetNames = {
                    sun: 'å¤ªé˜³',
                    mercury: 'æ°´æ˜Ÿ',
                    venus: 'é‡‘æ˜Ÿ',
                    earth: 'åœ°çƒ',
                    mars: 'ç«æ˜Ÿ',
                    jupiter: 'æœ¨æ˜Ÿ',
                    saturn: 'åœŸæ˜Ÿ',
                    uranus: 'å¤©ç‹æ˜Ÿ',
                    neptune: 'æµ·ç‹æ˜Ÿ'
                };
                
                let tooltip = document.getElementById('planet-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'planet-tooltip';
                    tooltip.style.cssText = `
                        position: absolute;
                        background: rgba(0,0,0,0.8);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 6px;
                        font-size: 14px;
                        pointer-events: none;
                        z-index: 1000;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    `;
                    document.body.appendChild(tooltip);
                }
                
                tooltip.innerHTML = `<strong>${planetNames[planetName] || planetName}</strong><br>ç‚¹å‡»èšç„¦è§‚å¯Ÿ`;
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY + 10) + 'px';
                tooltip.style.display = 'block';
            }

            hidePlanetTooltip() {
                const tooltip = document.getElementById('planet-tooltip');
                if (tooltip) {
                    tooltip.style.display = 'none';
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.isPlaying) {
                    // Update planet positions
                    Object.entries(this.planets).forEach(([name, planet]) => {
                        if (name === 'sun') {
                            // Rotate sun
                            planet.mesh.rotation.y += 0.01 * this.speed;
                            
                            // Animate solar flares
                            if (this.solarFlares) {
                                this.solarFlares.rotation.y += 0.02 * this.speed;
                                this.solarFlares.rotation.z += 0.01 * this.speed;
                            }
                            return;
                        }
                        
                        // Orbital motion
                        const data = planet.data;
                        const speed = (365 / data.period) * 0.01 * this.speed;
                        planet.angle += speed;
                        
                        const x = Math.cos(planet.angle) * data.distance;
                        const z = Math.sin(planet.angle) * data.distance;
                        
                        planet.mesh.position.set(x, 0, z);
                        
                        // Planet rotation
                        planet.mesh.rotation.y += 0.02 * this.speed;
                        
                        // Update focused planet camera if needed
                        if (this.focusedPlanet === name) {
                            const position = planet.mesh.position.clone();
                            const distance = planet.data.size * 8;
                            this.controls.target.copy(position);
                        }
                    });
                    
                    // Update asteroids
                    if (this.asteroids) {
                        this.asteroids.forEach(asteroid => {
                            asteroid.angle += asteroid.speed * this.speed;
                            const x = Math.cos(asteroid.angle) * asteroid.distance;
                            const z = Math.sin(asteroid.angle) * asteroid.distance;
                            asteroid.mesh.position.x = x;
                            asteroid.mesh.position.z = z;
                        });
                    }
                    
                    // Update comets
                    if (this.comets) {
                        this.comets.forEach(comet => {
                            comet.angle += comet.speed * this.speed;
                            
                            // Elliptical orbit calculation
                            const a = comet.semiMajorAxis;
                            const e = comet.eccentricity;
                            const r = a * (1 - e * e) / (1 + e * Math.cos(comet.angle));
                            
                            const x = r * Math.cos(comet.angle);
                            const z = r * Math.sin(comet.angle);
                            
                            comet.mesh.position.set(x, 0, z);
                            
                            // Point tail away from sun
                            comet.mesh.lookAt(0, 0, 0);
                        });
                    }
                }
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            showFallbackMessage() {
                const container = document.getElementById('solar-system-container');
                container.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; text-align: center;">
                        <div>
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                            <div>3Då¤ªé˜³ç³»åŠ è½½å¤±è´¥</div>
                            <div style="font-size: 0.8rem; margin-top: 0.5rem;">è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æµè§ˆå™¨å…¼å®¹æ€§</div>
                        </div>
                    </div>
                `;
            }
        }

        // 3D Seasons Demonstration - Enhanced and Educational
        class Seasons3D {
            constructor(containerId) {
                this.containerId = containerId;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.earth = null;
                this.sun = null;
                this.sunRays = [];
                this.orbitAngle = 0;
                this.isPlaying = true;
                this.speed = 1;
                this.seasons = ['æ˜¥åˆ†', 'å¤è‡³', 'ç§‹åˆ†', 'å†¬è‡³'];
                this.currentSeasonIndex = 0;
                this.init();
            }

            async init() {
                try {
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLights();
                    this.setupControls();
                    await this.createObjects();
                    this.setupEventListeners();
                    this.animate();
                    
                    // Hide loading indicator
                    const loadingElement = document.getElementById('seasons-loading');
                    if (loadingElement) {
                        loadingElement.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Failed to initialize Seasons3D:', error);
                    this.showError();
                }
            }

            showError() {
                const container = document.getElementById(this.containerId);
                const loadingElement = document.getElementById('seasons-loading');
                if (loadingElement) {
                    loadingElement.innerHTML = '<div style="color: #ff6b6b;">3Dæ¼”ç¤ºåŠ è½½å¤±è´¥</div>';
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000022);
                
                // Add stars
                this.createStarField();
            }

            createStarField() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.0 });
                
                const starsVertices = [];
                for (let i = 0; i < 2000; i++) {
                    const x = (Math.random() - 0.5) * 400;
                    const y = (Math.random() - 0.5) * 400;
                    const z = (Math.random() - 0.5) * 400;
                    starsVertices.push(x, y, z);
                }
                
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(stars);
            }

            setupCamera() {
                const container = document.getElementById(this.containerId);
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.set(0, 25, 35);
                this.camera.lookAt(0, 0, 0);
            }

            setupRenderer() {
                const container = document.getElementById(this.containerId);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                container.appendChild(this.renderer.domElement);
            }

            setupLights() {
                // Ambient light for general illumination
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(ambientLight);
                
                // Sun light (directional light from sun position)
                this.sunLight = new THREE.DirectionalLight(0xFFFFFF, 3);
                this.sunLight.position.set(0, 0, 0);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.sunLight.shadow.camera.near = 0.5;
                this.sunLight.shadow.camera.far = 100;
                this.sunLight.shadow.camera.left = -50;
                this.sunLight.shadow.camera.right = 50;
                this.sunLight.shadow.camera.top = 50;
                this.sunLight.shadow.camera.bottom = -50;
                this.scene.add(this.sunLight);
            }

            setupControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = 20;
                this.controls.maxDistance = 80;
                this.controls.target.set(0, 0, 0);
                this.controls.autoRotate = false;
            }

            async createObjects() {
                // Create realistic Sun at center
                this.sun = await this.createRealisticSun(3, [0, 0, 0]);
                this.scene.add(this.sun);

                // Create realistic Earth with proper tilt
                this.earth = await this.createRealisticEarth(1.5, [15, 0, 0]);
                this.earth.castShadow = true;
                this.earth.receiveShadow = true;
                this.scene.add(this.earth);

                // Create Earth's orbital path
                this.createOrbitPath();

                // Create season markers with labels
                this.createSeasonMarkers();

                // Create illumination indicators
                this.createIlluminationIndicators();
            }

            createOrbitPath() {
                const orbitPoints = [];
                for (let i = 0; i <= 128; i++) {
                    const angle = (i / 128) * Math.PI * 2;
                    orbitPoints.push(new THREE.Vector3(
                        Math.cos(angle) * 15,
                        0,
                        Math.sin(angle) * 15
                    ));
                }
                
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                const orbitMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.6
                });
                const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
                this.scene.add(orbit);
            }

            createSeasonMarkers() {
                const seasonData = [
                    { pos: [15, 0, 0], text: 'æ˜¥åˆ†\næ˜¼å¤œç­‰é•¿', color: 0x90EE90, angle: 0 },
                    { pos: [0, 0, 15], text: 'å¤è‡³\nåŒ—åŠçƒå¤å­£', color: 0xFFD700, angle: Math.PI/2 },
                    { pos: [-15, 0, 0], text: 'ç§‹åˆ†\næ˜¼å¤œç­‰é•¿', color: 0xFFA500, angle: Math.PI },
                    { pos: [0, 0, -15], text: 'å†¬è‡³\nåŒ—åŠçƒå†¬å­£', color: 0x87CEEB, angle: 3*Math.PI/2 }
                ];

                seasonData.forEach((season, index) => {
                    // Create marker sphere
                    const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: season.color,
                        emissive: season.color,
                        emissiveIntensity: 0.4
                    });
                    const marker = new THREE.Mesh(geometry, material);
                    marker.position.set(...season.pos);
                    this.scene.add(marker);

                    // Add glow effect
                    const glowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: season.color,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    marker.add(glow);

                    // Add text label using CSS2DRenderer would be better, but using simple geometry
                    this.createTextLabel(season.text, season.pos, season.color);
                });
            }

            createTextLabel(text, position, color) {
                // Create a simple plane for text (placeholder - in real implementation would use CSS2DRenderer)
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 128;
                
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(text.split('\n')[0], 128, 50);
                context.fillText(text.split('\n')[1] || '', 128, 80);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true,
                    alphaTest: 0.1
                });
                const geometry = new THREE.PlaneGeometry(4, 2);
                const textMesh = new THREE.Mesh(geometry, material);
                textMesh.position.set(position[0], position[1] + 3, position[2]);
                textMesh.lookAt(this.camera.position);
                this.scene.add(textMesh);
            }

            createIlluminationIndicators() {
                // Create sun rays to show illumination direction
                this.sunRays = [];
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const rayGeometry = new THREE.CylinderGeometry(0.05, 0.05, 30, 8);
                    const rayMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFFF88,
                        transparent: true,
                        opacity: 0.7
                    });
                    const ray = new THREE.Mesh(rayGeometry, rayMaterial);
                    
                    ray.position.set(
                        Math.cos(angle) * 15,
                        0,
                        Math.sin(angle) * 15
                    );
                    ray.lookAt(0, 0, 0);
                    ray.rotateX(Math.PI / 2);
                    
                    this.sunRays.push(ray);
                    this.scene.add(ray);
                }
            }

            setupEventListeners() {
                // Play/Pause button
                document.getElementById('seasons-play-pause').addEventListener('click', () => {
                    this.isPlaying = !this.isPlaying;
                    const button = document.getElementById('seasons-play-pause');
                    button.textContent = this.isPlaying ? 'â¸ï¸' : 'â–¶ï¸';
                });

                // Reset button
                document.getElementById('seasons-reset').addEventListener('click', () => {
                    this.orbitAngle = 0;
                    this.currentSeasonIndex = 0;
                    this.updateSeasonInfo();
                });

                // Speed control
                document.getElementById('seasons-speed').addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('seasons-speed-value').textContent = this.speed + 'x';
                });
            }

            updateSeasonInfo() {
                // Determine current season based on orbit angle
                const normalizedAngle = ((this.orbitAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                this.currentSeasonIndex = Math.floor((normalizedAngle / (Math.PI * 2)) * 4);
                
                const seasonNames = ['æ˜¥åˆ†', 'å¤è‡³', 'ç§‹åˆ†', 'å†¬è‡³'];
                const sunPositions = ['èµ¤é“', 'åŒ—å›å½’çº¿', 'èµ¤é“', 'å—å›å½’çº¿'];
                
                const currentSeasonElement = document.getElementById('current-season');
                const sunPositionElement = document.getElementById('sun-position');
                
                if (currentSeasonElement) {
                    currentSeasonElement.textContent = seasonNames[this.currentSeasonIndex] || 'æ˜¥åˆ†';
                }
                if (sunPositionElement) {
                    sunPositionElement.textContent = sunPositions[this.currentSeasonIndex] || 'èµ¤é“';
                }
            }

            // Add missing methods for realistic object creation
            async loadPlanetTexture(planetName) {
                const textureUrls = {
                    sun: [
                        'https://threejs.org/examples/textures/planets/sun.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_sun.jpg'
                    ],
                    earth: [
                        'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_earth_daymap.jpg'
                    ],
                    earth_clouds: [
                        'https://threejs.org/examples/textures/planets/earth_clouds_1024.png',
                        'https://www.solarsystemscope.com/textures/download/2k_earth_clouds.jpg'
                    ],
                    moon: [
                        'https://threejs.org/examples/textures/planets/moon_1024.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_moon.jpg'
                    ]
                };
                
                const urls = textureUrls[planetName] || textureUrls.earth;
                
                return new Promise((resolve) => {
                    const loader = new THREE.TextureLoader();
                    
                    const tryLoadTexture = (urlIndex = 0) => {
                        if (urlIndex >= urls.length) {
                            resolve(null);
                            return;
                        }
                        
                        loader.load(
                            urls[urlIndex],
                            (texture) => {
                                resolve(texture);
                            },
                            undefined,
                            () => {
                                tryLoadTexture(urlIndex + 1);
                            }
                        );
                    };
                    
                    tryLoadTexture();
                });
            }

            async createRealisticEarth(size = 1.5, position = [15, 0, 0]) {
                const earthGroup = new THREE.Group();
                
                // Load textures
                const dayTexture = await this.loadPlanetTexture('earth');
                const cloudsTexture = await this.loadPlanetTexture('earth_clouds');
                
                // Earth sphere with day texture
                const earthGeometry = new THREE.SphereGeometry(size, 64, 64);
                const earthMaterial = new THREE.MeshPhongMaterial({
                    map: dayTexture,
                    bumpMap: dayTexture,
                    bumpScale: 0.05,
                    specularMap: dayTexture,
                    specular: new THREE.Color('grey'),
                    shininess: 100
                });
                
                const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earth.castShadow = true;
                earth.receiveShadow = true;
                earthGroup.add(earth);
                
                // Apply 23.5 degree axial tilt - this is crucial for seasons!
                earthGroup.rotation.z = Math.PI * 23.5 / 180;
                
                // Cloud layer
                if (cloudsTexture) {
                    const cloudGeometry = new THREE.SphereGeometry(size * 1.02, 64, 64);
                    const cloudMaterial = new THREE.MeshPhongMaterial({
                        map: cloudsTexture,
                        transparent: true,
                        opacity: 0.4
                    });
                    const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    earthGroup.add(clouds);
                    earthGroup.clouds = clouds;
                }
                
                // Atmosphere glow
                const atmosphereGeometry = new THREE.SphereGeometry(size * 1.1, 32, 32);
                const atmosphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                earthGroup.add(atmosphere);
                
                earthGroup.position.set(...position);
                return earthGroup;
            }

            async createRealisticSun(size = 3, position = [0, 0, 0]) {
                const sunGroup = new THREE.Group();
                
                // Load sun texture
                const sunTexture = await this.loadPlanetTexture('sun');
                
                // Sun sphere with realistic surface
                const sunGeometry = new THREE.SphereGeometry(size, 64, 64);
                const sunMaterial = new THREE.MeshPhongMaterial({
                    map: sunTexture,
                    emissive: 0xFFAA00,
                    emissiveIntensity: 1.2,
                    emissiveMap: sunTexture
                });
                
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                sunGroup.add(sun);
                
                // Corona layers for realistic glow
                const coronaLayers = [
                    { size: size * 1.2, color: 0xFFD700, opacity: 0.5 },
                    { size: size * 1.5, color: 0xFF6600, opacity: 0.3 },
                    { size: size * 1.8, color: 0xFFDD44, opacity: 0.1 }
                ];
                
                coronaLayers.forEach(layer => {
                    const coronaGeometry = new THREE.SphereGeometry(layer.size, 32, 32);
                    const coronaMaterial = new THREE.MeshBasicMaterial({
                        color: layer.color,
                        transparent: true,
                        opacity: layer.opacity,
                        side: THREE.BackSide
                    });
                    const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                    sunGroup.add(corona);
                });
                
                // Enhanced solar flares
                this.createEnhancedSolarFlares(sunGroup, size);
                
                sunGroup.position.set(...position);
                return sunGroup;
            }

            async createRealisticMoon(size = 0.6, position = [0, 0, 0]) {
                const moonGroup = new THREE.Group();
                
                // Load moon texture
                const moonTexture = await this.loadPlanetTexture('moon');
                
                // Moon sphere with realistic surface
                const moonGeometry = new THREE.SphereGeometry(size, 32, 32);
                const moonMaterial = new THREE.MeshPhongMaterial({
                    map: moonTexture,
                    bumpMap: moonTexture,
                    bumpScale: 0.1,
                    shininess: 1
                });
                
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.castShadow = true;
                moon.receiveShadow = true;
                moonGroup.add(moon);
                
                moonGroup.position.set(...position);
                return moonGroup;
            }

            createEnhancedSolarFlares(sunGroup, sunSize) {
                // Create more realistic solar flare particles
                const flareCount = 300;
                const flareGeometry = new THREE.BufferGeometry();
                const flarePositions = [];
                const flareSizes = [];
                const flareColors = [];
                
                for (let i = 0; i < flareCount; i++) {
                    // Random positions around the sun surface
                    const radius = sunSize + Math.random() * (sunSize * 0.8);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    flarePositions.push(x, y, z);
                    flareSizes.push(Math.random() * 0.3 + 0.1);
                    
                    // Vary colors from yellow to orange to red
                    const colorVariation = Math.random();
                    if (colorVariation < 0.4) {
                        flareColors.push(1, 1, 0); // Yellow
                    } else if (colorVariation < 0.7) {
                        flareColors.push(1, 0.5, 0); // Orange
                    } else {
                        flareColors.push(1, 0.2, 0); // Red-orange
                    }
                }
                
                flareGeometry.setAttribute('position', new THREE.Float32BufferAttribute(flarePositions, 3));
                flareGeometry.setAttribute('size', new THREE.Float32BufferAttribute(flareSizes, 1));
                flareGeometry.setAttribute('color', new THREE.Float32BufferAttribute(flareColors, 3));
                
                const flareMaterial = new THREE.PointsMaterial({
                    size: 0.2,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true
                });
                
                const flares = new THREE.Points(flareGeometry, flareMaterial);
                sunGroup.add(flares);
                
                // Store reference for animation
                sunGroup.solarFlares = flares;
                return flares;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.isPlaying && this.earth) { 
                    // Orbit Earth around Sun
                    this.orbitAngle += 0.008 * this.speed;
                    this.earth.position.x = Math.cos(this.orbitAngle) * 15;
                    this.earth.position.z = Math.sin(this.orbitAngle) * 15;
                    
                    // Rotate Earth on its axis (maintaining the tilt)
                    this.earth.rotation.y += 0.02 * this.speed;
                    
                    // Animate clouds if they exist
                    if (this.earth.clouds) {
                        this.earth.clouds.rotation.y += 0.005 * this.speed;
                    }
                    
                    // Update season information
                    this.updateSeasonInfo();
                    
                    // Animate sun rays
                    if (this.sunRays) {
                        this.sunRays.forEach((ray, index) => {
                            ray.rotation.z += 0.003 * this.speed;
                        });
                    }
                    
                    // Animate sun solar flares
                    if (this.sun && this.sun.solarFlares) {
                        this.sun.solarFlares.rotation.y += 0.01 * this.speed;
                        this.sun.solarFlares.rotation.z += 0.005 * this.speed;
                    }
                }
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // 3D Day/Night Demonstration - Enhanced and Educational
        class DayNight3D {
            constructor(containerId) {
                this.containerId = containerId;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.earth = null;
                this.sun = null;
                this.terminator = null;
                this.cityLights = [];
                this.isPlaying = true;
                this.speed = 2;
                this.rotationAngle = 0;
                this.init();
            }

            async init() {
                try {
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLights();
                    this.setupControls();
                    await this.createObjects();
                    this.setupEventListeners();
                    this.animate();
                    
                    // Hide loading indicator
                    const loadingElement = document.getElementById('day-night-loading');
                    if (loadingElement) {
                        loadingElement.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Failed to initialize DayNight3D:', error);
                    this.showError();
                }
            }

            showError() {
                const loadingElement = document.getElementById('day-night-loading');
                if (loadingElement) {
                    loadingElement.innerHTML = '<div style="color: #ff6b6b;">3Dæ¼”ç¤ºåŠ è½½å¤±è´¥</div>';
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000033);
                
                // Add stars
                this.createStarField();
            }

            createStarField() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8 });
                
                const starsVertices = [];
                for (let i = 0; i < 1500; i++) {
                    const x = (Math.random() - 0.5) * 200;
                    const y = (Math.random() - 0.5) * 200;
                    const z = (Math.random() - 0.5) * 200;
                    starsVertices.push(x, y, z);
                }
                
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(stars);
            }

            setupCamera() {
                const container = document.getElementById(this.containerId);
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.set(8, 5, 12);
                this.camera.lookAt(0, 0, 0);
            }

            setupRenderer() {
                const container = document.getElementById(this.containerId);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                container.appendChild(this.renderer.domElement);
            }

            setupLights() {
                // Very dim ambient light to show night side
                const ambientLight = new THREE.AmbientLight(0x202040, 0.2);
                this.scene.add(ambientLight);
                
                // Strong directional light from sun
                this.sunLight = new THREE.DirectionalLight(0xFFFFFF, 3);
                this.sunLight.position.set(-15, 5, 0);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.sunLight.shadow.camera.near = 0.5;
                this.sunLight.shadow.camera.far = 50;
                this.sunLight.shadow.camera.left = -15;
                this.sunLight.shadow.camera.right = 15;
                this.sunLight.shadow.camera.top = 15;
                this.sunLight.shadow.camera.bottom = -15;
                this.scene.add(this.sunLight);
            }

            setupControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = 5;
                this.controls.maxDistance = 25;
                this.controls.target.set(0, 0, 0);
            }

            async createObjects() {
                // Create realistic Sun (light source) with enhanced glow
                this.sun = await this.createRealisticSun(1.2, [-15, 0, 0]);
                this.scene.add(this.sun);

                // Create realistic Earth with day/night textures
                this.earth = await this.createRealisticEarth(2.5, [0, 0, 0]);
                this.earth.castShadow = true;
                this.earth.receiveShadow = true;
                this.scene.add(this.earth);

                // Create visible terminator line (day/night boundary)
                this.createTerminator();

                // Add city lights on night side
                this.addCityLights();

                // Add illumination indicators
                this.createIlluminationIndicators();
            }

            createTerminator() {
                // Create a visible terminator line as a ring around Earth
                const terminatorGeometry = new THREE.RingGeometry(2.52, 2.55, 128);
                const terminatorMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFDD88,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                this.terminator = new THREE.Mesh(terminatorGeometry, terminatorMaterial);
                this.terminator.rotation.x = Math.PI / 2;
                this.scene.add(this.terminator);
            }

            addCityLights() {
                // Add realistic city lights that appear on night side
                const cityPositions = [
                    { name: 'çº½çº¦', lat: 40.7, lon: -74 },
                    { name: 'ä¼¦æ•¦', lat: 51.5, lon: 0 },
                    { name: 'ä¸œäº¬', lat: 35.7, lon: 139.7 },
                    { name: 'æ‚‰å°¼', lat: -33.9, lon: 151.2 },
                    { name: 'è«æ–¯ç§‘', lat: 55.8, lon: 37.6 },
                    { name: 'åŒ—äº¬', lat: 39.9, lon: 116.4 },
                    { name: 'å¼€ç½—', lat: 30.0, lon: 31.2 },
                    { name: 'é‡Œçº¦', lat: -22.9, lon: -43.2 }
                ];

                this.cityLights = [];
                cityPositions.forEach(city => {
                    const phi = (90 - city.lat) * (Math.PI / 180);
                    const theta = (city.lon + 180) * (Math.PI / 180);
                    
                    const x = -(2.6 * Math.sin(phi) * Math.cos(theta));
                    const z = (2.6 * Math.sin(phi) * Math.sin(theta));
                    const y = (2.6 * Math.cos(phi));
                    
                    // Create glowing city light
                    const lightGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFFF88,
                        emissive: 0xFFFF88,
                        emissiveIntensity: 1.0
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(x, y, z);
                    
                    // Add glow effect
                    const glowGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFFF88,
                        transparent: true,
                        opacity: 0.6
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    light.add(glow);
                    
                    light.userData = { city: city.name, originalPosition: { x, y, z } };
                    this.cityLights.push(light);
                    this.scene.add(light);
                });
            }

            createIlluminationIndicators() {
                // Create arrows showing sun rays direction
                const arrowCount = 8;
                this.sunRays = [];
                
                for (let i = 0; i < arrowCount; i++) {
                    const angle = (i / arrowCount) * Math.PI * 2;
                    
                    // Create arrow geometry
                    const arrowGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
                    const arrowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFDD00,
                        transparent: true,
                        opacity: 0.8
                    });
                    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                    
                    // Position arrows around the illuminated hemisphere
                    const radius = 4;
                    arrow.position.set(
                        -radius + Math.cos(angle) * 0.5,
                        Math.sin(angle) * 2,
                        Math.cos(angle + Math.PI/2) * 2
                    );
                    arrow.lookAt(0, 0, 0);
                    
                    this.sunRays.push(arrow);
                    this.scene.add(arrow);
                }
            }

            setupEventListeners() {
                // Play/Pause button
                document.getElementById('daynight-play-pause').addEventListener('click', () => {
                    this.isPlaying = !this.isPlaying;
                    const button = document.getElementById('daynight-play-pause');
                    button.textContent = this.isPlaying ? 'â¸ï¸' : 'â–¶ï¸';
                });

                // Reset button
                document.getElementById('daynight-reset').addEventListener('click', () => {
                    this.rotationAngle = 0;
                    if (this.earth) {
                        this.earth.rotation.y = 0;
                    }
                    this.updateTimeInfo();
                });

                // Speed control
                document.getElementById('daynight-speed').addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('daynight-speed-value').textContent = this.speed + 'x';
                });
            }

            updateTimeInfo() {
                // Calculate current time based on rotation (24 hours = 2Ï€ radians)
                const hours = ((this.rotationAngle % (Math.PI * 2)) / (Math.PI * 2)) * 24;
                const displayHours = Math.floor(hours);
                const displayMinutes = Math.floor((hours - displayHours) * 60);
                
                const timeString = `${displayHours.toString().padStart(2, '0')}:${displayMinutes.toString().padStart(2, '0')}`;
                
                const currentTimeElement = document.getElementById('current-time');
                const terminatorElement = document.getElementById('terminator-position');
                
                if (currentTimeElement) {
                    currentTimeElement.textContent = timeString;
                }
                
                if (terminatorElement) {
                    const isDay = (hours >= 6 && hours <= 18);
                    terminatorElement.textContent = isDay ? 'æ˜¼ä¾§ä¸»å¯¼' : 'å¤œä¾§ä¸»å¯¼';
                }
            }

            // Add missing methods for realistic object creation
            async loadPlanetTexture(planetName) {
                const textureUrls = {
                    sun: [
                        'https://threejs.org/examples/textures/planets/sun.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_sun.jpg'
                    ],
                    earth: [
                        'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_earth_daymap.jpg'
                    ],
                    earth_night: [
                        'https://threejs.org/examples/textures/planets/earth_lights_2048.png',
                        'https://www.solarsystemscope.com/textures/download/2k_earth_nightmap.jpg'
                    ],
                    earth_clouds: [
                        'https://threejs.org/examples/textures/planets/earth_clouds_1024.png',
                        'https://www.solarsystemscope.com/textures/download/2k_earth_clouds.jpg'
                    ],
                    moon: [
                        'https://threejs.org/examples/textures/planets/moon_1024.jpg',
                        'https://www.solarsystemscope.com/textures/download/2k_moon.jpg'
                    ]
                };
                
                const urls = textureUrls[planetName] || textureUrls.earth;
                
                return new Promise((resolve) => {
                    const loader = new THREE.TextureLoader();
                    
                    const tryLoadTexture = (urlIndex = 0) => {
                        if (urlIndex >= urls.length) {
                            resolve(null);
                            return;
                        }
                        
                        loader.load(
                            urls[urlIndex],
                            (texture) => {
                                resolve(texture);
                            },
                            undefined,
                            () => {
                                tryLoadTexture(urlIndex + 1);
                            }
                        );
                    };
                    
                    tryLoadTexture();
                });
            }

            async createRealisticEarth(size = 2.5, position = [0, 0, 0]) {
                const earthGroup = new THREE.Group();
                
                // Load textures
                const dayTexture = await this.loadPlanetTexture('earth');
                const nightTexture = await this.loadPlanetTexture('earth_night');
                const cloudsTexture = await this.loadPlanetTexture('earth_clouds');
                
                // Earth sphere with day texture
                const earthGeometry = new THREE.SphereGeometry(size, 128, 128);
                const earthMaterial = new THREE.MeshPhongMaterial({
                    map: dayTexture,
                    bumpMap: dayTexture,
                    bumpScale: 0.02,
                    specularMap: dayTexture,
                    specular: new THREE.Color('grey'),
                    shininess: 100
                });
                
                const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earth.castShadow = true;
                earth.receiveShadow = true;
                earthGroup.add(earth);
                
                // Night lights layer (visible on dark side)
                if (nightTexture) {
                    const nightGeometry = new THREE.SphereGeometry(size * 1.001, 128, 128);
                    const nightMaterial = new THREE.MeshBasicMaterial({
                        map: nightTexture,
                        transparent: true,
                        opacity: 1.0,
                        blending: THREE.AdditiveBlending
                    });
                    const nightLights = new THREE.Mesh(nightGeometry, nightMaterial);
                    earthGroup.add(nightLights);
                    earthGroup.nightLights = nightLights;
                }
                
                // Cloud layer with animation
                if (cloudsTexture) {
                    const cloudGeometry = new THREE.SphereGeometry(size * 1.02, 64, 64);
                    const cloudMaterial = new THREE.MeshPhongMaterial({
                        map: cloudsTexture,
                        transparent: true,
                        opacity: 0.4,
                        alphaMap: cloudsTexture
                    });
                    const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    earthGroup.add(clouds);
                    earthGroup.clouds = clouds;
                }
                
                // Atmosphere glow (stronger on day side)
                const atmosphereGeometry = new THREE.SphereGeometry(size * 1.1, 32, 32);
                const atmosphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                earthGroup.add(atmosphere);
                
                earthGroup.position.set(...position);
                return earthGroup;
            }

            async createRealisticSun(size = 1.2, position = [-15, 0, 0]) {
                const sunGroup = new THREE.Group();
                
                // Load sun texture
                const sunTexture = await this.loadPlanetTexture('sun');
                
                // Sun sphere with realistic surface
                const sunGeometry = new THREE.SphereGeometry(size, 64, 64);
                const sunMaterial = new THREE.MeshPhongMaterial({
                    map: sunTexture,
                    emissive: 0xFFAA00,
                    emissiveIntensity: 1.5,
                    emissiveMap: sunTexture
                });
                
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                sunGroup.add(sun);
                
                // Enhanced corona for distance viewing
                const coronaLayers = [
                    { size: size * 1.3, color: 0xFFD700, opacity: 0.6 },
                    { size: size * 1.6, color: 0xFF6600, opacity: 0.4 },
                    { size: size * 2.0, color: 0xFFDD44, opacity: 0.2 }
                ];
                
                coronaLayers.forEach(layer => {
                    const coronaGeometry = new THREE.SphereGeometry(layer.size, 32, 32);
                    const coronaMaterial = new THREE.MeshBasicMaterial({
                        color: layer.color,
                        transparent: true,
                        opacity: layer.opacity,
                        side: THREE.BackSide
                    });
                    const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                    sunGroup.add(corona);
                });
                
                // Enhanced solar flares
                this.createEnhancedSolarFlares(sunGroup, size);
                
                sunGroup.position.set(...position);
                return sunGroup;
            }

            async createRealisticMoon(size = 0.6, position = [0, 0, 0]) {
                const moonGroup = new THREE.Group();
                
                // Load moon texture
                const moonTexture = await this.loadPlanetTexture('moon');
                
                // Moon sphere with realistic surface
                const moonGeometry = new THREE.SphereGeometry(size, 32, 32);
                const moonMaterial = new THREE.MeshPhongMaterial({
                    map: moonTexture,
                    bumpMap: moonTexture,
                    bumpScale: 0.1,
                    shininess: 1
                });
                
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.castShadow = true;
                moon.receiveShadow = true;
                moonGroup.add(moon);
                
                moonGroup.position.set(...position);
                return moonGroup;
            }

            createEnhancedSolarFlares(sunGroup, sunSize) {
                // Create solar flare particles for the sun
                const flareCount = 200;
                const flareGeometry = new THREE.BufferGeometry();
                const flarePositions = [];
                const flareSizes = [];
                const flareColors = [];
                
                for (let i = 0; i < flareCount; i++) {
                    // Random positions around the sun surface
                    const radius = sunSize + Math.random() * (sunSize * 0.6);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    flarePositions.push(x, y, z);
                    flareSizes.push(Math.random() * 0.2 + 0.1);
                    
                    // Solar flare colors
                    const colorVariation = Math.random();
                    if (colorVariation < 0.5) {
                        flareColors.push(1, 1, 0); // Yellow
                    } else {
                        flareColors.push(1, 0.4, 0); // Orange
                    }
                }
                
                flareGeometry.setAttribute('position', new THREE.Float32BufferAttribute(flarePositions, 3));
                flareGeometry.setAttribute('size', new THREE.Float32BufferAttribute(flareSizes, 1));
                flareGeometry.setAttribute('color', new THREE.Float32BufferAttribute(flareColors, 3));
                
                const flareMaterial = new THREE.PointsMaterial({
                    size: 0.15,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true
                });
                
                const flares = new THREE.Points(flareGeometry, flareMaterial);
                sunGroup.add(flares);
                
                // Store reference for animation
                sunGroup.solarFlares = flares;
                return flares;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.isPlaying && this.earth) { 
                    // Rotate Earth to show day/night cycle
                    this.rotationAngle += 0.015 * this.speed;
                    this.earth.rotation.y = this.rotationAngle;
                    
                    // Animate clouds independently for realism
                    if (this.earth.clouds) {
                        this.earth.clouds.rotation.y = this.rotationAngle * 0.95; // Slightly different speed
                    }
                    
                    // Update terminator position to follow Earth's rotation
                    if (this.terminator) {
                        this.terminator.rotation.z = this.rotationAngle;
                    }
                    
                    // Update city lights visibility based on day/night
                    this.updateCityLights();
                    
                    // Animate sun solar flares
                    if (this.sun && this.sun.solarFlares) {
                        this.sun.solarFlares.rotation.y += 0.02 * this.speed;
                        this.sun.solarFlares.rotation.z += 0.01 * this.speed;
                    }
                    
                    // Update time information
                    this.updateTimeInfo();
                }
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            updateCityLights() {
                if (!this.cityLights) return;
                
                this.cityLights.forEach(light => {
                    // Rotate city light with Earth
                    const originalPos = light.userData.originalPosition;
                    const rotatedX = originalPos.x * Math.cos(this.rotationAngle) - originalPos.z * Math.sin(this.rotationAngle);
                    const rotatedZ = originalPos.x * Math.sin(this.rotationAngle) + originalPos.z * Math.cos(this.rotationAngle);
                    
                    light.position.set(rotatedX, originalPos.y, rotatedZ);
                    
                    // Calculate if this position is on night side (facing away from sun)
                    const sunDirection = new THREE.Vector3(-1, 0, 0); // Sun is at [-15, 0, 0]
                    const lightDirection = light.position.clone().normalize();
                    const dotProduct = lightDirection.dot(sunDirection);
                    
                    // Show lights on night side (dot product < 0 means facing away from sun)
                    const isNightSide = dotProduct < -0.1;
                    light.visible = isNightSide;
                    
                    // Adjust opacity based on how deep into night side
                    if (isNightSide) {
                        const opacity = Math.min(1.0, Math.abs(dotProduct) * 2);
                        light.material.opacity = opacity;
                        light.children[0].material.opacity = opacity * 0.6; // Glow effect
                    }
                });
            }
        }

        // 3D Tidal Demonstration - Enhanced and Educational
        class Tidal3D {
            constructor(containerId) {
                this.containerId = containerId;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.earth = null;
                this.moon = null;
                this.sun = null;
                this.water = null;
                this.tidalIndicators = [];
                this.moonAngle = 0;
                this.isPlaying = true;
                this.speed = 1.5;
                this.init();
            }

            async init() {
                try {
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLights();
                    this.setupControls();
                    await this.createObjects();
                    this.setupEventListeners();
                    this.animate();
                    
                    // Hide loading indicator
                    const loadingElement = document.getElementById('tidal-loading');
                    if (loadingElement) {
                        loadingElement.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Failed to initialize Tidal3D:', error);
                    this.showError();
                }
            }

            showError() {
                const loadingElement = document.getElementById('tidal-loading');
                if (loadingElement) {
                    loadingElement.innerHTML = '<div style="color: #ff6b6b;">3Dæ¼”ç¤ºåŠ è½½å¤±è´¥</div>';
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x001122);
                
                // Add stars
                this.createStarField();
            }

            createStarField() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8 });
                
                const starsVertices = [];
                for (let i = 0; i < 1000; i++) {
                    const x = (Math.random() - 0.5) * 300;
                    const y = (Math.random() - 0.5) * 300;
                    const z = (Math.random() - 0.5) * 300;
                    starsVertices.push(x, y, z);
                }
                
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(stars);
            }

            setupCamera() {
                const container = document.getElementById(this.containerId);
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.set(0, 12, 18);
                this.camera.lookAt(0, 0, 0);
            }

            setupRenderer() {
                const container = document.getElementById(this.containerId);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                container.appendChild(this.renderer.domElement);
            }

            setupLights() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Sun light (distant but visible)
                const sunLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
                sunLight.position.set(25, 15, 15);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 1024;
                sunLight.shadow.mapSize.height = 1024;
                this.scene.add(sunLight);

                // Moon light (subtle blue tint)
                this.moonLight = new THREE.PointLight(0xC0C0FF, 0.8, 30);
                this.scene.add(this.moonLight);
            }

            setupControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = 5;
                this.controls.maxDistance = 25;
                this.controls.target.set(0, 0, 0);
            }

            async createObjects() {
                // Create realistic Earth with continents
                this.earth = await this.createRealisticEarth(2, [0, 0, 0]);
                this.earth.castShadow = true;
                this.earth.receiveShadow = true;
                this.scene.add(this.earth);

                // Add enhanced ocean layer with realistic tidal effects
                this.createOceanLayer();

                // Create realistic Moon with surface details
                this.moon = await this.createRealisticMoon(0.6, [8, 0, 0]);
                this.moon.castShadow = true;
                this.scene.add(this.moon);

                // Create distant realistic Sun
                this.sun = await this.createRealisticSun(0.3, [25, 5, 5]);
                this.scene.add(this.sun);

                // Create Moon's orbit path
                this.createOrbitPath();

                // Create tidal force indicators
                this.createTidalIndicators();
            }

            createOceanLayer() {
                // Create ocean with dynamic tidal bulges
                const oceanGeometry = new THREE.SphereGeometry(2.15, 128, 128);
                const oceanMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x006994,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 100,
                    specular: 0x111111
                });
                this.water = new THREE.Mesh(oceanGeometry, oceanMaterial);
                this.water.receiveShadow = true;
                this.scene.add(this.water);

                // Store original positions for tidal calculations
                this.originalPositions = oceanGeometry.attributes.position.array.slice();
            }

            createOrbitPath() {
                const orbitPoints = [];
                for (let i = 0; i <= 128; i++) {
                    const angle = (i / 128) * Math.PI * 2;
                    orbitPoints.push(new THREE.Vector3(
                        Math.cos(angle) * 8,
                        0,
                        Math.sin(angle) * 8
                    ));
                }
                
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                const orbitMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.4
                });
                const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
                this.scene.add(orbit);
            }

            createTidalIndicators() {
                // Create arrows to show tidal forces
                const arrowGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
                const highTideMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4444 });
                const lowTideMaterial = new THREE.MeshBasicMaterial({ color: 0x4444FF });

                // High tide indicators (facing moon and opposite)
                for (let i = 0; i < 2; i++) {
                    const arrow = new THREE.Mesh(arrowGeometry, highTideMaterial);
                    this.tidalIndicators.push({ mesh: arrow, type: 'high' });
                    this.scene.add(arrow);
                }

                // Low tide indicators (perpendicular to moon)
                for (let i = 0; i < 2; i++) {
                    const arrow = new THREE.Mesh(arrowGeometry, lowTideMaterial);
                    this.tidalIndicators.push({ mesh: arrow, type: 'low' });
                    this.scene.add(arrow);
                }
            }

            setupEventListeners() {
                // Play/Pause button
                document.getElementById('tidal-play-pause').addEventListener('click', () => {
                    this.isPlaying = !this.isPlaying;
                    const button = document.getElementById('tidal-play-pause');
                    button.textContent = this.isPlaying ? 'â¸ï¸' : 'â–¶ï¸';
                });

                // Reset button
                document.getElementById('tidal-reset').addEventListener('click', () => {
                    this.moonAngle = 0;
                    this.moon.position.set(8, 0, 0);
                    this.updateTidalInfo();
                });

                // Speed control
                document.getElementById('tidal-speed').addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('tidal-speed-value').textContent = this.speed + 'x';
                });
            }

            updateTidalInfo() {
                if (!this.moon) return; // Add null check for moon
                
                // Determine tidal state based on moon position
                const moonX = this.moon.position.x;
                const moonZ = this.moon.position.z;
                
                let tidalState = '';
                let moonPhase = '';
                let tidalRange = '';

                // Determine if it's high or low tide based on moon position
                if (Math.abs(moonX) > Math.abs(moonZ)) {
                    tidalState = moonX > 0 ? 'æ¶¨æ½®' : 'æ¶¨æ½®';
                    tidalRange = '3.2ç±³';
                } else {
                    tidalState = 'è½æ½®';
                    tidalRange = '1.8ç±³';
                }

                // Determine moon phase
                if (moonX > 6) moonPhase = 'æ–°æœˆ';
                else if (moonZ > 6) moonPhase = 'ä¸Šå¼¦æœˆ';
                else if (moonX < -6) moonPhase = 'æ»¡æœˆ';
                else moonPhase = 'ä¸‹å¼¦æœˆ';

                document.getElementById('tidal-state').textContent = tidalState;
                document.getElementById('moon-phase').textContent = moonPhase;
                document.getElementById('tidal-range').textContent = tidalRange;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.isPlaying && this.moon && this.earth) { // Add null checks for moon and earth
                    // Orbit Moon around Earth
                    this.moonAngle += 0.015 * this.speed;
                    this.moon.position.x = Math.cos(this.moonAngle) * 8;
                    this.moon.position.z = Math.sin(this.moonAngle) * 8;
                    
                    // Update moon light position
                    if (this.moonLight) {
                        this.moonLight.position.copy(this.moon.position);
                    }
                    
                    // Animate realistic tidal bulges
                    this.updateTidalBulges();
                    
                    // Update tidal force indicators
                    this.updateTidalIndicators();
                    
                    // Rotate Earth (slower than moon orbit)
                    this.earth.rotation.y += 0.008 * this.speed;
                    
                    // Update tidal information
                    this.updateTidalInfo();
                }
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            updateTidalBulges() {
                if (!this.water || !this.originalPositions) return;

                const positions = this.water.geometry.attributes.position;
                const moonPos = this.moon.position.clone().normalize();
                
                for (let i = 0; i < positions.count; i++) {
                    const index = i * 3;
                    
                    // Get original position
                    const x = this.originalPositions[index];
                    const y = this.originalPositions[index + 1];
                    const z = this.originalPositions[index + 2];
                    
                    const vertex = new THREE.Vector3(x, y, z).normalize();
                    
                    // Calculate tidal effect based on moon position
                    const moonDot = vertex.dot(moonPos);
                    
                    // Primary bulge (facing moon)
                    const primaryBulge = Math.max(0, moonDot) * 0.4;
                    
                    // Secondary bulge (opposite side - centrifugal force)
                    const secondaryBulge = Math.max(0, -moonDot) * 0.25;
                    
                    // Side compression (perpendicular to moon)
                    const sideCompression = Math.abs(moonDot) < 0.3 ? -0.15 : 0;
                    
                    const totalEffect = primaryBulge + secondaryBulge + sideCompression;
                    const newRadius = 2.15 + totalEffect;
                    
                    vertex.multiplyScalar(newRadius);
                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
                
                positions.needsUpdate = true;
            }

            updateTidalIndicators() {
                const moonPos = this.moon.position.clone().normalize();
                
                this.tidalIndicators.forEach((indicator, index) => {
                    if (indicator.type === 'high') {
                        if (index === 0) {
                            // High tide facing moon
                            indicator.mesh.position.copy(moonPos).multiplyScalar(3);
                            indicator.mesh.lookAt(moonPos.clone().multiplyScalar(4));
                        } else {
                            // High tide opposite moon
                            indicator.mesh.position.copy(moonPos).multiplyScalar(-3);
                            indicator.mesh.lookAt(moonPos.clone().multiplyScalar(-4));
                        }
                    } else {
                        // Low tide perpendicular to moon
                        const perpendicular = new THREE.Vector3(-moonPos.z, 0, moonPos.x);
                        const direction = index === 2 ? 1 : -1;
                        indicator.mesh.position.copy(perpendicular).multiplyScalar(3 * direction);
                        indicator.mesh.lookAt(perpendicular.clone().multiplyScalar(4 * direction));
                    }
                });
            }
            
            // Add missing methods for realistic object creation
            async loadPlanetTexture(planetName) {
                const textureUrls = {
                    sun: ['https://threejs.org/examples/textures/planets/sun.jpg'],
                    earth: ['https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'],
                    earth_clouds: ['https://threejs.org/examples/textures/planets/earth_clouds_1024.png'],
                    moon: ['https://threejs.org/examples/textures/planets/moon_1024.jpg']
                };
                
                const urls = textureUrls[planetName] || textureUrls.earth;
                
                return new Promise((resolve) => {
                    const loader = new THREE.TextureLoader();
                    loader.load(urls[0], resolve, undefined, () => resolve(null));
                });
            }

            async createRealisticEarth(size = 2, position = [0, 0, 0]) {
                const earthGeometry = new THREE.SphereGeometry(size, 64, 64);
                const earthMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x6B93D6,
                    shininess: 30
                });
                const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earth.rotation.z = Math.PI * 23.5 / 180; // Apply tilt
                earth.position.set(...position);
                return earth;
            }

            async createRealisticSun(size = 0.3, position = [25, 5, 5]) {
                const sunGeometry = new THREE.SphereGeometry(size, 32, 32);
                const sunMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFFD700,
                    emissive: 0xFFAA00,
                    emissiveIntensity: 1
                });
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                sun.position.set(...position);
                return sun;
            }

            async createRealisticMoon(size = 0.6, position = [8, 0, 0]) {
                const moonGeometry = new THREE.SphereGeometry(size, 32, 32);
                const moonMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xC0C0C0,
                    shininess: 1
                });
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.position.set(...position);
                return moon;
            }

            createEnhancedSolarFlares(sunGroup, sunSize) {
                // Simple solar flare effect
                const flareGeometry = new THREE.SphereGeometry(sunSize * 1.2, 16, 16);
                const flareMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFAA00,
                    transparent: true,
                    opacity: 0.3
                });
                const flares = new THREE.Mesh(flareGeometry, flareMaterial);
                sunGroup.add(flares);
                sunGroup.solarFlares = flares;
                return flares;
            }
        }

        // Initialize 3D Solar System and Phenomena
        let solarSystem3D;
        let seasons3D;
        let dayNight3D;
        let tidal3D;
        
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize main solar system first
            solarSystem3D = new SolarSystem3D();
            
            // Initialize 3D phenomena demonstrations with proper async handling
            try {
                // Create instances and wait for them to initialize
                setTimeout(async () => {
                    try {
                        seasons3D = new Seasons3D('seasons-3d-container');
                        dayNight3D = new DayNight3D('day-night-3d-container'); 
                        tidal3D = new Tidal3D('tidal-3d-container');
                    } catch (error) {
                        console.error('Error initializing 3D phenomena:', error);
                    }
                }, 1500); // Delay to ensure main solar system loads first
            } catch (error) {
                console.error('Error setting up 3D demonstrations:', error);
            }
        });
    </script>
</body>
</html> 