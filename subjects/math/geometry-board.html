<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‡ ä½•ç”»æ¿ - æ•°å­¦å­¦ä¹ åŠ©æ‰‹</title>
    <link rel="icon" href="assets/icons/alex.ico" type="image/x-icon">
    <link rel="stylesheet" href="../../css/common.css">
    <link rel="stylesheet" href="../../css/components.css">
    <link rel="stylesheet" href="../../css/utilities.css">
    <link rel="stylesheet" href="../../css/responsive.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .geometry-workspace {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-right: 20px;
        }

        .tool-group label {
            font-weight: 600;
            color: #495057;
            margin-right: 10px;
        }

        .tool-btn {
            padding: 8px 15px;
            border: 2px solid #dee2e6;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tool-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .tool-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .color-picker {
            width: 40px;
            height: 35px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            background: #ff0000;
        }

        .size-slider {
            width: 100px;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #fafafa;
            overflow: hidden;
        }

        #geometryCanvas {
            display: block;
            cursor: crosshair;
            background: white;
            width: 100%;
            height: 100%;
        }

        .coordinates {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }

        .info-panel {
            background: #f8f9fa;
            padding: 15px;
            border-top: 2px solid #e9ecef;
            max-height: 200px;
            overflow-y: auto;
        }

        .shape-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-card {
            background: white;
            padding: 10px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .info-card h4 {
            color: #007bff;
            margin-bottom: 5px;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-btn:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .grid-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .toolbar {
                padding: 10px;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 5px;
            }

            .tool-group {
                margin-right: 0;
                margin-bottom: 5px;
                justify-content: center;
                flex-wrap: wrap;
                flex: none;
                min-width: auto;
            }

            .tool-group label {
                display: none; /* Hide labels on mobile to save space */
            }

            .tool-btn {
                padding: 8px 6px;
                font-size: 11px;
                min-width: 50px;
                margin: 1px;
                white-space: nowrap;
            }

            .canvas-container {
                min-height: 60vh;
                height: 60vh;
                touch-action: none; /* Prevent default touch behaviors */
            }

            #geometryCanvas {
                touch-action: none; /* Prevent scrolling and zooming */
            }

            .info-panel {
                max-height: 150px;
            }

            .coordinates {
                font-size: 11px;
                padding: 3px 6px;
            }

            .grid-toggle {
                font-size: 11px;
                padding: 3px 6px;
            }

            .color-picker {
                width: 30px;
                height: 30px;
            }

            .size-slider {
                width: 60px;
            }
        }

        @media (max-width: 480px) {
            .toolbar {
                padding: 8px;
                gap: 3px;
            }

            .tool-group {
                margin-bottom: 3px;
            }

            .tool-btn {
                padding: 6px 4px;
                font-size: 10px;
                min-width: 45px;
                margin: 1px;
            }

            .canvas-container {
                min-height: 50vh;
                height: 50vh;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .header p {
                font-size: 0.9rem;
            }

            .color-picker {
                width: 25px;
                height: 25px;
            }

            .size-slider {
                width: 50px;
            }

            #sizeDisplay {
                font-size: 10px;
            }
        }

        .measurement-display {
            position: absolute;
            background: rgba(255, 255, 0, 0.9);
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <button class="back-btn" onclick="window.location.href='main.html'">â† è¿”å›æ•°å­¦ä¸»é¡µ</button>
    
    <div class="container">
        <div class="header">
            <h1>ğŸ”· å‡ ä½•ç”»æ¿</h1>
            <p>äº¤äº’å¼å‡ ä½•ç»˜å›¾å·¥å…· - æ¢ç´¢å‡ ä½•ä¸–ç•Œçš„å¥¥ç§˜</p>
        </div>

        <div class="geometry-workspace">
            <div class="toolbar">
                <div class="tool-group">
                    <label>ç»˜å›¾å·¥å…·:</label>
                    <button class="tool-btn active" data-tool="select">âœ‹ é€‰æ‹©</button>
                    <button class="tool-btn" data-tool="point">ğŸ“ ç‚¹</button>
                    <button class="tool-btn" data-tool="line">ğŸ“ ç›´çº¿</button>
                    <button class="tool-btn" data-tool="segment">â– çº¿æ®µ</button>
                    <button class="tool-btn" data-tool="ray">ğŸ”¦ å°„çº¿</button>
                </div>

                <div class="tool-group">
                    <label>å½¢çŠ¶:</label>
                    <button class="tool-btn" data-tool="circle">â­• åœ†</button>
                    <button class="tool-btn" data-tool="rectangle">â¬œ çŸ©å½¢</button>
                    <button class="tool-btn" data-tool="triangle">ğŸ”º ä¸‰è§’å½¢</button>
                    <button class="tool-btn" data-tool="polygon">ğŸ”· å¤šè¾¹å½¢</button>
                </div>

                <div class="tool-group">
                    <label>æµ‹é‡:</label>
                    <button class="tool-btn" data-tool="distance">ğŸ“ è·ç¦»</button>
                    <button class="tool-btn" data-tool="angle">ğŸ“ è§’åº¦</button>
                    <button class="tool-btn" data-tool="area">ğŸ“Š é¢ç§¯</button>
                </div>

                <div class="tool-group">
                    <label>é¢œè‰²:</label>
                    <input type="color" class="color-picker" id="colorPicker" value="#ff0000">
                </div>

                <div class="tool-group">
                    <label>ç²—ç»†:</label>
                    <input type="range" class="size-slider" id="sizeSlider" min="1" max="10" value="2">
                    <span id="sizeDisplay">2px</span>
                </div>

                <div class="tool-group">
                    <button class="tool-btn" onclick="clearCanvas()">ğŸ—‘ï¸ æ¸…ç©º</button>
                    <button class="tool-btn" onclick="toggleGrid()">âŠ ç½‘æ ¼</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="geometryCanvas"></canvas>
                <div class="coordinates" id="coordinates">åæ ‡: (0, 0)</div>
                <button class="grid-toggle" id="gridToggle" onclick="toggleGrid()">æ˜¾ç¤ºç½‘æ ¼</button>
            </div>

            <div class="info-panel">
                <div class="shape-info" id="shapeInfo">
                    <div class="info-card">
                        <h4>ä½¿ç”¨è¯´æ˜</h4>
                        <p>é€‰æ‹©å·¥å…·ååœ¨ç”»å¸ƒä¸Šç‚¹å‡»æˆ–æ‹–æ‹½æ¥åˆ›å»ºå‡ ä½•å›¾å½¢ã€‚ä½¿ç”¨æµ‹é‡å·¥å…·å¯ä»¥è®¡ç®—è·ç¦»ã€è§’åº¦å’Œé¢ç§¯ã€‚</p>
                    </div>
                    <div class="info-card">
                        <h4>å¿«æ·æ“ä½œ</h4>
                        <p>â€¢ åŒå‡»åˆ é™¤å›¾å½¢<br>â€¢ æ‹–æ‹½ç§»åŠ¨å›¾å½¢<br>â€¢ å³é”®æŸ¥çœ‹å±æ€§</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class GeometryBoard {
            constructor() {
                this.canvas = document.getElementById('geometryCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentTool = 'select';
                this.isDrawing = false;
                this.startPoint = null;
                this.shapes = [];
                this.selectedShape = null;
                this.showGrid = false;
                this.measurements = [];
                this.tempPoints = [];
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupToolbar();
                this.redraw();
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                // Handle high DPI displays
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
                this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                
                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                
                // Prevent default touch behaviors
                this.canvas.addEventListener('touchstart', (e) => e.preventDefault());
                this.canvas.addEventListener('touchmove', (e) => e.preventDefault());
                this.canvas.addEventListener('touchend', (e) => e.preventDefault());
                
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.redraw();
                });

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && this.currentTool === 'area' && this.tempPoints.length >= 3) {
                        this.finishAreaMeasurement();
                    } else if (e.key === 'Escape') {
                        this.tempPoints = [];
                        this.redraw();
                        this.updateShapeInfo();
                    }
                });
            }

            // Touch event handlers
            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.handleMouseDown(mouseEvent);
            }

            handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.handleMouseMove(mouseEvent);
            }

            handleTouchEnd(e) {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                this.handleMouseUp(mouseEvent);
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                return {
                    x: (e.clientX - rect.left) * (this.canvas.width / rect.width) / dpr,
                    y: (e.clientY - rect.top) * (this.canvas.height / rect.height) / dpr
                };
            }

            handleRightClick(e) {
                e.preventDefault();
                if (this.currentTool === 'area' && this.tempPoints.length >= 3) {
                    this.finishAreaMeasurement();
                }
            }

            setupToolbar() {
                // Tool buttons
                document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        this.tempPoints = [];
                    });
                });

                // Color picker
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.currentColor = e.target.value;
                });

                // Size slider
                const sizeSlider = document.getElementById('sizeSlider');
                const sizeDisplay = document.getElementById('sizeDisplay');
                sizeSlider.addEventListener('input', (e) => {
                    this.currentSize = parseInt(e.target.value);
                    sizeDisplay.textContent = this.currentSize + 'px';
                });

                // Initialize values
                this.currentColor = document.getElementById('colorPicker').value;
                this.currentSize = parseInt(sizeSlider.value);
            }

            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                this.isDrawing = true;
                this.startPoint = pos;

                switch (this.currentTool) {
                    case 'select':
                        this.selectShape(pos);
                        break;
                    case 'point':
                        this.addPoint(pos);
                        break;
                    case 'triangle':
                    case 'polygon':
                        this.addPolygonPoint(pos);
                        break;
                    case 'distance':
                    case 'angle':
                        this.startMeasurement(pos);
                        break;
                }
            }

            handleMouseMove(e) {
                const pos = this.getMousePos(e);
                
                // Update coordinates display
                document.getElementById('coordinates').textContent = 
                    `åæ ‡: (${Math.round(pos.x)}, ${Math.round(pos.y)})`;

                if (!this.isDrawing) return;

                if (this.currentTool === 'select' && this.selectedShape) {
                    this.moveShape(pos);
                } else if (['line', 'segment', 'ray', 'circle', 'rectangle'].includes(this.currentTool)) {
                    this.redraw();
                    this.drawPreview(this.startPoint, pos);
                }
            }

            handleMouseUp(e) {
                if (!this.isDrawing) return;
                
                const pos = this.getMousePos(e);
                this.isDrawing = false;

                switch (this.currentTool) {
                    case 'line':
                        this.addLine(this.startPoint, pos);
                        break;
                    case 'segment':
                        this.addSegment(this.startPoint, pos);
                        break;
                    case 'ray':
                        this.addRay(this.startPoint, pos);
                        break;
                    case 'circle':
                        this.addCircle(this.startPoint, pos);
                        break;
                    case 'rectangle':
                        this.addRectangle(this.startPoint, pos);
                        break;
                }

                this.redraw();
                this.updateShapeInfo();
            }

            handleDoubleClick(e) {
                const pos = this.getMousePos(e);
                const shape = this.findShapeAt(pos);
                if (shape) {
                    this.deleteShape(shape);
                    this.redraw();
                    this.updateShapeInfo();
                }
            }

            addPoint(pos) {
                const shape = {
                    type: 'point',
                    x: pos.x,
                    y: pos.y,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
                this.redraw();
                this.updateShapeInfo();
            }

            addLine(start, end) {
                const shape = {
                    type: 'line',
                    start: start,
                    end: end,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addSegment(start, end) {
                const shape = {
                    type: 'segment',
                    start: start,
                    end: end,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addRay(start, end) {
                const shape = {
                    type: 'ray',
                    start: start,
                    end: end,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addCircle(center, edge) {
                const radius = Math.sqrt(
                    Math.pow(edge.x - center.x, 2) + Math.pow(edge.y - center.y, 2)
                );
                const shape = {
                    type: 'circle',
                    center: center,
                    radius: radius,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addRectangle(start, end) {
                const shape = {
                    type: 'rectangle',
                    start: start,
                    end: end,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addPolygonPoint(pos) {
                this.tempPoints.push(pos);
                
                if (this.currentTool === 'triangle' && this.tempPoints.length === 3) {
                    const shape = {
                        type: 'triangle',
                        points: [...this.tempPoints],
                        color: this.currentColor,
                        size: this.currentSize
                    };
                    this.shapes.push(shape);
                    this.tempPoints = [];
                    this.redraw();
                    this.updateShapeInfo();
                } else if (this.currentTool === 'polygon') {
                    this.redraw();
                    this.drawTempPolygon();
                }
            }

            startMeasurement(pos) {
                if (this.currentTool === 'distance') {
                    if (this.tempPoints.length === 0) {
                        this.tempPoints.push(pos);
                    } else {
                        const distance = Math.sqrt(
                            Math.pow(pos.x - this.tempPoints[0].x, 2) + 
                            Math.pow(pos.y - this.tempPoints[0].y, 2)
                        );
                        this.addMeasurement('distance', this.tempPoints[0], pos, distance.toFixed(2) + 'px');
                        this.tempPoints = [];
                    }
                } else if (this.currentTool === 'angle') {
                    this.tempPoints.push(pos);
                    if (this.tempPoints.length === 3) {
                        const angle = this.calculateAngle(this.tempPoints[0], this.tempPoints[1], this.tempPoints[2]);
                        this.addMeasurement('angle', this.tempPoints[1], this.tempPoints[1], angle.toFixed(1) + 'Â°');
                        // Draw angle arc
                        this.addAngleArc(this.tempPoints[0], this.tempPoints[1], this.tempPoints[2]);
                        this.tempPoints = [];
                    }
                } else if (this.currentTool === 'area') {
                    this.tempPoints.push(pos);
                    if (this.tempPoints.length >= 3) {
                        // For now, calculate area when we have at least 3 points
                        // User can right-click or press Enter to finish
                    }
                }
            }

            addMeasurement(type, start, end, value) {
                const measurement = {
                    type: type,
                    start: start,
                    end: end,
                    value: value
                };
                this.measurements.push(measurement);
                this.redraw();
            }

            calculateAngle(p1, vertex, p2) {
                const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
                const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };
                
                const dot = v1.x * v2.x + v1.y * v2.y;
                const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                
                const cosAngle = dot / (mag1 * mag2);
                const angleRad = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
                return angleRad * (180 / Math.PI);
            }

            addAngleArc(p1, vertex, p2) {
                const shape = {
                    type: 'angle-arc',
                    p1: p1,
                    vertex: vertex,
                    p2: p2,
                    color: '#ff6b6b',
                    size: 2
                };
                this.shapes.push(shape);
            }

            calculatePolygonArea(points) {
                if (points.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < points.length; i++) {
                    const j = (i + 1) % points.length;
                    area += points[i].x * points[j].y;
                    area -= points[j].x * points[i].y;
                }
                return Math.abs(area) / 2;
            }

            finishAreaMeasurement() {
                if (this.tempPoints.length >= 3) {
                    const area = this.calculatePolygonArea(this.tempPoints);
                    const centroid = this.calculateCentroid(this.tempPoints);
                    this.addMeasurement('area', centroid, centroid, area.toFixed(2) + 'pxÂ²');
                    
                    // Add the polygon outline
                    const shape = {
                        type: 'area-polygon',
                        points: [...this.tempPoints],
                        color: 'rgba(255, 107, 107, 0.3)',
                        size: 2
                    };
                    this.shapes.push(shape);
                    this.tempPoints = [];
                    this.redraw();
                    this.updateShapeInfo();
                }
            }

            calculateCentroid(points) {
                let cx = 0, cy = 0;
                points.forEach(p => {
                    cx += p.x;
                    cy += p.y;
                });
                return { x: cx / points.length, y: cy / points.length };
            }

            drawPreview(start, end) {
                this.ctx.strokeStyle = this.currentColor;
                this.ctx.lineWidth = this.currentSize;
                this.ctx.setLineDash([5, 5]);

                switch (this.currentTool) {
                    case 'line':
                    case 'segment':
                    case 'ray':
                        this.ctx.beginPath();
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                        this.ctx.stroke();
                        break;
                    case 'circle':
                        const radius = Math.sqrt(
                            Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)
                        );
                        this.ctx.beginPath();
                        this.ctx.arc(start.x, start.y, radius, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        break;
                    case 'rectangle':
                        this.ctx.beginPath();
                        this.ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                        this.ctx.stroke();
                        break;
                }

                this.ctx.setLineDash([]);
            }

            drawTempPolygon() {
                if (this.tempPoints.length < 2) return;

                this.ctx.strokeStyle = this.currentColor;
                this.ctx.lineWidth = this.currentSize;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.tempPoints[0].x, this.tempPoints[0].y);
                
                for (let i = 1; i < this.tempPoints.length; i++) {
                    this.ctx.lineTo(this.tempPoints[i].x, this.tempPoints[i].y);
                }
                
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // Draw temp points
                this.tempPoints.forEach(point => {
                    this.ctx.fillStyle = this.currentColor;
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }

            drawTempArea() {
                if (this.tempPoints.length < 1) return;

                // Draw temp points
                this.tempPoints.forEach((point, index) => {
                    this.ctx.fillStyle = '#ff6b6b';
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Draw point number
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText((index + 1).toString(), point.x, point.y + 4);
                });

                // Draw connecting lines
                if (this.tempPoints.length >= 2) {
                    this.ctx.strokeStyle = '#ff6b6b';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.tempPoints[0].x, this.tempPoints[0].y);
                    
                    for (let i = 1; i < this.tempPoints.length; i++) {
                        this.ctx.lineTo(this.tempPoints[i].x, this.tempPoints[i].y);
                    }
                    
                    // Close the polygon if we have 3+ points
                    if (this.tempPoints.length >= 3) {
                        this.ctx.lineTo(this.tempPoints[0].x, this.tempPoints[0].y);
                    }
                    
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }

            drawTempAngle() {
                this.tempPoints.forEach((point, index) => {
                    this.ctx.fillStyle = '#ff6b6b';
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Draw labels
                    this.ctx.fillStyle = 'black';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    const labels = ['è¾¹1', 'é¡¶ç‚¹', 'è¾¹2'];
                    if (labels[index]) {
                        this.ctx.fillText(labels[index], point.x, point.y - 10);
                    }
                });

                // Draw connecting lines
                if (this.tempPoints.length >= 2) {
                    this.ctx.strokeStyle = '#ff6b6b';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([3, 3]);
                    
                    if (this.tempPoints.length === 2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.tempPoints[0].x, this.tempPoints[0].y);
                        this.ctx.lineTo(this.tempPoints[1].x, this.tempPoints[1].y);
                        this.ctx.stroke();
                    } else if (this.tempPoints.length === 3) {
                        // Draw both lines from vertex
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.tempPoints[1].x, this.tempPoints[1].y);
                        this.ctx.lineTo(this.tempPoints[0].x, this.tempPoints[0].y);
                        this.ctx.moveTo(this.tempPoints[1].x, this.tempPoints[1].y);
                        this.ctx.lineTo(this.tempPoints[2].x, this.tempPoints[2].y);
                        this.ctx.stroke();
                    }
                    
                    this.ctx.setLineDash([]);
                }
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.showGrid) {
                    this.drawGrid();
                }

                this.shapes.forEach(shape => this.drawShape(shape));
                this.measurements.forEach(measurement => this.drawMeasurement(measurement));
                
                if (this.currentTool === 'polygon' && this.tempPoints.length > 0) {
                    this.drawTempPolygon();
                } else if (this.currentTool === 'area' && this.tempPoints.length > 0) {
                    this.drawTempArea();
                } else if (this.currentTool === 'angle' && this.tempPoints.length > 0) {
                    this.drawTempAngle();
                }
            }

            drawGrid() {
                const gridSize = 20;
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;

                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawShape(shape) {
                this.ctx.strokeStyle = shape.color;
                this.ctx.fillStyle = shape.color;
                this.ctx.lineWidth = shape.size;

                switch (shape.type) {
                    case 'point':
                        this.ctx.beginPath();
                        this.ctx.arc(shape.x, shape.y, shape.size + 2, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                    case 'line':
                        this.extendLine(shape.start, shape.end);
                        break;
                    case 'segment':
                        this.ctx.beginPath();
                        this.ctx.moveTo(shape.start.x, shape.start.y);
                        this.ctx.lineTo(shape.end.x, shape.end.y);
                        this.ctx.stroke();
                        break;
                    case 'ray':
                        this.extendRay(shape.start, shape.end);
                        break;
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(shape.center.x, shape.center.y, shape.radius, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        break;
                    case 'rectangle':
                        this.ctx.beginPath();
                        this.ctx.rect(shape.start.x, shape.start.y, 
                                     shape.end.x - shape.start.x, shape.end.y - shape.start.y);
                        this.ctx.stroke();
                        break;
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                        this.ctx.lineTo(shape.points[1].x, shape.points[1].y);
                        this.ctx.lineTo(shape.points[2].x, shape.points[2].y);
                        this.ctx.closePath();
                        this.ctx.stroke();
                        break;
                    case 'angle-arc':
                        this.drawAngleArc(shape);
                        break;
                    case 'area-polygon':
                        this.drawAreaPolygon(shape);
                        break;
                }
            }

            extendLine(start, end) {
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / length;
                const unitY = dy / length;
                
                const extension = 1000;
                const newStart = {
                    x: start.x - unitX * extension,
                    y: start.y - unitY * extension
                };
                const newEnd = {
                    x: end.x + unitX * extension,
                    y: end.y + unitY * extension
                };

                this.ctx.beginPath();
                this.ctx.moveTo(newStart.x, newStart.y);
                this.ctx.lineTo(newEnd.x, newEnd.y);
                this.ctx.stroke();
            }

            extendRay(start, end) {
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / length;
                const unitY = dy / length;
                
                const extension = 1000;
                const newEnd = {
                    x: start.x + unitX * extension,
                    y: start.y + unitY * extension
                };

                this.ctx.beginPath();
                this.ctx.moveTo(start.x, start.y);
                this.ctx.lineTo(newEnd.x, newEnd.y);
                this.ctx.stroke();
            }

            drawAngleArc(shape) {
                const { p1, vertex, p2 } = shape;
                const radius = 30;
                
                // Calculate angles
                const angle1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);
                const angle2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x);
                
                this.ctx.strokeStyle = shape.color;
                this.ctx.lineWidth = shape.size;
                this.ctx.beginPath();
                this.ctx.arc(vertex.x, vertex.y, radius, angle1, angle2);
                this.ctx.stroke();
                
                // Draw angle lines
                this.ctx.beginPath();
                this.ctx.moveTo(vertex.x, vertex.y);
                this.ctx.lineTo(vertex.x + Math.cos(angle1) * radius * 1.5, vertex.y + Math.sin(angle1) * radius * 1.5);
                this.ctx.moveTo(vertex.x, vertex.y);
                this.ctx.lineTo(vertex.x + Math.cos(angle2) * radius * 1.5, vertex.y + Math.sin(angle2) * radius * 1.5);
                this.ctx.stroke();
            }

            drawAreaPolygon(shape) {
                if (shape.points.length < 3) return;
                
                this.ctx.fillStyle = shape.color;
                this.ctx.strokeStyle = shape.color.replace('0.3', '1');
                this.ctx.lineWidth = shape.size;
                
                this.ctx.beginPath();
                this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                for (let i = 1; i < shape.points.length; i++) {
                    this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
            }

            drawMeasurement(measurement) {
                this.ctx.strokeStyle = '#ff6b6b';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([3, 3]);
                
                this.ctx.beginPath();
                this.ctx.moveTo(measurement.start.x, measurement.start.y);
                this.ctx.lineTo(measurement.end.x, measurement.end.y);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
                
                // Draw measurement text
                const midX = (measurement.start.x + measurement.end.x) / 2;
                const midY = (measurement.start.y + measurement.end.y) / 2;
                
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(measurement.value, midX + 5, midY - 5);
            }

            selectShape(pos) {
                this.selectedShape = this.findShapeAt(pos);
                this.redraw();
                
                if (this.selectedShape) {
                    this.highlightShape(this.selectedShape);
                }
            }

            findShapeAt(pos) {
                for (let i = this.shapes.length - 1; i >= 0; i--) {
                    const shape = this.shapes[i];
                    if (this.isPointInShape(pos, shape)) {
                        return shape;
                    }
                }
                return null;
            }

            isPointInShape(pos, shape) {
                const tolerance = 10;
                
                switch (shape.type) {
                    case 'point':
                        return Math.sqrt(Math.pow(pos.x - shape.x, 2) + Math.pow(pos.y - shape.y, 2)) <= tolerance;
                    case 'segment':
                        return this.distanceToLine(pos, shape.start, shape.end) <= tolerance;
                    case 'circle':
                        const distToCenter = Math.sqrt(Math.pow(pos.x - shape.center.x, 2) + Math.pow(pos.y - shape.center.y, 2));
                        return Math.abs(distToCenter - shape.radius) <= tolerance;
                    case 'rectangle':
                        return pos.x >= Math.min(shape.start.x, shape.end.x) - tolerance &&
                               pos.x <= Math.max(shape.start.x, shape.end.x) + tolerance &&
                               pos.y >= Math.min(shape.start.y, shape.end.y) - tolerance &&
                               pos.y <= Math.max(shape.start.y, shape.end.y) + tolerance;
                    default:
                        return false;
                }
            }

            distanceToLine(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            highlightShape(shape) {
                this.ctx.strokeStyle = '#ff6b6b';
                this.ctx.lineWidth = shape.size + 2;
                this.ctx.setLineDash([5, 5]);
                this.drawShape(shape);
                this.ctx.setLineDash([]);
            }

            moveShape(newPos) {
                if (!this.selectedShape) return;
                
                const dx = newPos.x - this.startPoint.x;
                const dy = newPos.y - this.startPoint.y;
                
                switch (this.selectedShape.type) {
                    case 'point':
                        this.selectedShape.x += dx;
                        this.selectedShape.y += dy;
                        break;
                    case 'segment':
                    case 'line':
                    case 'ray':
                        this.selectedShape.start.x += dx;
                        this.selectedShape.start.y += dy;
                        this.selectedShape.end.x += dx;
                        this.selectedShape.end.y += dy;
                        break;
                    case 'circle':
                        this.selectedShape.center.x += dx;
                        this.selectedShape.center.y += dy;
                        break;
                    case 'rectangle':
                        this.selectedShape.start.x += dx;
                        this.selectedShape.start.y += dy;
                        this.selectedShape.end.x += dx;
                        this.selectedShape.end.y += dy;
                        break;
                }
                
                this.startPoint = newPos;
                this.redraw();
                this.highlightShape(this.selectedShape);
            }

            deleteShape(shape) {
                const index = this.shapes.indexOf(shape);
                if (index > -1) {
                    this.shapes.splice(index, 1);
                }
            }

            updateShapeInfo() {
                const infoPanel = document.getElementById('shapeInfo');
                let html = '';
                
                const shapeCount = {};
                this.shapes.forEach(shape => {
                    shapeCount[shape.type] = (shapeCount[shape.type] || 0) + 1;
                });

                html += '<div class="info-card"><h4>å›¾å½¢ç»Ÿè®¡</h4><p>';
                Object.entries(shapeCount).forEach(([type, count]) => {
                    const typeName = {
                        'point': 'ç‚¹',
                        'line': 'ç›´çº¿',
                        'segment': 'çº¿æ®µ',
                        'ray': 'å°„çº¿',
                        'circle': 'åœ†',
                        'rectangle': 'çŸ©å½¢',
                        'triangle': 'ä¸‰è§’å½¢'
                    }[type] || type;
                    html += `${typeName}: ${count}ä¸ª<br>`;
                });
                html += '</p></div>';

                if (this.measurements.length > 0) {
                    html += '<div class="info-card"><h4>æµ‹é‡ç»“æœ</h4><p>';
                    this.measurements.forEach((measurement, index) => {
                        html += `æµ‹é‡${index + 1}: ${measurement.value}<br>`;
                    });
                    html += '</p></div>';
                }

                html += '<div class="info-card"><h4>æ“ä½œæç¤º</h4><p>';
                if (this.currentTool === 'triangle') {
                    html += `ä¸‰è§’å½¢ç»˜åˆ¶: å·²é€‰æ‹© ${this.tempPoints.length}/3 ä¸ªç‚¹`;
                } else if (this.currentTool === 'polygon') {
                    html += `å¤šè¾¹å½¢ç»˜åˆ¶: å·²é€‰æ‹© ${this.tempPoints.length} ä¸ªç‚¹ï¼ŒåŒå‡»å®Œæˆ`;
                } else if (this.currentTool === 'distance') {
                    html += this.tempPoints.length === 0 ? 'ç‚¹å‡»ç¬¬ä¸€ä¸ªç‚¹å¼€å§‹æµ‹é‡è·ç¦»' : 'ç‚¹å‡»ç¬¬äºŒä¸ªç‚¹å®Œæˆè·ç¦»æµ‹é‡';
                } else if (this.currentTool === 'angle') {
                    if (this.tempPoints.length === 0) {
                        html += 'è§’åº¦æµ‹é‡: ç‚¹å‡»ç¬¬ä¸€ä¸ªç‚¹ï¼ˆè§’çš„ä¸€è¾¹ï¼‰';
                    } else if (this.tempPoints.length === 1) {
                        html += 'è§’åº¦æµ‹é‡: ç‚¹å‡»é¡¶ç‚¹ï¼ˆè§’çš„é¡¶ç‚¹ï¼‰';
                    } else if (this.tempPoints.length === 2) {
                        html += 'è§’åº¦æµ‹é‡: ç‚¹å‡»ç¬¬ä¸‰ä¸ªç‚¹ï¼ˆè§’çš„å¦ä¸€è¾¹ï¼‰';
                    }
                } else if (this.currentTool === 'area') {
                    if (this.tempPoints.length < 3) {
                        html += `é¢ç§¯æµ‹é‡: å·²é€‰æ‹© ${this.tempPoints.length} ä¸ªç‚¹ï¼Œè‡³å°‘éœ€è¦3ä¸ªç‚¹`;
                    } else {
                        html += `é¢ç§¯æµ‹é‡: å·²é€‰æ‹© ${this.tempPoints.length} ä¸ªç‚¹ï¼Œå³é”®æˆ–æŒ‰Enterå®Œæˆ`;
                    }
                } else {
                    html += 'é€‰æ‹©å·¥å…·ååœ¨ç”»å¸ƒä¸Šç»˜åˆ¶å›¾å½¢';
                }
                html += '</p></div>';

                infoPanel.innerHTML = html;
            }
        }

        // Global functions
        function clearCanvas() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºç”»å¸ƒå—ï¼Ÿ')) {
                geometryBoard.shapes = [];
                geometryBoard.measurements = [];
                geometryBoard.tempPoints = [];
                geometryBoard.selectedShape = null;
                geometryBoard.redraw();
                geometryBoard.updateShapeInfo();
            }
        }

        function toggleGrid() {
            geometryBoard.showGrid = !geometryBoard.showGrid;
            const gridToggle = document.getElementById('gridToggle');
            gridToggle.textContent = geometryBoard.showGrid ? 'éšè—ç½‘æ ¼' : 'æ˜¾ç¤ºç½‘æ ¼';
            geometryBoard.redraw();
        }

        // Initialize the geometry board
        let geometryBoard;
        window.addEventListener('load', () => {
            geometryBoard = new GeometryBoard();
        });
    </script>
</body>
</html> 