<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>几何画板 - 数学学习助手</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .geometry-workspace {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-right: 20px;
        }

        .tool-group label {
            font-weight: 600;
            color: #495057;
            margin-right: 10px;
        }

        .tool-btn {
            padding: 8px 15px;
            border: 2px solid #dee2e6;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tool-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .tool-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .color-picker {
            width: 40px;
            height: 35px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            background: #ff0000;
        }

        .size-slider {
            width: 100px;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #fafafa;
            overflow: hidden;
        }

        #geometryCanvas {
            display: block;
            cursor: crosshair;
            background: white;
            width: 100%;
            height: 100%;
        }

        .coordinates {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }

        .info-panel {
            background: #f8f9fa;
            padding: 15px;
            border-top: 2px solid #e9ecef;
            max-height: 200px;
            overflow-y: auto;
        }

        .shape-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-card {
            background: white;
            padding: 10px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .info-card h4 {
            color: #007bff;
            margin-bottom: 5px;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-btn:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .grid-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .toolbar {
                padding: 10px;
                flex-direction: column;
                align-items: stretch;
            }

            .tool-group {
                margin-right: 0;
                margin-bottom: 10px;
                justify-content: center;
            }

            .canvas-container {
                min-height: 400px;
            }

            .info-panel {
                max-height: 150px;
            }
        }

        .measurement-display {
            position: absolute;
            background: rgba(255, 255, 0, 0.9);
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <button class="back-btn" onclick="window.location.href='main.html'">← 返回数学主页</button>
    
    <div class="container">
        <div class="header">
            <h1>🔷 几何画板</h1>
            <p>交互式几何绘图工具 - 探索几何世界的奥秘</p>
        </div>

        <div class="geometry-workspace">
            <div class="toolbar">
                <div class="tool-group">
                    <label>绘图工具:</label>
                    <button class="tool-btn active" data-tool="select">✋ 选择</button>
                    <button class="tool-btn" data-tool="point">📍 点</button>
                    <button class="tool-btn" data-tool="line">📏 直线</button>
                    <button class="tool-btn" data-tool="segment">➖ 线段</button>
                    <button class="tool-btn" data-tool="ray">🔦 射线</button>
                </div>

                <div class="tool-group">
                    <label>形状:</label>
                    <button class="tool-btn" data-tool="circle">⭕ 圆</button>
                    <button class="tool-btn" data-tool="rectangle">⬜ 矩形</button>
                    <button class="tool-btn" data-tool="triangle">🔺 三角形</button>
                    <button class="tool-btn" data-tool="polygon">🔷 多边形</button>
                </div>

                <div class="tool-group">
                    <label>测量:</label>
                    <button class="tool-btn" data-tool="distance">📐 距离</button>
                    <button class="tool-btn" data-tool="angle">📐 角度</button>
                    <button class="tool-btn" data-tool="area">📊 面积</button>
                </div>

                <div class="tool-group">
                    <label>颜色:</label>
                    <input type="color" class="color-picker" id="colorPicker" value="#ff0000">
                </div>

                <div class="tool-group">
                    <label>粗细:</label>
                    <input type="range" class="size-slider" id="sizeSlider" min="1" max="10" value="2">
                    <span id="sizeDisplay">2px</span>
                </div>

                <div class="tool-group">
                    <button class="tool-btn" onclick="clearCanvas()">🗑️ 清空</button>
                    <button class="tool-btn" onclick="toggleGrid()">⊞ 网格</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="geometryCanvas"></canvas>
                <div class="coordinates" id="coordinates">坐标: (0, 0)</div>
                <button class="grid-toggle" id="gridToggle" onclick="toggleGrid()">显示网格</button>
            </div>

            <div class="info-panel">
                <div class="shape-info" id="shapeInfo">
                    <div class="info-card">
                        <h4>使用说明</h4>
                        <p>选择工具后在画布上点击或拖拽来创建几何图形。使用测量工具可以计算距离、角度和面积。</p>
                    </div>
                    <div class="info-card">
                        <h4>快捷操作</h4>
                        <p>• 双击删除图形<br>• 拖拽移动图形<br>• 右键查看属性</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class GeometryBoard {
            constructor() {
                this.canvas = document.getElementById('geometryCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentTool = 'select';
                this.isDrawing = false;
                this.startPoint = null;
                this.shapes = [];
                this.selectedShape = null;
                this.showGrid = false;
                this.measurements = [];
                this.tempPoints = [];
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupToolbar();
                this.redraw();
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                // Handle high DPI displays
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
                
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.redraw();
                });
            }

            setupToolbar() {
                // Tool buttons
                document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        this.tempPoints = [];
                    });
                });

                // Color picker
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.currentColor = e.target.value;
                });

                // Size slider
                const sizeSlider = document.getElementById('sizeSlider');
                const sizeDisplay = document.getElementById('sizeDisplay');
                sizeSlider.addEventListener('input', (e) => {
                    this.currentSize = parseInt(e.target.value);
                    sizeDisplay.textContent = this.currentSize + 'px';
                });

                // Initialize values
                this.currentColor = document.getElementById('colorPicker').value;
                this.currentSize = parseInt(sizeSlider.value);
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                this.isDrawing = true;
                this.startPoint = pos;

                switch (this.currentTool) {
                    case 'select':
                        this.selectShape(pos);
                        break;
                    case 'point':
                        this.addPoint(pos);
                        break;
                    case 'triangle':
                    case 'polygon':
                        this.addPolygonPoint(pos);
                        break;
                    case 'distance':
                    case 'angle':
                        this.startMeasurement(pos);
                        break;
                }
            }

            handleMouseMove(e) {
                const pos = this.getMousePos(e);
                
                // Update coordinates display
                document.getElementById('coordinates').textContent = 
                    `坐标: (${Math.round(pos.x)}, ${Math.round(pos.y)})`;

                if (!this.isDrawing) return;

                if (this.currentTool === 'select' && this.selectedShape) {
                    this.moveShape(pos);
                } else if (['line', 'segment', 'ray', 'circle', 'rectangle'].includes(this.currentTool)) {
                    this.redraw();
                    this.drawPreview(this.startPoint, pos);
                }
            }

            handleMouseUp(e) {
                if (!this.isDrawing) return;
                
                const pos = this.getMousePos(e);
                this.isDrawing = false;

                switch (this.currentTool) {
                    case 'line':
                        this.addLine(this.startPoint, pos);
                        break;
                    case 'segment':
                        this.addSegment(this.startPoint, pos);
                        break;
                    case 'ray':
                        this.addRay(this.startPoint, pos);
                        break;
                    case 'circle':
                        this.addCircle(this.startPoint, pos);
                        break;
                    case 'rectangle':
                        this.addRectangle(this.startPoint, pos);
                        break;
                }

                this.redraw();
                this.updateShapeInfo();
            }

            handleDoubleClick(e) {
                const pos = this.getMousePos(e);
                const shape = this.findShapeAt(pos);
                if (shape) {
                    this.deleteShape(shape);
                    this.redraw();
                    this.updateShapeInfo();
                }
            }

            addPoint(pos) {
                const shape = {
                    type: 'point',
                    x: pos.x,
                    y: pos.y,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
                this.redraw();
                this.updateShapeInfo();
            }

            addLine(start, end) {
                const shape = {
                    type: 'line',
                    start: start,
                    end: end,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addSegment(start, end) {
                const shape = {
                    type: 'segment',
                    start: start,
                    end: end,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addRay(start, end) {
                const shape = {
                    type: 'ray',
                    start: start,
                    end: end,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addCircle(center, edge) {
                const radius = Math.sqrt(
                    Math.pow(edge.x - center.x, 2) + Math.pow(edge.y - center.y, 2)
                );
                const shape = {
                    type: 'circle',
                    center: center,
                    radius: radius,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addRectangle(start, end) {
                const shape = {
                    type: 'rectangle',
                    start: start,
                    end: end,
                    color: this.currentColor,
                    size: this.currentSize
                };
                this.shapes.push(shape);
            }

            addPolygonPoint(pos) {
                this.tempPoints.push(pos);
                
                if (this.currentTool === 'triangle' && this.tempPoints.length === 3) {
                    const shape = {
                        type: 'triangle',
                        points: [...this.tempPoints],
                        color: this.currentColor,
                        size: this.currentSize
                    };
                    this.shapes.push(shape);
                    this.tempPoints = [];
                    this.redraw();
                    this.updateShapeInfo();
                } else if (this.currentTool === 'polygon') {
                    this.redraw();
                    this.drawTempPolygon();
                }
            }

            startMeasurement(pos) {
                if (this.currentTool === 'distance') {
                    if (this.tempPoints.length === 0) {
                        this.tempPoints.push(pos);
                    } else {
                        const distance = Math.sqrt(
                            Math.pow(pos.x - this.tempPoints[0].x, 2) + 
                            Math.pow(pos.y - this.tempPoints[0].y, 2)
                        );
                        this.addMeasurement('distance', this.tempPoints[0], pos, distance.toFixed(2) + 'px');
                        this.tempPoints = [];
                    }
                }
            }

            addMeasurement(type, start, end, value) {
                const measurement = {
                    type: type,
                    start: start,
                    end: end,
                    value: value
                };
                this.measurements.push(measurement);
                this.redraw();
            }

            drawPreview(start, end) {
                this.ctx.strokeStyle = this.currentColor;
                this.ctx.lineWidth = this.currentSize;
                this.ctx.setLineDash([5, 5]);

                switch (this.currentTool) {
                    case 'line':
                    case 'segment':
                    case 'ray':
                        this.ctx.beginPath();
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                        this.ctx.stroke();
                        break;
                    case 'circle':
                        const radius = Math.sqrt(
                            Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)
                        );
                        this.ctx.beginPath();
                        this.ctx.arc(start.x, start.y, radius, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        break;
                    case 'rectangle':
                        this.ctx.beginPath();
                        this.ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                        this.ctx.stroke();
                        break;
                }

                this.ctx.setLineDash([]);
            }

            drawTempPolygon() {
                if (this.tempPoints.length < 2) return;

                this.ctx.strokeStyle = this.currentColor;
                this.ctx.lineWidth = this.currentSize;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.tempPoints[0].x, this.tempPoints[0].y);
                
                for (let i = 1; i < this.tempPoints.length; i++) {
                    this.ctx.lineTo(this.tempPoints[i].x, this.tempPoints[i].y);
                }
                
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // Draw temp points
                this.tempPoints.forEach(point => {
                    this.ctx.fillStyle = this.currentColor;
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.showGrid) {
                    this.drawGrid();
                }

                this.shapes.forEach(shape => this.drawShape(shape));
                this.measurements.forEach(measurement => this.drawMeasurement(measurement));
                
                if (this.currentTool === 'polygon' && this.tempPoints.length > 0) {
                    this.drawTempPolygon();
                }
            }

            drawGrid() {
                const gridSize = 20;
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;

                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawShape(shape) {
                this.ctx.strokeStyle = shape.color;
                this.ctx.fillStyle = shape.color;
                this.ctx.lineWidth = shape.size;

                switch (shape.type) {
                    case 'point':
                        this.ctx.beginPath();
                        this.ctx.arc(shape.x, shape.y, shape.size + 2, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                    case 'line':
                        this.extendLine(shape.start, shape.end);
                        break;
                    case 'segment':
                        this.ctx.beginPath();
                        this.ctx.moveTo(shape.start.x, shape.start.y);
                        this.ctx.lineTo(shape.end.x, shape.end.y);
                        this.ctx.stroke();
                        break;
                    case 'ray':
                        this.extendRay(shape.start, shape.end);
                        break;
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(shape.center.x, shape.center.y, shape.radius, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        break;
                    case 'rectangle':
                        this.ctx.beginPath();
                        this.ctx.rect(shape.start.x, shape.start.y, 
                                     shape.end.x - shape.start.x, shape.end.y - shape.start.y);
                        this.ctx.stroke();
                        break;
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                        this.ctx.lineTo(shape.points[1].x, shape.points[1].y);
                        this.ctx.lineTo(shape.points[2].x, shape.points[2].y);
                        this.ctx.closePath();
                        this.ctx.stroke();
                        break;
                }
            }

            extendLine(start, end) {
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / length;
                const unitY = dy / length;
                
                const extension = 1000;
                const newStart = {
                    x: start.x - unitX * extension,
                    y: start.y - unitY * extension
                };
                const newEnd = {
                    x: end.x + unitX * extension,
                    y: end.y + unitY * extension
                };

                this.ctx.beginPath();
                this.ctx.moveTo(newStart.x, newStart.y);
                this.ctx.lineTo(newEnd.x, newEnd.y);
                this.ctx.stroke();
            }

            extendRay(start, end) {
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / length;
                const unitY = dy / length;
                
                const extension = 1000;
                const newEnd = {
                    x: start.x + unitX * extension,
                    y: start.y + unitY * extension
                };

                this.ctx.beginPath();
                this.ctx.moveTo(start.x, start.y);
                this.ctx.lineTo(newEnd.x, newEnd.y);
                this.ctx.stroke();
            }

            drawMeasurement(measurement) {
                this.ctx.strokeStyle = '#ff6b6b';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([3, 3]);
                
                this.ctx.beginPath();
                this.ctx.moveTo(measurement.start.x, measurement.start.y);
                this.ctx.lineTo(measurement.end.x, measurement.end.y);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
                
                // Draw measurement text
                const midX = (measurement.start.x + measurement.end.x) / 2;
                const midY = (measurement.start.y + measurement.end.y) / 2;
                
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(measurement.value, midX + 5, midY - 5);
            }

            selectShape(pos) {
                this.selectedShape = this.findShapeAt(pos);
                this.redraw();
                
                if (this.selectedShape) {
                    this.highlightShape(this.selectedShape);
                }
            }

            findShapeAt(pos) {
                for (let i = this.shapes.length - 1; i >= 0; i--) {
                    const shape = this.shapes[i];
                    if (this.isPointInShape(pos, shape)) {
                        return shape;
                    }
                }
                return null;
            }

            isPointInShape(pos, shape) {
                const tolerance = 10;
                
                switch (shape.type) {
                    case 'point':
                        return Math.sqrt(Math.pow(pos.x - shape.x, 2) + Math.pow(pos.y - shape.y, 2)) <= tolerance;
                    case 'segment':
                        return this.distanceToLine(pos, shape.start, shape.end) <= tolerance;
                    case 'circle':
                        const distToCenter = Math.sqrt(Math.pow(pos.x - shape.center.x, 2) + Math.pow(pos.y - shape.center.y, 2));
                        return Math.abs(distToCenter - shape.radius) <= tolerance;
                    case 'rectangle':
                        return pos.x >= Math.min(shape.start.x, shape.end.x) - tolerance &&
                               pos.x <= Math.max(shape.start.x, shape.end.x) + tolerance &&
                               pos.y >= Math.min(shape.start.y, shape.end.y) - tolerance &&
                               pos.y <= Math.max(shape.start.y, shape.end.y) + tolerance;
                    default:
                        return false;
                }
            }

            distanceToLine(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            highlightShape(shape) {
                this.ctx.strokeStyle = '#ff6b6b';
                this.ctx.lineWidth = shape.size + 2;
                this.ctx.setLineDash([5, 5]);
                this.drawShape(shape);
                this.ctx.setLineDash([]);
            }

            moveShape(newPos) {
                if (!this.selectedShape) return;
                
                const dx = newPos.x - this.startPoint.x;
                const dy = newPos.y - this.startPoint.y;
                
                switch (this.selectedShape.type) {
                    case 'point':
                        this.selectedShape.x += dx;
                        this.selectedShape.y += dy;
                        break;
                    case 'segment':
                    case 'line':
                    case 'ray':
                        this.selectedShape.start.x += dx;
                        this.selectedShape.start.y += dy;
                        this.selectedShape.end.x += dx;
                        this.selectedShape.end.y += dy;
                        break;
                    case 'circle':
                        this.selectedShape.center.x += dx;
                        this.selectedShape.center.y += dy;
                        break;
                    case 'rectangle':
                        this.selectedShape.start.x += dx;
                        this.selectedShape.start.y += dy;
                        this.selectedShape.end.x += dx;
                        this.selectedShape.end.y += dy;
                        break;
                }
                
                this.startPoint = newPos;
                this.redraw();
                this.highlightShape(this.selectedShape);
            }

            deleteShape(shape) {
                const index = this.shapes.indexOf(shape);
                if (index > -1) {
                    this.shapes.splice(index, 1);
                }
            }

            updateShapeInfo() {
                const infoPanel = document.getElementById('shapeInfo');
                let html = '';
                
                const shapeCount = {};
                this.shapes.forEach(shape => {
                    shapeCount[shape.type] = (shapeCount[shape.type] || 0) + 1;
                });

                html += '<div class="info-card"><h4>图形统计</h4><p>';
                Object.entries(shapeCount).forEach(([type, count]) => {
                    const typeName = {
                        'point': '点',
                        'line': '直线',
                        'segment': '线段',
                        'ray': '射线',
                        'circle': '圆',
                        'rectangle': '矩形',
                        'triangle': '三角形'
                    }[type] || type;
                    html += `${typeName}: ${count}个<br>`;
                });
                html += '</p></div>';

                if (this.measurements.length > 0) {
                    html += '<div class="info-card"><h4>测量结果</h4><p>';
                    this.measurements.forEach((measurement, index) => {
                        html += `测量${index + 1}: ${measurement.value}<br>`;
                    });
                    html += '</p></div>';
                }

                html += '<div class="info-card"><h4>操作提示</h4><p>';
                if (this.currentTool === 'triangle') {
                    html += `三角形绘制: 已选择 ${this.tempPoints.length}/3 个点`;
                } else if (this.currentTool === 'polygon') {
                    html += `多边形绘制: 已选择 ${this.tempPoints.length} 个点，双击完成`;
                } else if (this.currentTool === 'distance') {
                    html += this.tempPoints.length === 0 ? '点击第一个点开始测量距离' : '点击第二个点完成距离测量';
                } else {
                    html += '选择工具后在画布上绘制图形';
                }
                html += '</p></div>';

                infoPanel.innerHTML = html;
            }
        }

        // Global functions
        function clearCanvas() {
            if (confirm('确定要清空画布吗？')) {
                geometryBoard.shapes = [];
                geometryBoard.measurements = [];
                geometryBoard.tempPoints = [];
                geometryBoard.selectedShape = null;
                geometryBoard.redraw();
                geometryBoard.updateShapeInfo();
            }
        }

        function toggleGrid() {
            geometryBoard.showGrid = !geometryBoard.showGrid;
            const gridToggle = document.getElementById('gridToggle');
            gridToggle.textContent = geometryBoard.showGrid ? '隐藏网格' : '显示网格';
            geometryBoard.redraw();
        }

        // Initialize the geometry board
        let geometryBoard;
        window.addEventListener('load', () => {
            geometryBoard = new GeometryBoard();
        });
    </script>
</body>
</html> 