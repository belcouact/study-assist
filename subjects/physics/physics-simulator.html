<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理模拟器 - 学习助手</title>
    <link rel="icon" href="../../assets/icons/logo_btrfly.ico" type="image/x-icon">
    <link rel="stylesheet" href="../../css/common.css">
    <link rel="stylesheet" href="../../css/components.css">
    <link rel="stylesheet" href="../../css/utilities.css">
    <link rel="stylesheet" href="../../css/responsive.css">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        .simulator-page {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem 0;
        }

        .simulator-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            margin: 2rem auto;
            max-width: 1400px;
        }

        .simulator-header {
            background: linear-gradient(135deg, #4361ee, #7209b7);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .simulator-header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .simulator-header p {
            margin: 1rem 0 0 0;
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .simulator-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            overflow-x: auto;
        }

        .simulator-tab {
            flex: 1;
            min-width: 150px;
            padding: 1rem 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .simulator-tab.active {
            background: white;
            color: #4361ee;
            border-bottom: 3px solid #4361ee;
        }

        .simulator-tab:hover {
            background: rgba(67, 97, 238, 0.1);
            color: #4361ee;
        }

        .simulator-content {
            padding: 2rem;
            min-height: 600px;
        }

        .simulation-panel {
            display: none;
        }

        .simulation-panel.active {
            display: block;
        }

        .simulation-workspace {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
            height: 600px;
        }

        .simulation-controls {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .simulation-display {
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .simulation-canvas {
            width: 100%;
            height: 100%;
            display: block;
            background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f8f9fa 75%), 
                        linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            border-radius: 13px;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }

        .control-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .control-input:focus {
            outline: none;
            border-color: #4361ee;
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
        }

        .control-slider {
            width: 100%;
            margin: 0.5rem 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            transition: background 0.3s ease;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4361ee, #7209b7);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(67, 97, 238, 0.3);
        }

        .control-button {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(135deg, #4361ee, #7209b7);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.5rem;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(67, 97, 238, 0.3);
        }

        .control-button:active {
            transform: translateY(0);
        }

        .control-button.secondary {
            background: linear-gradient(135deg, #6c757d, #495057);
        }

        .control-button.danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }

        .simulation-info {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            border: 1px solid #4361ee;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .simulation-info h4 {
            margin: 0 0 0.5rem 0;
            color: #4361ee;
            font-weight: 600;
        }

        .simulation-info p {
            margin: 0;
            font-size: 0.9rem;
            color: #333;
        }

        /* Enhanced physics objects */
        .physics-object {
            position: absolute;
            border-radius: 50%;
            transition: all 0.1s ease;
        }

        .projectile {
            width: 12px;
            height: 12px;
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff4444);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.6), 0 0 30px rgba(255, 68, 68, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .pendulum-bob {
            width: 24px;
            height: 24px;
            background: radial-gradient(circle at 30% 30%, #6c95ff, #4361ee);
            box-shadow: 0 0 20px rgba(67, 97, 238, 0.5), 0 0 40px rgba(67, 97, 238, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
        }

        .pendulum-string {
            position: absolute;
            background: linear-gradient(to bottom, #333, #666);
            transform-origin: top center;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .wave-particle {
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #9c27b0, #7209b7);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.6);
        }

        .electric-charge {
            border-radius: 50%;
            border: 3px solid;
            position: absolute;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .charge-positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff4444);
            border-color: #cc0000;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
        }

        .charge-negative {
            background: radial-gradient(circle at 30% 30%, #6b6bff, #4444ff);
            border-color: #0000cc;
            box-shadow: 0 0 20px rgba(68, 68, 255, 0.6);
        }

        .charge-positive:hover, .charge-negative:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(67, 97, 238, 0.8);
        }

        .ray-light {
            stroke: #ffeb3b;
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 0 8px #ffeb3b) drop-shadow(0 0 16px #ffc107);
        }

        .lens {
            fill: rgba(67, 97, 238, 0.2);
            stroke: #4361ee;
            stroke-width: 3;
            filter: drop-shadow(0 0 5px rgba(67, 97, 238, 0.3));
        }

        .mirror {
            stroke: #666;
            stroke-width: 5;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
        }

        /* Particle system effects */
        .particle-explosion {
            position: absolute;
            pointer-events: none;
        }

        .spark-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: radial-gradient(circle, #ffeb3b, #ff9800);
            border-radius: 50%;
            animation: sparkle 1s ease-out forwards;
        }

        @keyframes sparkle {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.3);
            }
        }

        /* Wave effects */
        .wave-ripple {
            position: absolute;
            border: 2px solid rgba(67, 97, 238, 0.6);
            border-radius: 50%;
            animation: ripple 2s ease-out infinite;
        }

        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* Field visualization */
        .field-line {
            stroke: rgba(67, 97, 238, 0.7);
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(67, 97, 238, 0.3));
        }

        .magnetic-field-line {
            stroke: rgba(255, 107, 53, 0.7);
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(255, 107, 53, 0.3));
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .simulation-workspace {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .simulation-controls {
                order: 2;
                max-height: 300px;
            }
            
            .simulation-display {
                height: 400px;
                order: 1;
            }
            
            .simulator-tabs {
                flex-wrap: wrap;
            }
            
            .simulator-tab {
                min-width: 120px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            .simulator-content {
                padding: 1rem;
            }
            
            .simulation-workspace {
                gap: 1rem;
            }
            
            .simulation-display {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <header class="main-header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <a href="../../index.html">
                        <i class="fas fa-graduation-cap" style="background: linear-gradient(90deg, #4361ee, #7209b7); -webkit-background-clip: text; background-clip: text; color: transparent;"></i>
                        <span>Alex的学习助手</span>
                    </a>
                </div>
                <nav class="main-nav">
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="main.html">物理</a></li>
                        <li><a href="../../index.html#subjects">科目</a></li>
                        <li><a href="../../tts.html">语音</a></li>
                        <li><a href="../../draw.html">绘图</a></li>
                    </ul>
                </nav>
                <button class="mobile-menu-toggle" aria-label="切换菜单">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
        </div>
    </header>

    <main class="simulator-page">
        <div class="container">
            <div class="simulator-container">
                <div class="simulator-header">
                    <h1><i class="fas fa-atom"></i> 物理模拟器</h1>
                    <p>通过交互式模拟探索物理世界的奥秘</p>
                </div>

                <div class="simulator-tabs">
                    <button class="simulator-tab active" data-tab="mechanics">
                        <i class="fas fa-cogs"></i> 力学
                    </button>
                    <button class="simulator-tab" data-tab="electromagnetism">
                        <i class="fas fa-bolt"></i> 电磁学
                    </button>
                    <button class="simulator-tab" data-tab="optics">
                        <i class="fas fa-glasses"></i> 光学
                    </button>
                    <button class="simulator-tab" data-tab="waves">
                        <i class="fas fa-water"></i> 波动
                    </button>
                    <button class="simulator-tab" data-tab="thermodynamics">
                        <i class="fas fa-temperature-high"></i> 热力学
                    </button>
                </div>

                <div class="simulator-content">
                    <!-- 力学模拟 -->
                    <div class="simulation-panel active" id="mechanics-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-cogs"></i> 力学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="mechanics-type">
                                        <option value="projectile">抛体运动</option>
                                        <option value="pendulum">单摆</option>
                                        <option value="collision">碰撞</option>
                                        <option value="spring">弹簧振动</option>
                                    </select>
                                </div>

                                <div id="projectile-controls">
                                    <div class="control-group">
                                        <label>初始速度 (m/s): <span id="velocity-value">20</span></label>
                                        <input type="range" class="control-slider" id="initial-velocity" min="5" max="50" value="20">
                                    </div>
                                    <div class="control-group">
                                        <label>发射角度 (°): <span id="angle-value">45</span></label>
                                        <input type="range" class="control-slider" id="launch-angle" min="0" max="90" value="45">
                                    </div>
                                    <div class="control-group">
                                        <label>重力加速度 (m/s²): <span id="gravity-value">9.8</span></label>
                                        <input type="range" class="control-slider" id="gravity" min="1" max="20" value="9.8" step="0.1">
                                    </div>
                                </div>

                                <div id="pendulum-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>摆长 (m): <span id="pendulum-length-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="pendulum-length" min="0.5" max="3" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>初始角度 (°): <span id="pendulum-angle-value">30</span></label>
                                        <input type="range" class="control-slider" id="pendulum-angle" min="5" max="60" value="30">
                                    </div>
                                </div>

                                <div id="collision-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>球1质量 (kg): <span id="mass1-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="mass1" min="0.5" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>球2质量 (kg): <span id="mass2-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="mass2" min="0.5" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>球1初速度 (m/s): <span id="velocity1-value">5</span></label>
                                        <input type="range" class="control-slider" id="velocity1" min="0" max="10" value="5" step="0.5">
                                    </div>
                                    <div class="control-group">
                                        <label>球2初速度 (m/s): <span id="velocity2-value">0</span></label>
                                        <input type="range" class="control-slider" id="velocity2" min="0" max="10" value="0" step="0.5">
                                    </div>
                                    <div class="control-group">
                                        <label>恢复系数: <span id="restitution-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="restitution" min="0" max="1" value="1.0" step="0.1">
                                    </div>
                                </div>

                                <div id="spring-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>弹簧常数 (N/m): <span id="spring-k-value">10</span></label>
                                        <input type="range" class="control-slider" id="spring-k" min="1" max="50" value="10">
                                    </div>
                                    <div class="control-group">
                                        <label>质量 (kg): <span id="spring-mass-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="spring-mass" min="0.1" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>初始位移 (m): <span id="spring-displacement-value">0.5</span></label>
                                        <input type="range" class="control-slider" id="spring-displacement" min="0.1" max="2" value="0.5" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>阻尼系数: <span id="damping-value">0.1</span></label>
                                        <input type="range" class="control-slider" id="damping" min="0" max="1" value="0.1" step="0.05">
                                    </div>
                                </div>

                                <button class="control-button" id="start-mechanics">开始模拟</button>
                                <button class="control-button secondary" id="reset-mechanics">重置</button>
                                <button class="control-button secondary" id="pause-mechanics">暂停</button>

                                <div class="simulation-info">
                                    <h4>实时数据</h4>
                                    <p id="mechanics-info">点击开始模拟查看实时数据</p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="mechanics-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 电磁学模拟 -->
                    <div class="simulation-panel" id="electromagnetism-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-bolt"></i> 电磁学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="em-type">
                                        <option value="electric-field">电场</option>
                                        <option value="magnetic-field">磁场</option>
                                        <option value="electromagnetic-induction">电磁感应</option>
                                        <option value="circuit">电路</option>
                                    </select>
                                </div>

                                <div id="electric-field-controls">
                                    <div class="control-group">
                                        <label>电荷数量: <span id="charge-count-value">2</span></label>
                                        <input type="range" class="control-slider" id="charge-count" min="1" max="5" value="2">
                                    </div>
                                    <div class="control-group">
                                        <label>电荷强度: <span id="charge-strength-value">1</span></label>
                                        <input type="range" class="control-slider" id="charge-strength" min="0.1" max="3" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>显示电场线</label>
                                        <input type="checkbox" id="show-field-lines" checked>
                                    </div>
                                </div>

                                <div id="magnetic-field-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>磁场强度 (T): <span id="magnetic-strength-value">0.1</span></label>
                                        <input type="range" class="control-slider" id="magnetic-strength" min="0.01" max="1" value="0.1" step="0.01">
                                    </div>
                                    <div class="control-group">
                                        <label>电流 (A): <span id="current-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="current" min="0.1" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>导线形状</label>
                                        <select class="control-input" id="wire-shape">
                                            <option value="straight">直导线</option>
                                            <option value="loop">圆形线圈</option>
                                            <option value="solenoid">螺线管</option>
                                        </select>
                                    </div>
                                </div>

                                <div id="induction-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>线圈匝数: <span id="coil-turns-value">10</span></label>
                                        <input type="range" class="control-slider" id="coil-turns" min="5" max="50" value="10">
                                    </div>
                                    <div class="control-group">
                                        <label>磁铁速度 (m/s): <span id="magnet-speed-value">2</span></label>
                                        <input type="range" class="control-slider" id="magnet-speed" min="0.5" max="10" value="2" step="0.5">
                                    </div>
                                    <div class="control-group">
                                        <label>磁铁强度: <span id="magnet-strength-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="magnet-strength" min="0.1" max="3" value="1.0" step="0.1">
                                    </div>
                                </div>

                                <div id="circuit-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>电压 (V): <span id="voltage-value">12</span></label>
                                        <input type="range" class="control-slider" id="voltage" min="1" max="24" value="12">
                                    </div>
                                    <div class="control-group">
                                        <label>电阻 (Ω): <span id="resistance-value">10</span></label>
                                        <input type="range" class="control-slider" id="resistance" min="1" max="100" value="10">
                                    </div>
                                    <div class="control-group">
                                        <label>电路类型</label>
                                        <select class="control-input" id="circuit-type">
                                            <option value="series">串联电路</option>
                                            <option value="parallel">并联电路</option>
                                            <option value="rc">RC电路</option>
                                        </select>
                                    </div>
                                </div>

                                <button class="control-button" id="start-em">开始模拟</button>
                                <button class="control-button secondary" id="reset-em">重置</button>
                                <button class="control-button secondary" id="add-charge">添加电荷</button>

                                <div class="simulation-info">
                                    <h4>电磁学原理</h4>
                                    <p id="em-info">点击画布添加电荷，观察电场分布</p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="em-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 光学模拟 -->
                    <div class="simulation-panel" id="optics-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-glasses"></i> 光学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="optics-type">
                                        <option value="reflection">反射</option>
                                        <option value="refraction">折射</option>
                                        <option value="lens">透镜</option>
                                        <option value="interference">干涉</option>
                                    </select>
                                </div>

                                <div id="reflection-controls">
                                    <div class="control-group">
                                        <label>入射角 (°): <span id="incident-angle-value">30</span></label>
                                        <input type="range" class="control-slider" id="incident-angle" min="0" max="80" value="30">
                                    </div>
                                    <div class="control-group">
                                        <label>镜面类型</label>
                                        <select class="control-input" id="mirror-type">
                                            <option value="plane">平面镜</option>
                                            <option value="concave">凹面镜</option>
                                            <option value="convex">凸面镜</option>
                                        </select>
                                    </div>
                                </div>

                                <div id="refraction-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>折射率1: <span id="n1-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="refractive-index-1" min="1.0" max="2.5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>折射率2: <span id="n2-value">1.5</span></label>
                                        <input type="range" class="control-slider" id="refractive-index-2" min="1.0" max="2.5" value="1.5" step="0.1">
                                    </div>
                                </div>

                                <div id="lens-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>焦距 (cm): <span id="focal-length-value">20</span></label>
                                        <input type="range" class="control-slider" id="focal-length" min="5" max="50" value="20">
                                    </div>
                                    <div class="control-group">
                                        <label>物距 (cm): <span id="object-distance-value">30</span></label>
                                        <input type="range" class="control-slider" id="object-distance" min="10" max="100" value="30">
                                    </div>
                                    <div class="control-group">
                                        <label>透镜类型</label>
                                        <select class="control-input" id="lens-type">
                                            <option value="convex">凸透镜</option>
                                            <option value="concave">凹透镜</option>
                                        </select>
                                    </div>
                                </div>

                                <div id="interference-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>波长 (nm): <span id="wavelength-value">550</span></label>
                                        <input type="range" class="control-slider" id="light-wavelength" min="400" max="700" value="550">
                                    </div>
                                    <div class="control-group">
                                        <label>缝间距 (μm): <span id="slit-spacing-value">100</span></label>
                                        <input type="range" class="control-slider" id="slit-spacing" min="50" max="500" value="100">
                                    </div>
                                    <div class="control-group">
                                        <label>屏幕距离 (m): <span id="screen-distance-value">2</span></label>
                                        <input type="range" class="control-slider" id="screen-distance" min="0.5" max="5" value="2" step="0.1">
                                    </div>
                                </div>

                                <button class="control-button" id="start-optics">开始模拟</button>
                                <button class="control-button secondary" id="reset-optics">重置</button>

                                <div class="simulation-info">
                                    <h4>光学定律</h4>
                                    <p id="optics-info">调整参数观察光线传播规律</p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="optics-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 波动模拟 -->
                    <div class="simulation-panel" id="waves-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-water"></i> 波动模拟</h3>
                                
                                <div class="control-group">
                                    <label>波动类型</label>
                                    <select class="control-input" id="wave-type">
                                        <option value="transverse">横波</option>
                                        <option value="longitudinal">纵波</option>
                                        <option value="standing">驻波</option>
                                        <option value="interference">波的干涉</option>
                                    </select>
                                </div>

                                <div class="control-group">
                                    <label>频率 (Hz): <span id="frequency-value">1.0</span></label>
                                    <input type="range" class="control-slider" id="wave-frequency" min="0.1" max="5" value="1.0" step="0.1">
                                </div>

                                <div class="control-group">
                                    <label>振幅: <span id="amplitude-value">50</span></label>
                                    <input type="range" class="control-slider" id="wave-amplitude" min="10" max="100" value="50">
                                </div>

                                <div class="control-group">
                                    <label>波速 (m/s): <span id="wave-speed-value">100</span></label>
                                    <input type="range" class="control-slider" id="wave-speed" min="50" max="200" value="100">
                                </div>

                                <button class="control-button" id="start-waves">开始模拟</button>
                                <button class="control-button secondary" id="reset-waves">重置</button>
                                <button class="control-button secondary" id="pause-waves">暂停</button>

                                <div class="simulation-info">
                                    <h4>波动参数</h4>
                                    <p id="waves-info">波长: <span id="wavelength">100m</span><br>周期: <span id="period">1.0s</span></p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="waves-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 热力学模拟 -->
                    <div class="simulation-panel" id="thermodynamics-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-temperature-high"></i> 热力学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="thermo-type">
                                        <option value="gas-particles">气体分子运动</option>
                                        <option value="heat-conduction">热传导</option>
                                        <option value="phase-transition">相变</option>
                                        <option value="carnot-cycle">卡诺循环</option>
                                    </select>
                                </div>

                                <div id="gas-controls">
                                    <div class="control-group">
                                        <label>温度 (K): <span id="temperature-value">300</span></label>
                                        <input type="range" class="control-slider" id="temperature" min="100" max="800" value="300">
                                    </div>
                                    <div class="control-group">
                                        <label>压强 (atm): <span id="pressure-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="pressure" min="0.1" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>分子数量: <span id="molecule-count-value">100</span></label>
                                        <input type="range" class="control-slider" id="molecule-count" min="50" max="300" value="100">
                                    </div>
                                </div>

                                <div id="heat-conduction-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>热源温度 (K): <span id="heat-source-temp-value">400</span></label>
                                        <input type="range" class="control-slider" id="heat-source-temp" min="300" max="800" value="400">
                                    </div>
                                    <div class="control-group">
                                        <label>冷源温度 (K): <span id="cold-source-temp-value">200</span></label>
                                        <input type="range" class="control-slider" id="cold-source-temp" min="100" max="300" value="200">
                                    </div>
                                    <div class="control-group">
                                        <label>导热系数: <span id="thermal-conductivity-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="thermal-conductivity" min="0.1" max="5" value="1.0" step="0.1">
                                    </div>
                                </div>

                                <div id="phase-transition-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>初始温度 (K): <span id="initial-temp-value">250</span></label>
                                        <input type="range" class="control-slider" id="initial-temp" min="200" max="400" value="250">
                                    </div>
                                    <div class="control-group">
                                        <label>加热功率 (W): <span id="heating-power-value">100</span></label>
                                        <input type="range" class="control-slider" id="heating-power" min="50" max="500" value="100">
                                    </div>
                                    <div class="control-group">
                                        <label>物质类型</label>
                                        <select class="control-input" id="substance-type">
                                            <option value="water">水</option>
                                            <option value="ice">冰</option>
                                            <option value="alcohol">酒精</option>
                                        </select>
                                    </div>
                                </div>

                                <div id="carnot-cycle-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>高温热源 (K): <span id="hot-reservoir-value">400</span></label>
                                        <input type="range" class="control-slider" id="hot-reservoir" min="350" max="600" value="400">
                                    </div>
                                    <div class="control-group">
                                        <label>低温热源 (K): <span id="cold-reservoir-value">300</span></label>
                                        <input type="range" class="control-slider" id="cold-reservoir" min="200" max="350" value="300">
                                    </div>
                                    <div class="control-group">
                                        <label>工作气体体积 (L): <span id="gas-volume-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="gas-volume" min="0.5" max="3" value="1.0" step="0.1">
                                    </div>
                                </div>

                                <button class="control-button" id="start-thermo">开始模拟</button>
                                <button class="control-button secondary" id="reset-thermo">重置</button>
                                <button class="control-button secondary" id="pause-thermo">暂停</button>

                                <div class="simulation-info">
                                    <h4>热力学数据</h4>
                                    <p id="thermo-info">平均动能: <span id="avg-kinetic">--</span><br>体积: <span id="volume">--</span></p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="thermo-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="main-footer">
        <div class="container">
            <div class="footer-content">
                <p class="copyright-text">study-llm.me域名为Alex所有。保留所有权利。</p>
            </div>
        </div>
    </footer>

    <script src="../../js/common.js"></script>
    <script src="../../js/navigation.js"></script>
    <script>
        // 物理模拟器主要功能
        class PhysicsSimulator {
            constructor() {
                this.currentTab = 'mechanics';
                this.animations = {};
                this.isRunning = {
                    mechanics: false,
                    em: false,
                    optics: false,
                    waves: false,
                    thermo: false
                };
                this.initializeCanvases();
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // 标签切换
                document.querySelectorAll('.simulator-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchTab(e.target.dataset.tab);
                    });
                });

                // 力学控制
                this.setupMechanicsControls();
                this.setupElectromagnetismControls();
                this.setupOpticsControls();
                this.setupWavesControls();
                this.setupThermodynamicsControls();
            }

            initializeCanvases() {
                this.canvases = {
                    mechanics: document.getElementById('mechanics-canvas'),
                    em: document.getElementById('em-canvas'),
                    optics: document.getElementById('optics-canvas'),
                    waves: document.getElementById('waves-canvas'),
                    thermo: document.getElementById('thermo-canvas')
                };

                this.contexts = {};
                Object.keys(this.canvases).forEach(key => {
                    this.contexts[key] = this.canvases[key].getContext('2d');
                });
            }

            switchTab(tabName) {
                // 停止当前动画
                if (this.animations[this.currentTab]) {
                    cancelAnimationFrame(this.animations[this.currentTab]);
                }

                // 更新标签状态
                document.querySelectorAll('.simulator-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

                // 更新面板显示
                document.querySelectorAll('.simulation-panel').forEach(panel => {
                    panel.classList.remove('active');
                });
                document.getElementById(`${tabName}-panel`).classList.add('active');

                this.currentTab = tabName;
            }

            setupMechanicsControls() {
                const typeSelect = document.getElementById('mechanics-type');
                const startBtn = document.getElementById('start-mechanics');
                const resetBtn = document.getElementById('reset-mechanics');
                const pauseBtn = document.getElementById('pause-mechanics');

                // 类型切换
                if (typeSelect) {
                    typeSelect.addEventListener('change', (e) => {
                        this.switchMechanicsType(e.target.value);
                    });
                }

                // 滑块更新
                if (document.getElementById('initial-velocity')) {
                    document.getElementById('initial-velocity').addEventListener('input', (e) => {
                        document.getElementById('velocity-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('launch-angle')) {
                    document.getElementById('launch-angle').addEventListener('input', (e) => {
                        document.getElementById('angle-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('gravity')) {
                    document.getElementById('gravity').addEventListener('input', (e) => {
                        document.getElementById('gravity-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('pendulum-length')) {
                    document.getElementById('pendulum-length').addEventListener('input', (e) => {
                        document.getElementById('pendulum-length-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('pendulum-angle')) {
                    document.getElementById('pendulum-angle').addEventListener('input', (e) => {
                        document.getElementById('pendulum-angle-value').textContent = e.target.value;
                    });
                }

                // 碰撞控制
                if (document.getElementById('mass1')) {
                    document.getElementById('mass1').addEventListener('input', (e) => {
                        document.getElementById('mass1-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('mass2')) {
                    document.getElementById('mass2').addEventListener('input', (e) => {
                        document.getElementById('mass2-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('velocity1')) {
                    document.getElementById('velocity1').addEventListener('input', (e) => {
                        document.getElementById('velocity1-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('velocity2')) {
                    document.getElementById('velocity2').addEventListener('input', (e) => {
                        document.getElementById('velocity2-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('restitution')) {
                    document.getElementById('restitution').addEventListener('input', (e) => {
                        document.getElementById('restitution-value').textContent = e.target.value;
                    });
                }

                // 弹簧控制
                if (document.getElementById('spring-k')) {
                    document.getElementById('spring-k').addEventListener('input', (e) => {
                        document.getElementById('spring-k-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('spring-mass')) {
                    document.getElementById('spring-mass').addEventListener('input', (e) => {
                        document.getElementById('spring-mass-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('spring-displacement')) {
                    document.getElementById('spring-displacement').addEventListener('input', (e) => {
                        document.getElementById('spring-displacement-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('damping')) {
                    document.getElementById('damping').addEventListener('input', (e) => {
                        document.getElementById('damping-value').textContent = e.target.value;
                    });
                }

                // 按钮控制
                if (startBtn) startBtn.addEventListener('click', () => this.startMechanicsSimulation());
                if (resetBtn) resetBtn.addEventListener('click', () => this.resetMechanicsSimulation());
                if (pauseBtn) pauseBtn.addEventListener('click', () => this.pauseMechanicsSimulation());
            }

            switchMechanicsType(type) {
                document.getElementById('projectile-controls').style.display = 
                    type === 'projectile' ? 'block' : 'none';
                document.getElementById('pendulum-controls').style.display = 
                    type === 'pendulum' ? 'block' : 'none';
                document.getElementById('collision-controls').style.display = 
                    type === 'collision' ? 'block' : 'none';
                document.getElementById('spring-controls').style.display = 
                    type === 'spring' ? 'block' : 'none';
            }

            startMechanicsSimulation() {
                const type = document.getElementById('mechanics-type').value;
                this.isRunning.mechanics = true;

                if (type === 'projectile') {
                    this.simulateProjectileMotion();
                } else if (type === 'pendulum') {
                    this.simulatePendulum();
                } else if (type === 'collision') {
                    this.simulateCollision();
                } else if (type === 'spring') {
                    this.simulateSpring();
                }
            }

            simulateProjectileMotion() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const velocity = parseFloat(document.getElementById('initial-velocity').value);
                const angle = parseFloat(document.getElementById('launch-angle').value) * Math.PI / 180;
                const gravity = parseFloat(document.getElementById('gravity').value);

                const vx = velocity * Math.cos(angle);
                const vy = velocity * Math.sin(angle);

                let t = 0;
                const dt = 0.02;
                const scale = 8; // 像素/米
                
                // 空气阻力系数 (可调节)
                const airResistance = 0.01;
                const mass = 1; // kg

                // 存储轨迹点用于绘制完整轨迹
                const trajectoryPoints = [];
                let currentVx = vx;
                let currentVy = vy;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制坐标系和网格
                    this.drawCoordinateSystem(ctx, canvas, scale);

                    // 计算当前位置 (考虑空气阻力)
                    const x = 50 + t * currentVx * scale;
                    const y = canvas.height - 80 - (currentVy * t - 0.5 * gravity * t * t) * scale;

                    // 空气阻力计算
                    const speed = Math.sqrt(currentVx * currentVx + currentVy * currentVy);
                    const dragForceX = -airResistance * speed * currentVx;
                    const dragForceY = -airResistance * speed * currentVy;
                    
                    // 更新速度（考虑重力和空气阻力）
                    currentVx += (dragForceX / mass) * dt;
                    currentVy += (-gravity + dragForceY / mass) * dt;

                    // 存储轨迹点
                    if (t % 0.1 < dt) { // 每0.1秒记录一个点
                        trajectoryPoints.push({x: x, y: y, t: t});
                    }

                    // 绘制完整轨迹
                    this.drawTrajectory(ctx, trajectoryPoints);

                    // 绘制理论轨迹（无空气阻力）
                    this.drawTheoreticalTrajectory(ctx, canvas, vx, vy, gravity, scale);

                    if (y <= canvas.height - 80 && x < canvas.width - 50) {
                        // 绘制抛体（增强效果）
                        this.drawProjectile(ctx, x, y, currentVx, currentVy);

                        // 绘制速度分解
                        this.drawVelocityComponents(ctx, x, y, currentVx, currentVy);

                        // 绘制轨迹切线和法线
                        this.drawTangentAndNormal(ctx, x, y, currentVx, currentVy);

                        // 实时物理数据分析
                        const height = Math.max(0, (canvas.height - 80 - y) / scale);
                        const distance = (x - 50) / scale;
                        const totalSpeed = Math.sqrt(currentVx * currentVx + currentVy * currentVy);
                        const kineticEnergy = 0.5 * mass * totalSpeed * totalSpeed;
                        const potentialEnergy = mass * gravity * height;
                        const totalEnergy = kineticEnergy + potentialEnergy;
                        
                        // 计算理论值对比
                        const theoreticalRange = (vx * vx * Math.sin(2 * angle)) / gravity;
                        const maxHeight = (vy * vy) / (2 * gravity);

                        document.getElementById('mechanics-info').innerHTML = `
                            <strong>实时飞行数据:</strong><br>
                            时间: ${t.toFixed(2)}s<br>
                            位置: (${distance.toFixed(1)}m, ${height.toFixed(1)}m)<br>
                            速度: ${totalSpeed.toFixed(2)}m/s<br>
                            水平速度: ${currentVx.toFixed(2)}m/s<br>
                            垂直速度: ${currentVy.toFixed(2)}m/s<br>
                            <strong>能量分析:</strong><br>
                            动能: ${kineticEnergy.toFixed(2)}J<br>
                            势能: ${potentialEnergy.toFixed(2)}J<br>
                            总能量: ${totalEnergy.toFixed(2)}J<br>
                            <strong>理论对比:</strong><br>
                            理论射程: ${theoreticalRange.toFixed(1)}m<br>
                            最大高度: ${maxHeight.toFixed(1)}m<br>
                            空气阻力效应: ${((1 - distance/theoreticalRange)*100).toFixed(1)}%
                        `;

                        t += dt;
                        this.animations.mechanics = requestAnimationFrame(animate);
                    } else {
                        // 着陆分析
                        const finalDistance = (x - 50) / scale;
                        const flightTime = t;
                        this.isRunning.mechanics = false;
                        
                        document.getElementById('mechanics-info').innerHTML += `<br><strong style="color: #ff4444;">着陆分析:</strong><br>
                            实际射程: ${finalDistance.toFixed(1)}m<br>
                            飞行时间: ${flightTime.toFixed(2)}s<br>
                            着陆速度: ${Math.sqrt(currentVx*currentVx + currentVy*currentVy).toFixed(2)}m/s`;
                    }
                };

                animate();
            }

            drawCoordinateSystem(ctx, canvas, scale) {
                // 绘制网格
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                // 垂直网格线（每10米）
                for (let x = 50; x < canvas.width - 50; x += 10 * scale) {
                    ctx.beginPath();
                    ctx.moveTo(x, 50);
                    ctx.lineTo(x, canvas.height - 80);
                    ctx.stroke();
                }
                
                // 水平网格线（每5米）
                for (let y = canvas.height - 80; y > 50; y -= 5 * scale) {
                    ctx.beginPath();
                    ctx.moveTo(50, y);
                    ctx.lineTo(canvas.width - 50, y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // 绘制坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // X轴
                ctx.moveTo(50, canvas.height - 80);
                ctx.lineTo(canvas.width - 50, canvas.height - 80);
                // Y轴
                ctx.moveTo(50, canvas.height - 80);
                ctx.lineTo(50, 50);
                ctx.stroke();

                // 坐标轴标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i <= 100; i += 20) {
                    const x = 50 + i * scale;
                    if (x < canvas.width - 50) {
                        ctx.fillText(`${i}m`, x, canvas.height - 60);
                    }
                }
                
                ctx.textAlign = 'right';
                for (let i = 0; i <= 50; i += 10) {
                    const y = canvas.height - 80 - i * scale;
                    if (y > 50) {
                        ctx.fillText(`${i}m`, 45, y + 3);
                    }
                }
            }

            drawTrajectory(ctx, points) {
                if (points.length < 2) return;
                
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                
                points.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();

                // 绘制时间标记点
                ctx.fillStyle = '#4361ee';
                points.forEach((point, index) => {
                    if (index % 5 === 0) { // 每0.5秒标记一次
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.fillStyle = '#666';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${point.t.toFixed(1)}s`, point.x, point.y - 8);
                        ctx.fillStyle = '#4361ee';
                    }
                });
            }

            drawTheoreticalTrajectory(ctx, canvas, vx, vy, gravity, scale) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                const maxTime = (2 * vy) / gravity;
                for (let t = 0; t <= maxTime; t += 0.1) {
                    const x = 50 + vx * t * scale;
                    const y = canvas.height - 80 - (vy * t - 0.5 * gravity * t * t) * scale;
                    
                    if (t === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            drawProjectile(ctx, x, y, vx, vy) {
                // 主体抛体
                const gradient = ctx.createRadialGradient(x - 4, y - 4, 0, x, y, 10);
                gradient.addColorStop(0, '#ff8888');
                gradient.addColorStop(1, '#ff4444');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
                
                // 运动轨迹效果
                const speed = Math.sqrt(vx * vx + vy * vy);
                ctx.fillStyle = `rgba(255, 68, 68, ${Math.min(0.5, speed * 0.02)})`;
                ctx.beginPath();
                ctx.arc(x - vx * 0.5, y + vy * 0.5, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#cc0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.stroke();
            }

            drawVelocityComponents(ctx, x, y, vx, vy) {
                const scale = 5;
                
                // 总速度矢量
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + vx * scale, y - vy * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, x + vx * scale, y - vy * scale, Math.atan2(-vy, vx), '#ff6b35');
                
                // 水平分量
                ctx.strokeStyle = '#35ff6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + vx * scale, y);
                ctx.stroke();
                this.drawArrowHead(ctx, x + vx * scale, y, 0, '#35ff6b');
                
                // 垂直分量
                ctx.strokeStyle = '#6b35ff';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y - vy * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, x, y - vy * scale, -Math.PI/2, '#6b35ff');
                ctx.setLineDash([]);
                
                // 速度标签
                ctx.fillStyle = '#333';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`v=${Math.sqrt(vx*vx+vy*vy).toFixed(1)}`, x + vx * scale + 5, y - vy * scale - 5);
                ctx.fillText(`vₓ=${vx.toFixed(1)}`, x + vx * scale + 5, y + 12);
                ctx.fillText(`vᵧ=${vy.toFixed(1)}`, x - 40, y - vy * scale);
            }

            drawArrowHead(ctx, x, y, angle, color) {
                ctx.fillStyle = color;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-8, -3);
                ctx.lineTo(-8, 3);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            drawTangentAndNormal(ctx, x, y, vx, vy) {
                if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) return;
                
                const speed = Math.sqrt(vx * vx + vy * vy);
                const unitX = vx / speed;
                const unitY = vy / speed;
                
                // 切线方向
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([2, 4]);
                ctx.beginPath();
                ctx.moveTo(x - unitX * 30, y + unitY * 30);
                ctx.lineTo(x + unitX * 30, y - unitY * 30);
                ctx.stroke();
                
                // 法线方向（垂直于切线）
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.moveTo(x - unitY * 20, y - unitX * 20);
                ctx.lineTo(x + unitY * 20, y + unitX * 20);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            simulatePendulum() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const length = parseFloat(document.getElementById('pendulum-length').value);
                const initialAngle = parseFloat(document.getElementById('pendulum-angle').value) * Math.PI / 180;
                const gravity = 9.8;
                
                let angle = initialAngle;
                let angularVelocity = 0;
                const dt = 0.01;
                const scale = 200; // 像素/米
                const damping = 0.995; // 阻尼系数
                
                const centerX = canvas.width / 2;
                const centerY = 100;
                
                // 用于绘制相位图的数据
                const phaseData = [];
                const energyData = [];
                let time = 0;
                
                // 理论周期计算
                const theoreticalPeriod = 2 * Math.PI * Math.sqrt(length / gravity);
                const theoreticalFrequency = 1 / theoreticalPeriod;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制背景网格和坐标系
                    this.drawPendulumBackground(ctx, canvas, centerX, centerY, length, scale);

                    // 计算摆球位置
                    const bobX = centerX + length * scale * Math.sin(angle);
                    const bobY = centerY + length * scale * Math.cos(angle);

                    // 绘制摆线
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(bobX, bobY);
                    ctx.stroke();

                    // 绘制固定点
                    ctx.fillStyle = '#666';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // 绘制摆球（增强效果）
                    this.drawPendulumBob(ctx, bobX, bobY, angularVelocity);

                    // 绘制运动轨迹
                    this.drawPendulumTrajectory(ctx, centerX, centerY, length * scale, angle);

                    // 绘制力的分析
                    this.drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity);

                    // 绘制速度矢量
                    this.drawAngularVelocity(ctx, canvas, bobX, bobY, angularVelocity, length);

                    // 绘制相位图
                    this.drawPhasePortrait(ctx, canvas, phaseData);

                    // 绘制能量图表
                    this.drawEnergyPlot(ctx, canvas, energyData, time);

                    // 物理计算（非线性单摆方程）
                    const angularAcceleration = -(gravity / length) * Math.sin(angle);
                    angularVelocity += angularAcceleration * dt;
                    angularVelocity *= damping; // 应用阻尼
                    angle += angularVelocity * dt;

                    // 记录相位数据
                    if (time % 0.1 < dt) {
                        phaseData.push({angle: angle, velocity: angularVelocity});
                        if (phaseData.length > 200) phaseData.shift();
                        
                        // 能量计算
                        const kineticEnergy = 0.5 * length * length * angularVelocity * angularVelocity;
                        const potentialEnergy = gravity * length * (1 - Math.cos(angle));
                        const totalEnergy = kineticEnergy + potentialEnergy;
                        
                        energyData.push({
                            time: time,
                            ke: kineticEnergy,
                            pe: potentialEnergy,
                            total: totalEnergy
                        });
                        if (energyData.length > 300) energyData.shift();
                    }

                    // 计算实际周期（通过零点检测）
                    const currentPeriod = this.calculatePeriod(angle, angularVelocity, time);
                    const actualFrequency = currentPeriod > 0 ? 1 / currentPeriod : 0;

                    // 更新信息
                    const ke = 0.5 * length * length * angularVelocity * angularVelocity;
                    const pe = gravity * length * (1 - Math.cos(angle));
                    const totalEnergy = ke + pe;
                    const maxAngle = Math.acos(1 - totalEnergy / (gravity * length));
                    
                    document.getElementById('mechanics-info').innerHTML = `
                        <strong>单摆运动分析:</strong><br>
                        时间: ${time.toFixed(2)}s<br>
                        角度: ${(angle * 180 / Math.PI).toFixed(2)}°<br>
                        角速度: ${angularVelocity.toFixed(3)} rad/s<br>
                        角加速度: ${(-(gravity/length)*Math.sin(angle)).toFixed(3)} rad/s²<br>
                        <strong>能量分析:</strong><br>
                        动能: ${ke.toFixed(4)}J<br>
                        势能: ${pe.toFixed(4)}J<br>
                        总能量: ${totalEnergy.toFixed(4)}J<br>
                        最大角度: ±${(maxAngle * 180 / Math.PI).toFixed(1)}°<br>
                        <strong>周期分析:</strong><br>
                        理论周期: ${theoreticalPeriod.toFixed(3)}s<br>
                        实际周期: ${currentPeriod.toFixed(3)}s<br>
                        频率: ${actualFrequency.toFixed(3)}Hz<br>
                        阻尼比: ${((1 - damping) * 1000).toFixed(1)}‰
                    `;

                    time += dt;
                    this.animations.mechanics = requestAnimationFrame(animate);
                };

                animate();
            }

            drawPendulumBackground(ctx, canvas, centerX, centerY, length, scale) {
                // 绘制摆动范围圆弧
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, length * scale, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 绘制垂直参考线
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX, centerY + length * scale + 20);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 绘制角度标记
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.6)';
                ctx.lineWidth = 1;
                for (let i = -60; i <= 60; i += 15) {
                    const angleRad = i * Math.PI / 180;
                    const x1 = centerX + (length * scale - 10) * Math.sin(angleRad);
                    const y1 = centerY + (length * scale - 10) * Math.cos(angleRad);
                    const x2 = centerX + (length * scale + 10) * Math.sin(angleRad);
                    const y2 = centerY + (length * scale + 10) * Math.cos(angleRad);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    
                    // 角度标签
                    if (i % 30 === 0 && i !== 0) {
                        ctx.fillStyle = '#666';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${i}°`, x2, y2 - 5);
                    }
                }
            }

            drawPendulumBob(ctx, x, y, angularVelocity) {
                // 主体摆球
                const radius = 20;
                const gradient = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, radius);
                gradient.addColorStop(0, '#88ccff');
                gradient.addColorStop(1, '#4361ee');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // 运动轨迹效果
                const speed = Math.abs(angularVelocity);
                ctx.fillStyle = `rgba(67, 97, 238, ${Math.min(0.3, speed * 0.1)})`;
                ctx.beginPath();
                ctx.arc(x - angularVelocity * 10, y, radius * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#2c5aa0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x - 6, y - 6, 6, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawPendulumTrajectory(ctx, centerX, centerY, radius, currentAngle) {
                // 绘制摆动轨迹弧线
                ctx.strokeStyle = 'rgba(67, 97, 238, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, -Math.PI/3, Math.PI/3);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 高亮当前位置
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, currentAngle - 0.05, currentAngle + 0.05);
                ctx.stroke();
            }

            drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity) {
                const scale = 20;
                const mg = gravity; // 简化显示
                
                // 重力 (向下)
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX, bobY + mg * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX, bobY + mg * scale, Math.PI/2, '#ff4444');
                
                // 重力的切向分量
                const tangentialForce = mg * Math.sin(angle);
                const tangentX = bobX - tangentialForce * scale * Math.cos(angle);
                const tangentY = bobY - tangentialForce * scale * Math.sin(angle);
                
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(tangentX, tangentY);
                ctx.stroke();
                this.drawArrowHead(ctx, tangentX, tangentY, angle - Math.PI/2, '#ff8800');
                
                // 重力的径向分量
                const radialForce = mg * Math.cos(angle);
                const radialX = bobX - radialForce * scale * Math.sin(angle);
                const radialY = bobY - radialForce * scale * Math.cos(angle);
                
                ctx.strokeStyle = '#8844ff';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(radialX, radialY);
                ctx.stroke();
                this.drawArrowHead(ctx, radialX, radialY, angle + Math.PI, '#8844ff');
                ctx.setLineDash([]);
                
                // 力的标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('mg', bobX + 5, bobY + mg * scale);
                ctx.fillText('mg sin θ', tangentX + 5, tangentY);
                ctx.fillText('mg cos θ', radialX + 5, radialY);
            }

            drawAngularVelocity(ctx, canvas, bobX, bobY, angularVelocity, length) {
                if (Math.abs(angularVelocity) < 0.01) return;
                
                const scale = 100;
                const velocityMagnitude = Math.abs(angularVelocity) * length * scale;
                const direction = angularVelocity > 0 ? 1 : -1;
                
                // 切向速度矢量
                const vx = bobX + velocityMagnitude * direction * Math.cos(Math.atan2(bobY - 100, bobX - canvas.width/2) + Math.PI/2);
                const vy = bobY + velocityMagnitude * direction * Math.sin(Math.atan2(bobY - 100, bobX - canvas.width/2) + Math.PI/2);
                
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(vx, vy);
                ctx.stroke();
                
                const angle = Math.atan2(vy - bobY, vx - bobX);
                this.drawArrowHead(ctx, vx, vy, angle, '#00ff88');
                
                // 速度标签
                ctx.fillStyle = '#00aa66';
                ctx.font = 'bold 10px Arial';
                ctx.fillText(`v=${Math.abs(angularVelocity * length).toFixed(2)}m/s`, vx + 5, vy);
            }

            drawPhasePortrait(ctx, canvas, phaseData) {
                if (phaseData.length < 2) return;
                
                const plotX = canvas.width - 200;
                const plotY = 50;
                const plotWidth = 140;
                const plotHeight = 140;
                
                // 绘制相位图背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 坐标轴
                ctx.beginPath();
                ctx.moveTo(plotX + plotWidth/2, plotY);
                ctx.lineTo(plotX + plotWidth/2, plotY + plotHeight);
                ctx.moveTo(plotX, plotY + plotHeight/2);
                ctx.lineTo(plotX + plotWidth, plotY + plotHeight/2);
                ctx.stroke();
                
                // 绘制相位轨迹
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                phaseData.forEach((point, index) => {
                    const x = plotX + plotWidth/2 + (point.angle / Math.PI) * plotWidth * 0.4;
                    const y = plotY + plotHeight/2 - point.velocity * plotHeight * 0.1;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('相位图', plotX + plotWidth/2, plotY - 5);
                ctx.fillText('θ', plotX + plotWidth + 5, plotY + plotHeight/2);
                ctx.save();
                ctx.translate(plotX - 10, plotY + plotHeight/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('ω', 0, 0);
                ctx.restore();
            }

            drawEnergyPlot(ctx, canvas, energyData, currentTime) {
                if (energyData.length < 2) return;
                
                const plotX = 50;
                const plotY = canvas.height - 150;
                const plotWidth = 300;
                const plotHeight = 100;
                
                // 绘制能量图背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 找出最大能量用于归一化
                const maxEnergy = Math.max(...energyData.map(d => d.total));
                
                // 绘制能量曲线
                const colors = {ke: '#ff6b35', pe: '#4361ee', total: '#333'};
                const labels = {ke: '动能', pe: '势能', total: '总能量'};
                
                Object.keys(colors).forEach(energyType => {
                    ctx.strokeStyle = colors[energyType];
                    ctx.lineWidth = energyType === 'total' ? 3 : 2;
                    ctx.setLineDash(energyType === 'total' ? [5, 5] : []);
                    ctx.beginPath();
                    
                    energyData.forEach((point, index) => {
                        const x = plotX + (index / energyData.length) * plotWidth;
                        const y = plotY + plotHeight - (point[energyType] / maxEnergy) * plotHeight;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                });
                ctx.setLineDash([]);
                
                // 图例
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                Object.keys(colors).forEach((energyType, index) => {
                    ctx.fillStyle = colors[energyType];
                    ctx.fillRect(plotX + 10, plotY + 10 + index * 15, 10, 2);
                    ctx.fillStyle = '#333';
                    ctx.fillText(labels[energyType], plotX + 25, plotY + 15 + index * 15);
                });
                
                ctx.textAlign = 'center';
                ctx.fillText('能量-时间图', plotX + plotWidth/2, plotY - 5);
            }

            calculatePeriod(angle, angularVelocity, time) {
                // 简化的周期计算：检测角度零点
                if (!this.lastZeroCrossing) this.lastZeroCrossing = 0;
                if (!this.zeroCrossings) this.zeroCrossings = [];
                
                if (Math.abs(angle) < 0.01 && angularVelocity > 0) {
                    if (time - this.lastZeroCrossing > 1) { // 避免噪音
                        this.zeroCrossings.push(time);
                        this.lastZeroCrossing = time;
                        
                        if (this.zeroCrossings.length >= 3) {
                            const period = 2 * (this.zeroCrossings[this.zeroCrossings.length - 1] - 
                                            this.zeroCrossings[this.zeroCrossings.length - 3]);
                            return period;
                        }
                    }
                }
                
                return 0;
            }

            resetMechanicsSimulation() {
                this.isRunning.mechanics = false;
                if (this.animations.mechanics) {
                    cancelAnimationFrame(this.animations.mechanics);
                }
                this.contexts.mechanics.clearRect(0, 0, this.canvases.mechanics.width, this.canvases.mechanics.height);
                document.getElementById('mechanics-info').textContent = '点击开始模拟查看实时数据';
            }

            pauseMechanicsSimulation() {
                this.isRunning.mechanics = !this.isRunning.mechanics;
                if (this.isRunning.mechanics) {
                    const type = document.getElementById('mechanics-type').value;
                    if (type === 'projectile') {
                        this.simulateProjectileMotion();
                    } else if (type === 'pendulum') {
                        this.simulatePendulum();
                    } else if (type === 'collision') {
                        this.simulateCollision();
                    } else if (type === 'spring') {
                        this.simulateSpring();
                    }
                }
            }

            simulateCollision() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const m1 = parseFloat(document.getElementById('mass1').value);
                const m2 = parseFloat(document.getElementById('mass2').value);
                let v1 = parseFloat(document.getElementById('velocity1').value);
                let v2 = parseFloat(document.getElementById('velocity2').value);
                const e = parseFloat(document.getElementById('restitution').value);

                // 初始化多个碰撞球体
                const balls = [
                    {
                        id: 1,
                        x: 150,
                        y: canvas.height / 2,
                        vx: v1,
                        vy: 0,
                        mass: m1,
                        radius: Math.max(15, Math.min(35, m1 * 12)),
                        color: '#ff4444',
                        trail: []
                    },
                    {
                        id: 2,
                        x: canvas.width - 150,
                        y: canvas.height / 2,
                        vx: -v2,
                        vy: 0,
                        mass: m2,
                        radius: Math.max(15, Math.min(35, m2 * 12)),
                        color: '#4444ff',
                        trail: []
                    }
                ];

                let time = 0;
                let collisionOccurred = false;
                let collisionTime = 0;
                const dt = 0.016; // 60 FPS
                
                // 保存初始动量和能量
                const initialMomentum = {
                    x: m1 * v1 + m2 * (-v2),
                    y: 0
                };
                const initialKE = 0.5 * m1 * v1 * v1 + 0.5 * m2 * v2 * v2;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制实验室坐标系
                    this.drawLabFrame(ctx, canvas);

                    // 绘制质心坐标系
                    this.drawCenterOfMassFrame(ctx, canvas, balls);

                    // 更新球体位置
                    balls.forEach(ball => {
                        ball.x += ball.vx * dt * 60; // 像素/秒转换
                        ball.y += ball.vy * dt * 60;
                        
                        // 记录轨迹
                        if (time % 0.1 < dt) {
                            ball.trail.push({x: ball.x, y: ball.y, time: time});
                            if (ball.trail.length > 100) ball.trail.shift();
                        }

                        // 边界反弹
                        if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
                            ball.vx *= -0.9; // 轻微能量损失
                            ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
                        }
                        if (ball.y - ball.radius <= 0 || ball.y + ball.radius >= canvas.height) {
                            ball.vy *= -0.9;
                            ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));
                        }
                    });

                    // 检测和处理碰撞
                    this.handleCollisions(balls, e, ctx);

                    // 绘制轨迹
                    balls.forEach(ball => {
                        this.drawTrail(ctx, ball.trail, ball.color);
                    });

                    // 绘制球体
                    balls.forEach(ball => {
                        this.drawCollisionBall(ctx, ball);
                    });

                    // 绘制速度矢量
                    balls.forEach(ball => {
                        this.drawVelocityVector2D(ctx, ball);
                    });

                    // 绘制动量守恒分析
                    this.drawMomentumAnalysis(ctx, canvas, balls, initialMomentum);

                    // 绘制能量分析图表
                    this.drawEnergyConservationChart(ctx, canvas, balls, initialKE, time);

                    // 计算当前物理量
                    const currentMomentum = {
                        x: balls.reduce((sum, ball) => sum + ball.mass * ball.vx, 0),
                        y: balls.reduce((sum, ball) => sum + ball.mass * ball.vy, 0)
                    };
                    const currentKE = balls.reduce((sum, ball) => 
                        sum + 0.5 * ball.mass * (ball.vx * ball.vx + ball.vy * ball.vy), 0);
                    
                    const momentumMagnitude = Math.sqrt(currentMomentum.x * currentMomentum.x + currentMomentum.y * currentMomentum.y);
                    const initialMomentumMagnitude = Math.sqrt(initialMomentum.x * initialMomentum.x + initialMomentum.y * initialMomentum.y);
                    
                    // 计算质心
                    const totalMass = balls.reduce((sum, ball) => sum + ball.mass, 0);
                    const cmVx = currentMomentum.x / totalMass;
                    const cmVy = currentMomentum.y / totalMass;

                    document.getElementById('mechanics-info').innerHTML = `
                        <strong>碰撞实验分析:</strong><br>
                        时间: ${time.toFixed(2)}s<br>
                        <strong>球体1:</strong> v = ${Math.sqrt(balls[0].vx*balls[0].vx + balls[0].vy*balls[0].vy).toFixed(2)} m/s<br>
                        <strong>球体2:</strong> v = ${Math.sqrt(balls[1].vx*balls[1].vx + balls[1].vy*balls[1].vy).toFixed(2)} m/s<br>
                        <strong>守恒定律验证:</strong><br>
                        动量守恒: ${((Math.abs(momentumMagnitude - initialMomentumMagnitude) < 0.1) ? '✓' : '✗')}<br>
                        初始动量: ${initialMomentumMagnitude.toFixed(3)} kg⋅m/s<br>
                        当前动量: ${momentumMagnitude.toFixed(3)} kg⋅m/s<br>
                        <strong>能量分析:</strong><br>
                        初始动能: ${initialKE.toFixed(3)} J<br>
                        当前动能: ${currentKE.toFixed(3)} J<br>
                        能量损失: ${((initialKE - currentKE) / initialKE * 100).toFixed(1)}%<br>
                        <strong>质心运动:</strong><br>
                        质心速度: (${cmVx.toFixed(2)}, ${cmVy.toFixed(2)}) m/s<br>
                        恢复系数: ${e}
                    `;

                    time += dt;
                    this.animations.mechanics = requestAnimationFrame(animate);
                };

                animate();
            }

            drawLabFrame(ctx, canvas) {
                // 绘制实验室坐标系网格
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                for (let x = 0; x <= canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // 绘制坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.moveTo(50, 0);
                ctx.lineTo(50, canvas.height);
                ctx.stroke();

                // 坐标轴标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('实验室坐标系', canvas.width / 2, 20);
                ctx.fillText('x', canvas.width - 20, canvas.height / 2 - 10);
                ctx.fillText('y', 60, 20);
            }

            drawCenterOfMassFrame(ctx, canvas, balls) {
                // 计算质心位置
                const totalMass = balls.reduce((sum, ball) => sum + ball.mass, 0);
                const cmX = balls.reduce((sum, ball) => sum + ball.mass * ball.x, 0) / totalMass;
                const cmY = balls.reduce((sum, ball) => sum + ball.mass * ball.y, 0) / totalMass;

                // 绘制质心
                ctx.fillStyle = '#ff6b35';
                ctx.strokeStyle = '#cc4400';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cmX, cmY, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // 质心标签
                ctx.fillStyle = '#cc4400';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CM', cmX, cmY - 15);

                // 绘制质心坐标系（相对于质心的虚线）
                ctx.strokeStyle = 'rgba(255, 107, 53, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(cmX - 100, cmY);
                ctx.lineTo(cmX + 100, cmY);
                ctx.moveTo(cmX, cmY - 50);
                ctx.lineTo(cmX, cmY + 50);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            handleCollisions(balls, restitution, ctx) {
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        const ball1 = balls[i];
                        const ball2 = balls[j];
                        
                        const dx = ball2.x - ball1.x;
                        const dy = ball2.y - ball1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < ball1.radius + ball2.radius) {
                            // 碰撞检测成功，进行2D弹性碰撞计算
                            
                            // 单位法向量
                            const nx = dx / distance;
                            const ny = dy / distance;
                            
                            // 单位切向量
                            const tx = -ny;
                            const ty = nx;
                            
                            // 投影速度到法向和切向
                            const v1n = ball1.vx * nx + ball1.vy * ny;
                            const v1t = ball1.vx * tx + ball1.vy * ty;
                            const v2n = ball2.vx * nx + ball2.vy * ny;
                            const v2t = ball2.vx * tx + ball2.vy * ty;
                            
                            // 2D弹性碰撞公式
                            const v1nNew = ((ball1.mass - restitution * ball2.mass) * v1n + 
                                           ball2.mass * (1 + restitution) * v2n) / (ball1.mass + ball2.mass);
                            const v2nNew = ((ball2.mass - restitution * ball1.mass) * v2n + 
                                           ball1.mass * (1 + restitution) * v1n) / (ball1.mass + ball2.mass);
                            
                            // 切向速度保持不变
                            const v1tNew = v1t;
                            const v2tNew = v2t;
                            
                            // 转换回直角坐标系
                            ball1.vx = v1nNew * nx + v1tNew * tx;
                            ball1.vy = v1nNew * ny + v1tNew * ty;
                            ball2.vx = v2nNew * nx + v2tNew * tx;
                            ball2.vy = v2nNew * ny + v2tNew * ty;
                            
                            // 分离重叠的球体
                            const overlap = ball1.radius + ball2.radius - distance;
                            ball1.x -= overlap * 0.5 * nx;
                            ball1.y -= overlap * 0.5 * ny;
                            ball2.x += overlap * 0.5 * nx;
                            ball2.y += overlap * 0.5 * ny;
                            
                            // 碰撞特效
                            this.createCollisionEffect(ctx, (ball1.x + ball2.x) / 2, (ball1.y + ball2.y) / 2);
                        }
                    }
                }
            }

            drawTrail(ctx, trail, color) {
                if (trail.length < 2) return;
                
                ctx.strokeStyle = color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                
                trail.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
            }

            drawCollisionBall(ctx, ball) {
                // 主体球
                const gradient = ctx.createRadialGradient(
                    ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0,
                    ball.x, ball.y, ball.radius
                );
                gradient.addColorStop(0, ball.color.replace('44', '88'));
                gradient.addColorStop(1, ball.color);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                ctx.fill();

                // 边框
                ctx.strokeStyle = ball.color.replace('44', '22');
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                ctx.stroke();

                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.2, 0, 2 * Math.PI);
                ctx.fill();

                // 球体标签
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${ball.id}`, ball.x, ball.y + 4);
                ctx.fillText(`${ball.mass}kg`, ball.x, ball.y + ball.radius + 15);
            }

            drawVelocityVector2D(ctx, ball) {
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (speed < 0.1) return;
                
                const scale = 20;
                const vx = ball.vx * scale;
                const vy = ball.vy * scale;
                
                // 速度矢量
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + vx, ball.y + vy);
                ctx.stroke();
                
                // 箭头
                const angle = Math.atan2(vy, vx);
                this.drawArrowHead(ctx, ball.x + vx, ball.y + vy, angle, '#00ff88');
                
                // 速度分量
                ctx.strokeStyle = '#88ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                
                // x分量
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + vx, ball.y);
                ctx.stroke();
                
                // y分量
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x, ball.y + vy);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 速度标签
                ctx.fillStyle = '#006644';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`v=${speed.toFixed(1)}m/s`, ball.x + vx + 5, ball.y + vy - 5);
                ctx.fillText(`vₓ=${ball.vx.toFixed(1)}`, ball.x + vx + 5, ball.y + 10);
                ctx.fillText(`vᵧ=${ball.vy.toFixed(1)}`, ball.x - 40, ball.y + vy);
            }

            drawMomentumAnalysis(ctx, canvas, balls, initialMomentum) {
                const plotX = canvas.width - 250;
                const plotY = 50;
                const plotWidth = 200;
                const plotHeight = 150;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('动量分析', plotX + plotWidth/2, plotY + 20);
                
                // 计算当前总动量
                const currentMomentum = {
                    x: balls.reduce((sum, ball) => sum + ball.mass * ball.vx, 0),
                    y: balls.reduce((sum, ball) => sum + ball.mass * ball.vy, 0)
                };
                
                const scale = 5;
                const centerX = plotX + plotWidth/2;
                const centerY = plotY + plotHeight/2 + 20;
                
                // 绘制坐标轴
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(plotX + 20, centerY);
                ctx.lineTo(plotX + plotWidth - 20, centerY);
                ctx.moveTo(centerX, plotY + 30);
                ctx.lineTo(centerX, plotY + plotHeight - 20);
                ctx.stroke();
                
                // 初始动量矢量
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + initialMomentum.x * scale, centerY - initialMomentum.y * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, centerX + initialMomentum.x * scale, centerY - initialMomentum.y * scale,
                                  Math.atan2(-initialMomentum.y, initialMomentum.x), '#ff6b35');
                
                // 当前动量矢量
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + currentMomentum.x * scale, centerY - currentMomentum.y * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, centerX + currentMomentum.x * scale, centerY - currentMomentum.y * scale,
                                  Math.atan2(-currentMomentum.y, currentMomentum.x), '#4361ee');
                
                // 图例
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ff6b35';
                ctx.fillText('初始动量', plotX + 10, plotY + plotHeight - 25);
                ctx.fillStyle = '#4361ee';
                ctx.fillText('当前动量', plotX + 10, plotY + plotHeight - 10);
            }

            drawPendulumBob(ctx, x, y, angularVelocity) {
                // 主体摆球
                const radius = 20;
                const gradient = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, radius);
                gradient.addColorStop(0, '#88ccff');
                gradient.addColorStop(1, '#4361ee');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // 运动轨迹效果
                const speed = Math.abs(angularVelocity);
                ctx.fillStyle = `rgba(67, 97, 238, ${Math.min(0.3, speed * 0.1)})`;
                ctx.beginPath();
                ctx.arc(x - angularVelocity * 10, y, radius * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#2c5aa0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x - 6, y - 6, 6, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawPendulumTrajectory(ctx, centerX, centerY, length, currentAngle) {
                // 绘制摆动轨迹弧线
                ctx.strokeStyle = 'rgba(67, 97, 238, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, length, -Math.PI/3, Math.PI/3);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 当前位置标记
                const x = centerX + length * Math.sin(currentAngle);
                const y = centerY + length * Math.cos(currentAngle);
                ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity) {
                const scale = 20;
                const mass = 1; // kg
                
                // 重力
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX, bobY + gravity * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX, bobY + gravity * scale, Math.PI/2, '#ff4444');
                
                // 张力
                const tension = gravity * Math.cos(angle);
                ctx.strokeStyle = '#44ff44';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX - tension * scale * Math.sin(angle), bobY - tension * scale * Math.cos(angle));
                ctx.stroke();
                this.drawArrowHead(ctx, bobX - tension * scale * Math.sin(angle), bobY - tension * scale * Math.cos(angle), -angle - Math.PI/2, '#44ff44');
                
                // 切向力
                const tangentialForce = gravity * Math.sin(angle);
                ctx.strokeStyle = '#4444ff';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX + tangentialForce * scale * Math.cos(angle), bobY + tangentialForce * scale * Math.sin(angle));
                ctx.stroke();
                this.drawArrowHead(ctx, bobX + tangentialForce * scale * Math.cos(angle), bobY + tangentialForce * scale * Math.sin(angle), angle, '#4444ff');
                
                // 力的标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('mg', bobX + 5, bobY + gravity * scale + 15);
                ctx.fillText('T', bobX - tension * scale * Math.sin(angle) - 15, bobY - tension * scale * Math.cos(angle));
                ctx.fillText('F_t', bobX + tangentialForce * scale * Math.cos(angle) + 5, bobY + tangentialForce * scale * Math.sin(angle));
            }

            drawAngularVelocity(ctx, canvas, bobX, bobY, angularVelocity, length) {
                if (Math.abs(angularVelocity) < 0.01) return;
                
                const scale = 50;
                const velocityMagnitude = Math.abs(angularVelocity) * length;
                
                // 线速度矢量（切向）
                const angle = Math.atan2(bobY - 100, bobX - canvas.width/2) + Math.PI/2;
                const vx = velocityMagnitude * scale * Math.cos(angle) * (angularVelocity > 0 ? 1 : -1);
                const vy = velocityMagnitude * scale * Math.sin(angle) * (angularVelocity > 0 ? 1 : -1);
                
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX + vx, bobY + vy);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX + vx, bobY + vy, Math.atan2(vy, vx), '#ff6b35');
                
                // 速度标签
                ctx.fillStyle = '#ff6b35';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`v=${velocityMagnitude.toFixed(2)}m/s`, bobX + vx + 5, bobY + vy - 5);
                ctx.fillText(`ω=${angularVelocity.toFixed(3)}rad/s`, bobX + 25, bobY - 25);
            }

            drawPhasePortrait(ctx, canvas, phaseData) {
                if (phaseData.length < 2) return;
                
                const plotX = canvas.width - 200;
                const plotY = 50;
                const plotWidth = 150;
                const plotHeight = 150;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 坐标轴
                ctx.strokeStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(plotX + plotWidth/2, plotY);
                ctx.lineTo(plotX + plotWidth/2, plotY + plotHeight);
                ctx.moveTo(plotX, plotY + plotHeight/2);
                ctx.lineTo(plotX + plotWidth, plotY + plotHeight/2);
                ctx.stroke();
                
                // 相位轨迹
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                phaseData.forEach((point, index) => {
                    const x = plotX + plotWidth/2 + point.angle * plotWidth/4;
                    const y = plotY + plotHeight/2 - point.velocity * plotHeight/10;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('相位图', plotX + plotWidth/2, plotY - 5);
                ctx.font = '10px Arial';
                ctx.fillText('θ', plotX + plotWidth - 10, plotY + plotHeight - 5);
                ctx.fillText('ω', plotX + 5, plotY + 10);
            }

            drawEnergyPlot(ctx, canvas, energyData, currentTime) {
                if (energyData.length < 2) return;
                
                const plotX = canvas.width - 200;
                const plotY = 220;
                const plotWidth = 150;
                const plotHeight = 100;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 找到最大能量值用于缩放
                const maxEnergy = Math.max(...energyData.map(d => Math.max(d.ke, d.pe, d.total)));
                
                // 绘制能量曲线
                const drawEnergyLine = (data, color, property) => {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    data.forEach((point, index) => {
                        const x = plotX + (index / data.length) * plotWidth;
                        const y = plotY + plotHeight - (point[property] / maxEnergy) * plotHeight;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                };
                
                drawEnergyLine(energyData, '#ff4444', 'ke');  // 动能
                drawEnergyLine(energyData, '#44ff44', 'pe');  // 势能
                drawEnergyLine(energyData, '#4444ff', 'total'); // 总能量
                
                // 图例
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ff4444';
                ctx.fillText('动能', plotX + 5, plotY + 15);
                ctx.fillStyle = '#44ff44';
                ctx.fillText('势能', plotX + 5, plotY + 30);
                ctx.fillStyle = '#4444ff';
                ctx.fillText('总能量', plotX + 5, plotY + 45);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('能量-时间图', plotX + plotWidth/2, plotY - 5);
            }

            calculatePeriod(angle, angularVelocity, currentTime) {
                // 简化的周期计算（通过零点检测）
                if (!this.lastZeroCrossing) this.lastZeroCrossing = 0;
                
                if (Math.abs(angle) < 0.01 && angularVelocity > 0) {
                    const period = currentTime - this.lastZeroCrossing;
                    this.lastZeroCrossing = currentTime;
                    return period > 0.5 ? period : 0; // 过滤噪声
                }
                return 0;
            }

            // 电磁学模拟函数

            simulateRefraction() {
                const canvas = this.canvases.optics;
                const ctx = this.contexts.optics;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const incidentAngle = parseFloat(document.getElementById('incident-angle').value) * Math.PI / 180;
                const n1 = parseFloat(document.getElementById('refractive-index-1').value);
                const n2 = parseFloat(document.getElementById('refractive-index-2').value);

                // 计算折射角 (斯涅尔定律)
                const sinRefracted = (n1 / n2) * Math.sin(incidentAngle);
                const refractedAngle = Math.asin(Math.min(1, Math.abs(sinRefracted)));

                // 绘制界面
                ctx.fillStyle = 'rgba(67, 97, 238, 0.1)';
                ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();

                // 绘制法线
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 100);
                ctx.lineTo(canvas.width / 2, canvas.height - 100);
                ctx.stroke();
                ctx.setLineDash([]);

                // 绘制入射光线
                const incidentX = canvas.width / 2 - 150 * Math.sin(incidentAngle);
                const incidentY = canvas.height / 2 - 150 * Math.cos(incidentAngle);
                
                ctx.strokeStyle = '#ffeb3b';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(incidentX, incidentY);
                ctx.lineTo(canvas.width / 2, canvas.height / 2);
                ctx.stroke();

                // 绘制折射光线
                if (sinRefracted <= 1) {
                    const refractedX = canvas.width / 2 + 150 * Math.sin(refractedAngle);
                    const refractedY = canvas.height / 2 + 150 * Math.cos(refractedAngle);
                    
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, canvas.height / 2);
                    ctx.lineTo(refractedX, refractedY);
                    ctx.stroke();
                }

                // 更新信息
                document.getElementById('optics-info').innerHTML = `
                    入射角: ${(incidentAngle * 180 / Math.PI).toFixed(1)}°<br>
                    折射角: ${sinRefracted <= 1 ? (refractedAngle * 180 / Math.PI).toFixed(1) + '°' : '全反射'}<br>
                    n₁ = ${n1}, n₂ = ${n2}<br>
                    ${sinRefracted > 1 ? '发生全反射！' : ''}
                `;
            }

            resetOpticsSimulation() {
                this.isRunning.optics = false;
                this.contexts.optics.clearRect(0, 0, this.canvases.optics.width, this.canvases.optics.height);
                document.getElementById('optics-info').textContent = '调整参数观察光线传播规律';
            }

            setupWavesControls() {
                const startBtn = document.getElementById('start-waves');
                const resetBtn = document.getElementById('reset-waves');
                const pauseBtn = document.getElementById('pause-waves');

                if (document.getElementById('wave-frequency')) {
                    document.getElementById('wave-frequency').addEventListener('input', (e) => {
                        document.getElementById('frequency-value').textContent = e.target.value;
                        this.updateWaveInfo();
                    });
                }

                if (document.getElementById('wave-amplitude')) {
                    document.getElementById('wave-amplitude').addEventListener('input', (e) => {
                        document.getElementById('amplitude-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('wave-speed')) {
                    document.getElementById('wave-speed').addEventListener('input', (e) => {
                        document.getElementById('wave-speed-value').textContent = e.target.value;
                        this.updateWaveInfo();
                    });
                }

                if (startBtn) startBtn.addEventListener('click', () => this.startWavesSimulation());
                if (resetBtn) resetBtn.addEventListener('click', () => this.resetWavesSimulation());
                if (pauseBtn) pauseBtn.addEventListener('click', () => this.pauseWavesSimulation());

                this.updateWaveInfo();
            }

            updateWaveInfo() {
                const frequencyEl = document.getElementById('wave-frequency');
                const speedEl = document.getElementById('wave-speed');
                const wavelengthEl = document.getElementById('wavelength');
                const periodEl = document.getElementById('period');

                if (frequencyEl && speedEl && wavelengthEl && periodEl) {
                    const frequency = parseFloat(frequencyEl.value);
                    const speed = parseFloat(speedEl.value);
                    const wavelength = speed / frequency;
                    const period = 1 / frequency;

                    wavelengthEl.textContent = wavelength.toFixed(1) + 'm';
                    periodEl.textContent = period.toFixed(2) + 's';
                }
            }

            startWavesSimulation() {
                this.isRunning.waves = true;
                this.simulateWaves();
            }

            simulateWaves() {
                const canvas = this.canvases.waves;
                const ctx = this.contexts.waves;
                
                const frequency = parseFloat(document.getElementById('wave-frequency').value);
                const amplitude = parseFloat(document.getElementById('wave-amplitude').value);
                const speed = parseFloat(document.getElementById('wave-speed').value);
                const type = document.getElementById('wave-type').value;

                let time = 0;
                const wavelength = speed / frequency;
                const period = 1 / frequency;
                const omega = 2 * Math.PI * frequency;
                const k = 2 * Math.PI / wavelength;
                const dt = 0.02;
                
                // Initialize wave data storage
                let waveHistory = [];
                let particleData = [];
                let energyData = [];
                
                // Create particle array for wave motion
                for (let i = 0; i < 100; i++) {
                    particleData.push({
                        x: i * (canvas.width / 100),
                        y: canvas.height / 2,
                        equilibriumY: canvas.height / 2,
                        velocity: 0,
                        displacement: 0
                    });
                }

                const animate = () => {
                    if (!this.isRunning.waves) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制增强的坐标系和网格
                    this.drawAdvancedWaveGrid(ctx, canvas, wavelength, amplitude);

                    if (type === 'transverse') {
                        this.drawAdvancedTransverseWave(ctx, canvas, amplitude, k, omega, time, particleData);
                    } else if (type === 'longitudinal') {
                        this.drawAdvancedLongitudinalWave(ctx, canvas, amplitude, k, omega, time, particleData);
                    } else if (type === 'standing') {
                        this.drawAdvancedStandingWave(ctx, canvas, amplitude, k, omega, time);
                    } else if (type === 'interference') {
                        this.drawAdvancedWaveInterference(ctx, canvas, amplitude, k, omega, time);
                    }

                    // 绘制高级波形分析
                    this.drawWaveformAnalysis(ctx, canvas, frequency, amplitude, speed, wavelength, period, time);

                    // 绘制粒子运动轨迹和速度矢量
                    this.drawParticleMotionAnalysis(ctx, canvas, type, amplitude, k, omega, time, particleData);

                    // 绘制能量密度和传播
                    this.drawWaveEnergyAnalysis(ctx, canvas, type, amplitude, k, omega, time);

                    // 绘制频谱和波包分析
                    this.drawFrequencySpectrumAnalysis(ctx, canvas, frequency, amplitude, time);

                    // 绘制波的干涉和衍射效应
                    this.drawWaveInterferenceEffects(ctx, canvas, wavelength, amplitude, time);

                    // 存储波形历史数据
                    if (time % 0.1 < dt) {
                        waveHistory.push({
                            time: time,
                            amplitude: amplitude,
                            frequency: frequency,
                            energy: 0.5 * amplitude * amplitude * omega * omega
                        });
                        if (waveHistory.length > 200) waveHistory.shift();
                    }

                    // 实时更新高级波动物理量
                    const instantaneousPower = 0.5 * amplitude * amplitude * omega * omega * speed;
                    const energyDensity = 0.5 * amplitude * amplitude * omega * omega;
                    const intensity = energyDensity * speed;
                    const impedance = Math.sqrt(1.0); // 简化阻抗
                    const phaseVelocity = speed;
                    const groupVelocity = speed; // 对于非色散介质

                    document.getElementById('waves-info').innerHTML = `
                        <strong>高级波动分析:</strong><br>
                        频率: ${frequency.toFixed(3)} Hz<br>
                        波长: ${wavelength.toFixed(2)} m<br>
                        周期: ${period.toFixed(3)} s<br>
                        相速度: ${phaseVelocity.toFixed(1)} m/s<br>
                        群速度: ${groupVelocity.toFixed(1)} m/s<br>
                        振幅: ${amplitude.toFixed(1)} 单位<br>
                        <strong>能量与功率分析:</strong><br>
                        瞬时功率: ${instantaneousPower.toFixed(3)} W<br>
                        能量密度: ${energyDensity.toFixed(3)} J/m³<br>
                        波强度: ${intensity.toFixed(3)} W/m²<br>
                        波阻抗: ${impedance.toFixed(3)} Ω<br>
                        <strong>波动现象:</strong><br>
                        • 波的叠加原理<br>
                        • 驻波的节点和反节点<br>
                        • 干涉和衍射效应<br>
                        • 多普勒效应<br>
                        • 波的反射和透射<br>
                        • 能量传播分析<br>
                        <strong>数学描述:</strong><br>
                        y = A sin(kx - ωt + φ)<br>
                        k = 2π/λ = ${k.toFixed(3)} rad/m<br>
                        ω = 2πf = ${omega.toFixed(3)} rad/s<br>
                        相位: φ = ${(k * 0 - omega * time).toFixed(2)} rad
                    `;

                    time += dt;
                    this.animations.waves = requestAnimationFrame(animate);
                };

                animate();
            }

            drawAdvancedWaveGrid(ctx, canvas, wavelength, amplitude) {
                // 绘制精密网格系统
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([1, 3]);
                
                const scale = 50; // 像素每单位长度
                const waveScale = Math.max(20, wavelength * 2);
                
                // 垂直网格线（每个波长标记）
                for (let x = 0; x <= canvas.width; x += waveScale) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // 水平网格线（每个振幅标记）
                const ampScale = Math.max(20, amplitude);
                for (let y = canvas.height/2 - 3*ampScale; y <= canvas.height/2 + 3*ampScale; y += ampScale) {
                    if (y > 0 && y < canvas.height) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                }
                ctx.setLineDash([]);

                // 绘制主坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // X轴（传播方向）
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                // Y轴（振动方向）
                ctx.moveTo(50, 50);
                ctx.lineTo(50, canvas.height - 50);
                ctx.stroke();

                // 坐标轴标签和刻度
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                
                // X轴标签（距离/波长）
                for (let i = 1; i <= 5; i++) {
                    const x = i * waveScale;
                    if (x < canvas.width - 20) {
                        ctx.fillText(`${i}λ`, x, canvas.height / 2 + 20);
                        // 刻度线
                        ctx.beginPath();
                        ctx.moveTo(x, canvas.height / 2 - 5);
                        ctx.lineTo(x, canvas.height / 2 + 5);
                        ctx.stroke();
                    }
                }
                
                // Y轴标签（振幅）
                ctx.textAlign = 'right';
                ctx.fillText('+A', 45, canvas.height / 2 - amplitude - 5);
                ctx.fillText('-A', 45, canvas.height / 2 + amplitude + 15);
                ctx.fillText('0', 45, canvas.height / 2 + 5);
                
                // 轴标题
                ctx.textAlign = 'center';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('位移 (m)', 25, 30);
                ctx.fillText('传播方向 →', canvas.width / 2, canvas.height - 10);
            }

            drawPendulumBob(ctx, x, y, angularVelocity) {
                // 主体摆球
                const radius = 20;
                const gradient = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, radius);
                gradient.addColorStop(0, '#88ccff');
                gradient.addColorStop(1, '#4361ee');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // 运动轨迹效果
                const speed = Math.abs(angularVelocity);
                ctx.fillStyle = `rgba(67, 97, 238, ${Math.min(0.3, speed * 0.1)})`;
                ctx.beginPath();
                ctx.arc(x - angularVelocity * 10, y, radius * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#2c5aa0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x - 6, y - 6, 6, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawPendulumTrajectory(ctx, centerX, centerY, length, currentAngle) {
                // 绘制摆动轨迹弧线
                ctx.strokeStyle = 'rgba(67, 97, 238, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, length, -Math.PI/3, Math.PI/3);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 当前位置标记
                const x = centerX + length * Math.sin(currentAngle);
                const y = centerY + length * Math.cos(currentAngle);
                ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity) {
                const scale = 20;
                const mass = 1; // kg
                
                // 重力
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX, bobY + gravity * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX, bobY + gravity * scale, Math.PI/2, '#ff4444');
                
                // 张力
                const tension = gravity * Math.cos(angle);
                ctx.strokeStyle = '#44ff44';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX - tension * scale * Math.sin(angle), bobY - tension * scale * Math.cos(angle));
                ctx.stroke();
                this.drawArrowHead(ctx, bobX - tension * scale * Math.sin(angle), bobY - tension * scale * Math.cos(angle), -angle - Math.PI/2, '#44ff44');
                
                // 切向力
                const tangentialForce = gravity * Math.sin(angle);
                ctx.strokeStyle = '#4444ff';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX + tangentialForce * scale * Math.cos(angle), bobY + tangentialForce * scale * Math.sin(angle));
                ctx.stroke();
                this.drawArrowHead(ctx, bobX + tangentialForce * scale * Math.cos(angle), bobY + tangentialForce * scale * Math.sin(angle), angle, '#4444ff');
                
                // 力的标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('mg', bobX + 5, bobY + gravity * scale + 15);
                ctx.fillText('T', bobX - tension * scale * Math.sin(angle) - 15, bobY - tension * scale * Math.cos(angle));
                ctx.fillText('F_t', bobX + tangentialForce * scale * Math.cos(angle) + 5, bobY + tangentialForce * scale * Math.sin(angle));
            }

            simulateLens() {
                const canvas = this.canvases.optics;
                const ctx = this.contexts.optics;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const focalLength = parseFloat(document.getElementById('focal-length').value);
                const objectDistance = parseFloat(document.getElementById('object-distance').value);
                const lensType = document.getElementById('lens-type').value;

                const lensX = canvas.width / 2;
                const scale = 5; // 像素/cm

                // 绘制透镜
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 4;
                if (lensType === 'convex') {
                    // 凸透镜
                    ctx.beginPath();
                    ctx.arc(lensX - 20, canvas.height / 2, 100, -Math.PI/6, Math.PI/6);
                    ctx.arc(lensX + 20, canvas.height / 2, 100, Math.PI - Math.PI/6, Math.PI + Math.PI/6);
                    ctx.stroke();
                } else {
                    // 凹透镜
                    ctx.beginPath();
                    ctx.arc(lensX + 60, canvas.height / 2, 100, Math.PI - Math.PI/6, Math.PI + Math.PI/6);
                    ctx.arc(lensX - 60, canvas.height / 2, 100, -Math.PI/6, Math.PI/6);
                    ctx.stroke();
                }

                // 绘制光轴
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(50, canvas.height / 2);
                ctx.lineTo(canvas.width - 50, canvas.height / 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // 绘制物体
                const objectX = lensX - objectDistance * scale;
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(objectX, canvas.height / 2);
                ctx.lineTo(objectX, canvas.height / 2 - 40);
                ctx.stroke();

                // 计算像距
                let imageDistance;
                if (lensType === 'convex') {
                    imageDistance = (focalLength * objectDistance) / (objectDistance - focalLength);
                } else {
                    imageDistance = -(focalLength * objectDistance) / (objectDistance + focalLength);
                }

                if (isFinite(imageDistance)) {
                    const imageX = lensX + imageDistance * scale;
                    const magnification = -imageDistance / objectDistance;
                    
                    // 绘制像
                    ctx.strokeStyle = magnification > 0 ? '#4361ee' : '#ff4444';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(imageX, canvas.height / 2);
                    ctx.lineTo(imageX, canvas.height / 2 - 40 * magnification);
                    ctx.stroke();

                    document.getElementById('optics-info').innerHTML = `
                        物距: ${objectDistance}cm<br>
                        焦距: ${focalLength}cm<br>
                        像距: ${imageDistance.toFixed(1)}cm<br>
                        放大倍数: ${magnification.toFixed(2)}<br>
                        像的性质: ${magnification > 0 ? '正立' : '倒立'}，${Math.abs(magnification) > 1 ? '放大' : '缩小'}
                    `;
                } else {
                    document.getElementById('optics-info').innerHTML = `
                        物距: ${objectDistance}cm<br>
                        焦距: ${focalLength}cm<br>
                        无法成像（物体在焦点上）
                    `;
                }
            }

            simulateInterference() {
                const canvas = this.canvases.optics;
                const ctx = this.contexts.optics;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const wavelength = parseFloat(document.getElementById('light-wavelength').value);
                const slitSpacing = parseFloat(document.getElementById('slit-spacing').value);
                const screenDistance = parseFloat(document.getElementById('screen-distance').value);

                // 绘制双缝
                const slitX = 200;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(slitX, 100);
                ctx.lineTo(slitX, canvas.height / 2 - 30);
                ctx.moveTo(slitX, canvas.height / 2 + 30);
                ctx.lineTo(slitX, canvas.height - 100);
                ctx.stroke();

                // 绘制屏幕
                const screenX = slitX + screenDistance * 100;
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(screenX, 100);
                ctx.lineTo(screenX, canvas.height - 100);
                ctx.stroke();

                // 计算干涉条纹
                const k = 2 * Math.PI / wavelength;
                const slitSeparation = slitSpacing / 1000; // 转换为mm

                // 绘制干涉条纹
                for (let y = 100; y < canvas.height - 100; y += 2) {
                    const screenY = y - canvas.height / 2;
                    const pathDiff = slitSeparation * screenY / (screenDistance * 1000);
                    const phase = k * pathDiff;
                    const intensity = Math.pow(Math.cos(phase / 2), 2);
                    
                    const brightness = Math.floor(255 * intensity);
                    ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                    ctx.fillRect(screenX - 5, y, 10, 2);
                }

                document.getElementById('optics-info').innerHTML = `
                    波长: ${wavelength}nm<br>
                    缝间距: ${slitSpacing}μm<br>
                    屏幕距离: ${screenDistance}m<br>
                    观察到明暗相间的干涉条纹
                `;
            }

            drawAdvancedStandingWave(ctx, canvas, amplitude, k, omega, time) {
                // 绘制驻波的包络线
                ctx.strokeStyle = 'rgba(255, 107, 53, 0.4)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                // 上包络线
                for (let x = 0; x <= canvas.width; x += 2) {
                    const envelope = amplitude * Math.abs(Math.sin(k * x / 10));
                    const y = canvas.height / 2 - envelope;
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                // 下包络线
                for (let x = canvas.width; x >= 0; x -= 2) {
                    const envelope = amplitude * Math.abs(Math.sin(k * x / 10));
                    const y = canvas.height / 2 + envelope;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 绘制实时驻波
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 4;
                ctx.beginPath();
                
                for (let x = 0; x <= canvas.width; x += 2) {
                    const envelope = amplitude * Math.abs(Math.sin(k * x / 10));
                    const y = canvas.height / 2 + envelope * Math.cos(omega * time);
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 标记节点和反节点
                const nodeSpacing = Math.PI / k * 10;
                
                // 节点（振幅为零的点）
                ctx.fillStyle = '#e74c3c';
                for (let i = 0; i <= canvas.width / nodeSpacing; i++) {
                    const x = i * nodeSpacing;
                    if (x > 0 && x < canvas.width) {
                        ctx.beginPath();
                        ctx.arc(x, canvas.height / 2, 8, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // 节点标签
                        ctx.fillStyle = '#333';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('节点', x, canvas.height / 2 + 25);
                        ctx.fillText(`N${i}`, x, canvas.height / 2 + 40);
                        ctx.fillStyle = '#e74c3c';
                    }
                }
                
                // 反节点（振幅最大的点）
                ctx.fillStyle = '#3498db';
                for (let i = 0; i <= canvas.width / nodeSpacing; i++) {
                    const x = (i + 0.5) * nodeSpacing;
                    if (x > 0 && x < canvas.width) {
                        const envelope = amplitude * Math.abs(Math.sin(k * x / 10));
                        const y = canvas.height / 2 + envelope * Math.cos(omega * time);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // 反节点标签
                        ctx.fillStyle = '#333';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('反节点', x, canvas.height / 2 - 30);
                        ctx.fillText(`A${i}`, x, canvas.height / 2 - 15);
                        
                        // 振幅指示器
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(x, canvas.height / 2 - envelope);
                        ctx.lineTo(x, canvas.height / 2 + envelope);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#3498db';
                    }
                }
                
                // 绘制驻波分析图
                this.drawStandingWaveAnalysis(ctx, canvas, amplitude, k, omega, time);
            }

            drawStandingWaveAnalysis(ctx, canvas, amplitude, k, omega, time) {
                const analysisX = 20;
                const analysisY = 20;
                const analysisWidth = 200;
                const analysisHeight = 120;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(analysisX, analysisY, analysisWidth, analysisHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(analysisX, analysisY, analysisWidth, analysisHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('驻波分析', analysisX + analysisWidth / 2, analysisY + 15);
                
                // 绘制振幅分布
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = 0; x < analysisWidth; x += 2) {
                    const position = x / analysisWidth * canvas.width;
                    const envelope = amplitude * Math.abs(Math.sin(k * position / 10));
                    const y = analysisY + analysisHeight - 20 - (envelope / amplitude) * 60;
                    
                    if (x === 0) {
                        ctx.moveTo(analysisX + x, y);
                    } else {
                        ctx.lineTo(analysisX + x, y);
                    }
                }
                ctx.stroke();
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('振幅包络', analysisX + 5, analysisY + 35);
                ctx.fillText('节点间距: λ/2', analysisX + 5, analysisY + 50);
                ctx.fillText('反节点振幅: 2A', analysisX + 5, analysisY + 65);
                ctx.fillText('相位关系: 原地振动', analysisX + 5, analysisY + 80);
                
                // 绘制能量分布
                ctx.fillStyle = 'rgba(52, 152, 219, 0.3)';
                for (let x = 0; x < analysisWidth; x += 4) {
                    const position = x / analysisWidth * canvas.width;
                    const envelope = amplitude * Math.abs(Math.sin(k * position / 10));
                    const energy = envelope * envelope;
                    const height = (energy / (amplitude * amplitude)) * 20;
                    ctx.fillRect(analysisX + x, analysisY + analysisHeight - 20, 3, -height);
                }
            }

            drawAdvancedWaveInterference(ctx, canvas, amplitude, k, omega, time) {
                // 双源干涉
                const source1X = canvas.width * 0.2;
                const source1Y = canvas.height * 0.4;
                const source2X = canvas.width * 0.2;
                const source2Y = canvas.height * 0.6;
                const sourceSpacing = Math.abs(source2Y - source1Y);
                
                // 绘制干涉图样
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let x = 0; x < canvas.width; x += 2) {
                    for (let y = 0; y < canvas.height; y += 2) {
                        // 计算到两个源的距离
                        const r1 = Math.sqrt((x - source1X) * (x - source1X) + (y - source1Y) * (y - source1Y));
                        const r2 = Math.sqrt((x - source2X) * (x - source2X) + (y - source2Y) * (y - source2Y));
                        
                        // 计算相位差
                        const phase1 = k * r1 / 10 - omega * time;
                        const phase2 = k * r2 / 10 - omega * time;
                        const phaseDiff = phase2 - phase1;
                        
                        // 计算干涉强度
                        const wave1 = amplitude * Math.sin(phase1) / Math.max(1, r1 / 50);
                        const wave2 = amplitude * Math.sin(phase2) / Math.max(1, r2 / 50);
                        const resultant = wave1 + wave2;
                        
                        // 转换为颜色
                        const intensity = Math.abs(resultant);
                        const normalized = Math.min(255, intensity * 50);
                        
                        // 设置像素颜色
                        const index = (y * canvas.width + x) * 4;
                        if (index < data.length) {
                            data[index] = resultant > 0 ? normalized : 0;     // R
                            data[index + 1] = normalized * 0.5;               // G
                            data[index + 2] = resultant < 0 ? normalized : 0; // B
                            data[index + 3] = normalized;                     // A
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // 绘制波源
                ctx.fillStyle = '#ffeb3b';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                
                // 源1
                ctx.beginPath();
                ctx.arc(source1X, source1Y, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // 源2
                ctx.beginPath();
                ctx.arc(source2X, source2Y, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // 绘制同心圆表示波阵面
                this.drawWaveFronts(ctx, source1X, source1Y, k, omega, time, '#ff6b35');
                this.drawWaveFronts(ctx, source2X, source2Y, k, omega, time, '#4361ee');
                
                // 绘制干涉分析
                this.drawInterferenceAnalysis(ctx, canvas, sourceSpacing, k, amplitude);
                
                // 标记构造性和破坏性干涉区域
                this.markInterferenceRegions(ctx, canvas, source1X, source1Y, source2X, source2Y, k, omega, time);
            }

            drawWaveFronts(ctx, centerX, centerY, k, omega, time, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                
                const waveLength = 2 * Math.PI / k * 10;
                const phase = omega * time;
                
                for (let i = 1; i <= 5; i++) {
                    const radius = (i * waveLength + phase * 5) % (waveLength * 5);
                    if (radius > 10) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                }
                ctx.globalAlpha = 1;
            }

            drawInterferenceAnalysis(ctx, canvas, sourceSpacing, k, amplitude) {
                const analysisX = canvas.width - 180;
                const analysisY = 20;
                const analysisWidth = 160;
                const analysisHeight = 140;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(analysisX, analysisY, analysisWidth, analysisHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(analysisX, analysisY, analysisWidth, analysisHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('双缝干涉分析', analysisX + analysisWidth / 2, analysisY + 15);
                
                // 干涉条纹强度分布
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let y = 0; y < analysisHeight - 40; y += 2) {
                    const angle = (y - (analysisHeight - 40) / 2) / 100;
                    const pathDiff = sourceSpacing * Math.sin(angle);
                    const phase = k * pathDiff / 10;
                    const intensity = 4 * amplitude * amplitude * Math.cos(phase / 2) * Math.cos(phase / 2);
                    const x = (intensity / (4 * amplitude * amplitude)) * 60;
                    
                    if (y === 0) {
                        ctx.moveTo(analysisX + 20 + x, analysisY + 30 + y);
                    } else {
                        ctx.lineTo(analysisX + 20 + x, analysisY + 30 + y);
                    }
                }
                ctx.stroke();
                
                // 标签和公式
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('强度: I = 4I₀cos²(δ/2)', analysisX + 5, analysisY + analysisHeight - 25);
                ctx.fillText('相位差: δ = kd sinθ', analysisX + 5, analysisY + analysisHeight - 15);
                ctx.fillText('明纹: δ = 2nπ', analysisX + 5, analysisY + analysisHeight - 5);
            }

            markInterferenceRegions(ctx, canvas, x1, y1, x2, y2, k, omega, time) {
                // 标记特殊干涉线
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                // 零级明纹（等光程线）
                const midY = (y1 + y2) / 2;
                ctx.beginPath();
                ctx.moveTo(Math.max(x1, x2), midY);
                ctx.lineTo(canvas.width, midY);
                ctx.stroke();
                
                // 一级明纹线
                const wavelength = 2 * Math.PI / k * 10;
                const spacing = Math.abs(y2 - y1);
                const angle1 = Math.asin(wavelength / spacing);
                
                if (!isNaN(angle1)) {
                    // 上一级明纹
                    ctx.beginPath();
                    ctx.moveTo(Math.max(x1, x2), midY);
                    ctx.lineTo(canvas.width, midY - (canvas.width - Math.max(x1, x2)) * Math.tan(angle1));
                    ctx.stroke();
                    
                    // 下一级明纹
                    ctx.beginPath();
                    ctx.moveTo(Math.max(x1, x2), midY);
                    ctx.lineTo(canvas.width, midY + (canvas.width - Math.max(x1, x2)) * Math.tan(angle1));
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                
                // 标记明暗纹
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('0级明纹', canvas.width - 50, midY + 5);
                if (!isNaN(angle1)) {
                    ctx.fillText('±1级明纹', canvas.width - 50, midY - 30);
                }
            }

            calculateElectricField(x, y) {
                let Ex = 0, Ey = 0;
                const k = 8.99e9; // 库仑常数 (简化)
                
                this.electricCharges.forEach(charge => {
                    const dx = x - charge.x;
                    const dy = y - charge.y;
                    const r2 = dx * dx + dy * dy;
                    const r = Math.sqrt(r2);
                    
                    if (r > charge.radius) {
                        const E = k * Math.abs(charge.charge) / r2;
                        Ex += E * dx / r * Math.sign(charge.charge);
                        Ey += E * dy / r * Math.sign(charge.charge);
                    }
                });
                
                return { x: Ex, y: Ey };
            }

            calculateElectricPotential(x, y) {
                let potential = 0;
                const k = 8.99e9; // 库仑常数
                
                this.electricCharges.forEach(charge => {
                    const dx = x - charge.x;
                    const dy = y - charge.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    if (r > charge.radius) {
                        potential += k * charge.charge / r;
                    }
                });
                
                return potential;
            }

            drawElectricFieldAnalysis(ctx, canvas) {
                const analysisX = 20;
                const analysisY = 20;
                const analysisWidth = 250;
                const analysisHeight = 150;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(analysisX, analysisY, analysisWidth, analysisHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(analysisX, analysisY, analysisWidth, analysisHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('电场分析面板', analysisX + analysisWidth / 2, analysisY + 18);
                
                // 计算关键点的电场
                const centerField = this.calculateElectricField(canvas.width / 2, canvas.height / 2);
                const centerMagnitude = Math.sqrt(centerField.x ** 2 + centerField.y ** 2);
                const centerPotential = this.calculateElectricPotential(canvas.width / 2, canvas.height / 2);
                
                // 显示实时数据
                ctx.fillStyle = '#333';
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('中心点电场分析:', analysisX + 10, analysisY + 40);
                ctx.fillText(`电场强度: ${centerMagnitude.toFixed(2)} N/C`, analysisX + 10, analysisY + 55);
                ctx.fillText(`电势: ${centerPotential.toFixed(2)} V`, analysisX + 10, analysisY + 70);
                ctx.fillText(`场强方向: ${Math.atan2(centerField.y, centerField.x).toFixed(2)} rad`, analysisX + 10, analysisY + 85);
                
                // 绘制电场矢量图示
                const vectorX = analysisX + 180;
                const vectorY = analysisY + 60;
                const scale = 0.01;
                
                // 绘制坐标系
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(vectorX - 30, vectorY);
                ctx.lineTo(vectorX + 30, vectorY);
                ctx.moveTo(vectorX, vectorY - 30);
                ctx.lineTo(vectorX, vectorY + 30);
                ctx.stroke();
                
                // 绘制电场矢量
                if (centerMagnitude > 0.1) {
                    const vectorLength = Math.min(25, centerMagnitude * scale);
                    const endX = vectorX + centerField.x * scale;
                    const endY = vectorY - centerField.y * scale; // Y轴翻转
                    
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(vectorX, vectorY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    const angle = Math.atan2(-centerField.y, centerField.x);
                    this.drawArrowHead(ctx, endX, endY, angle, '#e74c3c');
                }
                
                // 标签
                ctx.fillStyle = '#666';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('E⃗', vectorX + 35, vectorY + 5);
                ctx.fillText('电场矢量图', vectorX, vectorY + 45);
                
                // 显示物理常数
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('物理常数:', analysisX + 10, analysisY + 105);
                ctx.fillText('k = 8.99×10⁹ N⋅m²/C²', analysisX + 10, analysisY + 120);
                ctx.fillText('ε₀ = 8.85×10⁻¹² C²/N⋅m²', analysisX + 10, analysisY + 135);
            }

            drawElectricPotentialDistribution(ctx, canvas) {
                // 简化实现，避免过长
                const plotX = canvas.width - 200;
                const plotY = 200;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, 180, 100);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(plotX, plotY, 180, 100);
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('电势分布', plotX + 90, plotY + 20);
            }

            drawGaussianSurfaceDemo(ctx, canvas) {
                // 简化实现
                const x = 20, y = 350;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(x, y, 150, 80);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(x, y, 150, 80);
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('高斯定律: ∮E⋅dA = Q/ε₀', x + 75, y + 40);
            }

            calculateElectrostaticEnergy() {
                return 1.0; // 简化返回
            }

            setupElectromagnetismControls() {
                const typeSelect = document.getElementById('em-type');
                const strengthSlider = document.getElementById('magnetic-strength');
                const currentSlider = document.getElementById('current');
                const wireShapeSelect = document.getElementById('wire-shape');
                const chargeSlider = document.getElementById('charge-amount');
                const runButton = document.getElementById('run-em');
                const stopButton = document.getElementById('stop-em');
                const resetButton = document.getElementById('reset-em');

                if (typeSelect) {
                    typeSelect.addEventListener('change', () => {
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (strengthSlider) {
                    strengthSlider.addEventListener('input', () => {
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (currentSlider) {
                    currentSlider.addEventListener('input', () => {
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (wireShapeSelect) {
                    wireShapeSelect.addEventListener('change', () => {
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (chargeSlider) {
                    chargeSlider.addEventListener('input', () => {
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (runButton) {
                    runButton.addEventListener('click', () => {
                        this.startElectromagnetismSimulation();
                    });
                }

                if (stopButton) {
                    stopButton.addEventListener('click', () => {
                        this.stopElectromagnetismSimulation();
                    });
                }

                if (resetButton) {
                    resetButton.addEventListener('click', () => {
                        this.resetElectromagnetismSimulation();
                    });
                }

                // 初始化电荷数组
                this.electricCharges = [];
                this.magneticSources = [];
            }

            updateElectromagnetismSimulation() {
                if (!this.isRunning.em) return;
                
                const type = document.getElementById('em-type')?.value || 'magnetic';
                
                if (type === 'magnetic') {
                    this.simulateMagneticField();
                } else if (type === 'electric') {
                    this.simulateElectricField();
                } else if (type === 'induction') {
                    this.simulateElectromagneticInduction();
                }
            }

            startElectromagnetismSimulation() {
                this.isRunning.em = true;
                this.updateElectromagnetismSimulation();
                
                // 开始动画循环
                if (!this.animations.em) {
                    this.animations.em = setInterval(() => {
                        this.updateElectromagnetismSimulation();
                    }, 50);
                }
            }

            stopElectromagnetismSimulation() {
                this.isRunning.em = false;
                if (this.animations.em) {
                    clearInterval(this.animations.em);
                    this.animations.em = null;
                }
            }

            resetElectromagnetismSimulation() {
                this.stopElectromagnetismSimulation();
                this.electricCharges = [];
                this.magneticSources = [];
                
                const canvas = this.canvases.em;
                const ctx = this.contexts.em;
                if (canvas && ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }

            simulateMagneticField() {
                const canvas = this.canvases.em;
                const ctx = this.contexts.em;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const magneticStrength = parseFloat(document.getElementById('magnetic-strength')?.value || 1);
                const current = parseFloat(document.getElementById('current')?.value || 1);
                const wireShape = document.getElementById('wire-shape')?.value || 'straight';
                
                // 绘制磁场背景
                this.drawMagneticFieldBackground(ctx, canvas);
                
                if (wireShape === 'straight') {
                    this.drawStraightWireMagneticField(ctx, canvas, current, magneticStrength);
                } else if (wireShape === 'loop') {
                    this.drawLoopMagneticField(ctx, canvas, current, magneticStrength);
                } else if (wireShape === 'solenoid') {
                    this.drawSolenoidMagneticField(ctx, canvas, current, magneticStrength);
                }
                
                // 更新信息显示
                const infoElement = document.getElementById('em-info');
                if (infoElement) {
                    infoElement.innerHTML = `
                        <strong>磁场模拟</strong><br>
                        电流: ${current.toFixed(1)} A<br>
                        磁场强度: ${magneticStrength.toFixed(1)}<br>
                        导线形状: ${wireShape === 'straight' ? '直导线' : wireShape === 'loop' ? '环形' : '螺线管'}
                    `;
                }
            }

            simulateElectricField() {
                const canvas = this.canvases.em;
                const ctx = this.contexts.em;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const chargeAmount = parseFloat(document.getElementById('charge-amount')?.value || 1);
                
                // 如果没有电荷，创建一些默认电荷
                if (this.electricCharges.length === 0) {
                    this.electricCharges = [
                        { x: canvas.width * 0.3, y: canvas.height * 0.5, charge: chargeAmount },
                        { x: canvas.width * 0.7, y: canvas.height * 0.5, charge: -chargeAmount }
                    ];
                }
                
                // 绘制电场线
                this.drawElectricFieldLines(ctx, canvas);
                
                // 绘制电荷
                this.drawElectricCharges(ctx);
                
                // 绘制电场矢量
                this.drawElectricFieldVectors(ctx, canvas);
                
                // 更新信息显示
                const infoElement = document.getElementById('em-info');
                if (infoElement) {
                    infoElement.innerHTML = `
                        <strong>电场模拟</strong><br>
                        电荷量: ±${Math.abs(chargeAmount).toFixed(1)} C<br>
                        电荷数量: ${this.electricCharges.length}<br>
                        库仑常数: k = 8.99×10⁹ N⋅m²/C²
                    `;
                }
            }

            simulateElectromagneticInduction() {
                const canvas = this.canvases.em;
                const ctx = this.contexts.em;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const time = Date.now() * 0.001;
                const frequency = 0.5; // Hz
                const magneticFlux = Math.sin(2 * Math.PI * frequency * time);
                const inducedEMF = -2 * Math.PI * frequency * Math.cos(2 * Math.PI * frequency * time);
                
                // 绘制变化的磁场
                this.drawChangingMagneticField(ctx, canvas, magneticFlux);
                
                // 绘制感应电流
                this.drawInducedCurrent(ctx, canvas, inducedEMF);
                
                // 更新信息显示
                const infoElement = document.getElementById('em-info');
                if (infoElement) {
                    infoElement.innerHTML = `
                        <strong>电磁感应</strong><br>
                        磁通量: Φ = ${magneticFlux.toFixed(2)} Wb<br>
                        感应电动势: ε = ${inducedEMF.toFixed(2)} V<br>
                        法拉第定律: ε = -dΦ/dt
                    `;
                }
            }

            drawMagneticFieldBackground(ctx, canvas) {
                // 绘制网格背景
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                
                for (let x = 0; x < canvas.width; x += 20) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y < canvas.height; y += 20) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }

            drawStraightWireMagneticField(ctx, canvas, current, strength) {
                const wireX = canvas.width / 2;
                
                // 绘制导线
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(wireX, 0);
                ctx.lineTo(wireX, canvas.height);
                ctx.stroke();
                
                // 绘制磁场线（同心圆）
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 2;
                
                for (let r = 30; r < canvas.width / 2; r += 30) {
                    ctx.beginPath();
                    ctx.arc(wireX, canvas.height / 2, r, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    // 绘制磁场方向箭头
                    const arrowAngle = current > 0 ? Math.PI / 4 : -Math.PI / 4;
                    const arrowX = wireX + r * Math.cos(arrowAngle);
                    const arrowY = canvas.height / 2 + r * Math.sin(arrowAngle);
                    this.drawMagneticFieldArrow(ctx, arrowX, arrowY, arrowAngle + Math.PI / 2);
                }
                
                // 电流方向指示
                ctx.fillStyle = current > 0 ? '#ff4444' : '#4444ff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(current > 0 ? '⊙' : '⊗', wireX, 30);
            }

            drawLoopMagneticField(ctx, canvas, current, strength) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const loopRadius = 80;
                
                // 绘制线圈
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(centerX, centerY, loopRadius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 绘制磁场线
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 2;
                
                // 中心轴上的磁场线
                for (let i = -3; i <= 3; i++) {
                    if (i === 0) continue;
                    const y = centerY + i * 40;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 20, y);
                    ctx.lineTo(centerX + 20, y);
                    ctx.stroke();
                    this.drawMagneticFieldArrow(ctx, centerX + 15, y, 0);
                }
                
                // 环形磁场线
                for (let r = loopRadius + 30; r < canvas.width / 2; r += 40) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, -Math.PI / 3, Math.PI / 3);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 2 * Math.PI / 3, 4 * Math.PI / 3);
                    ctx.stroke();
                }
            }

            drawSolenoidMagneticField(ctx, canvas, current, strength) {
                const centerX = canvas.width / 2;
                const solenoidHeight = 200;
                const solenoidTop = (canvas.height - solenoidHeight) / 2;
                
                // 绘制螺线管
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                
                for (let i = 0; i < 8; i++) {
                    const y = solenoidTop + i * 25;
                    ctx.beginPath();
                    ctx.arc(centerX, y, 15, 0, Math.PI);
                    ctx.stroke();
                }
                
                // 内部磁场线（均匀）
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 2;
                
                for (let x = centerX - 40; x <= centerX + 40; x += 20) {
                    ctx.beginPath();
                    ctx.moveTo(x, solenoidTop);
                    ctx.lineTo(x, solenoidTop + solenoidHeight);
                    ctx.stroke();
                    this.drawMagneticFieldArrow(ctx, x, solenoidTop + solenoidHeight / 2, Math.PI / 2);
                }
                
                // 外部磁场线
                for (let i = 1; i <= 3; i++) {
                    const offset = i * 60;
                    ctx.beginPath();
                    ctx.moveTo(centerX - offset, solenoidTop + solenoidHeight);
                    ctx.quadraticCurveTo(centerX - offset - 30, centerY, centerX - offset, solenoidTop);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX + offset, solenoidTop);
                    ctx.quadraticCurveTo(centerX + offset + 30, centerY, centerX + offset, solenoidTop + solenoidHeight);
                    ctx.stroke();
                }
            }

            drawMagneticFieldArrow(ctx, x, y, direction) {
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + 15 * Math.cos(direction), y + 15 * Math.sin(direction));
                ctx.stroke();
                this.drawArrowHead(ctx, x + 15 * Math.cos(direction), y + 15 * Math.sin(direction), direction, '#0066ff');
            }

            drawChangingMagneticField(ctx, canvas, flux) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const intensity = Math.abs(flux);
                
                // 绘制磁场区域
                ctx.fillStyle = `rgba(0, 102, 255, ${intensity * 0.3})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 100, 0, 2 * Math.PI);
                ctx.fill();
                
                // 绘制磁场线
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * 2 * Math.PI;
                    const x1 = centerX + 60 * Math.cos(angle);
                    const y1 = centerY + 60 * Math.sin(angle);
                    const x2 = centerX + 90 * Math.cos(angle);
                    const y2 = centerY + 90 * Math.sin(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    
                    if (flux > 0) {
                        this.drawArrowHead(ctx, x2, y2, angle, '#0066ff');
                    }
                }
            }

            drawInducedCurrent(ctx, canvas, emf) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const loopRadius = 120;
                
                // 绘制导体环
                ctx.strokeStyle = emf > 0 ? '#ff4444' : '#44ff44';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(centerX, centerY, loopRadius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 绘制感应电流方向
                if (Math.abs(emf) > 0.1) {
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * 2 * Math.PI;
                        const x = centerX + loopRadius * Math.cos(angle);
                        const y = centerY + loopRadius * Math.sin(angle);
                        const currentDirection = emf > 0 ? angle + Math.PI / 2 : angle - Math.PI / 2;
                        this.drawCurrentArrow(ctx, x, y, 0, currentDirection);
                    }
                }
            }

            drawCurrentArrow(ctx, x, y, offset, direction) {
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x + offset, y);
                ctx.lineTo(x + offset + 20 * Math.cos(direction), y + 20 * Math.sin(direction));
                ctx.stroke();
                this.drawArrowHead(ctx, x + offset + 20 * Math.cos(direction), y + 20 * Math.sin(direction), direction, '#ff4444');
            }

            calculateInteractionForces() {
                return { coulomb: 1.0, distance: 1.0 }; // 简化返回
            }

            setupOpticsControls() {
                const typeSelect = document.getElementById('optics-type');
                const incidentAngleSlider = document.getElementById('incident-angle');
                const refractiveIndexSlider = document.getElementById('refractive-index');
                const focalLengthSlider = document.getElementById('focal-length');
                const objectDistanceSlider = document.getElementById('object-distance');
                const lensTypeSelect = document.getElementById('lens-type');
                const runButton = document.getElementById('run-optics');
                const stopButton = document.getElementById('stop-optics');
                const resetButton = document.getElementById('reset-optics');

                if (typeSelect) {
                    typeSelect.addEventListener('change', () => {
                        this.updateOpticsSimulation();
                    });
                }

                if (incidentAngleSlider) {
                    incidentAngleSlider.addEventListener('input', () => {
                        this.updateOpticsSimulation();
                    });
                }

                if (refractiveIndexSlider) {
                    refractiveIndexSlider.addEventListener('input', () => {
                        this.updateOpticsSimulation();
                    });
                }

                if (focalLengthSlider) {
                    focalLengthSlider.addEventListener('input', () => {
                        this.updateOpticsSimulation();
                    });
                }

                if (objectDistanceSlider) {
                    objectDistanceSlider.addEventListener('input', () => {
                        this.updateOpticsSimulation();
                    });
                }

                if (lensTypeSelect) {
                    lensTypeSelect.addEventListener('change', () => {
                        this.updateOpticsSimulation();
                    });
                }

                if (runButton) {
                    runButton.addEventListener('click', () => {
                        this.startOpticsSimulation();
                    });
                }

                if (stopButton) {
                    stopButton.addEventListener('click', () => {
                        this.stopOpticsSimulation();
                    });
                }

                if (resetButton) {
                    resetButton.addEventListener('click', () => {
                        this.resetOpticsSimulation();
                    });
                }
            }

            updateOpticsSimulation() {
                if (!this.isRunning.optics) return;
                
                const type = document.getElementById('optics-type')?.value || 'reflection';
                
                if (type === 'reflection') {
                    this.simulateReflection();
                } else if (type === 'refraction') {
                    this.simulateRefraction();
                } else if (type === 'lens') {
                    this.simulateLens();
                }
            }

            startOpticsSimulation() {
                this.isRunning.optics = true;
                this.updateOpticsSimulation();
                
                if (!this.animations.optics) {
                    this.animations.optics = setInterval(() => {
                        this.updateOpticsSimulation();
                    }, 50);
                }
            }

            stopOpticsSimulation() {
                this.isRunning.optics = false;
                if (this.animations.optics) {
                    clearInterval(this.animations.optics);
                    this.animations.optics = null;
                }
            }

            resetOpticsSimulation() {
                this.stopOpticsSimulation();
                const canvas = this.canvases.optics;
                const ctx = this.contexts.optics;
                if (canvas && ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }

            setupThermodynamicsControls() {
                const temperatureSlider = document.getElementById('temperature');
                const pressureSlider = document.getElementById('pressure');
                const volumeSlider = document.getElementById('volume');
                const gasTypeSelect = document.getElementById('gas-type');
                const runButton = document.getElementById('run-thermo');
                const stopButton = document.getElementById('stop-thermo');
                const resetButton = document.getElementById('reset-thermo');

                if (temperatureSlider) {
                    temperatureSlider.addEventListener('input', () => {
                        this.updateThermoSimulation();
                    });
                }

                if (pressureSlider) {
                    pressureSlider.addEventListener('input', () => {
                        this.updateThermoSimulation();
                    });
                }

                if (volumeSlider) {
                    volumeSlider.addEventListener('input', () => {
                        this.updateThermoSimulation();
                    });
                }

                if (gasTypeSelect) {
                    gasTypeSelect.addEventListener('change', () => {
                        this.updateThermoSimulation();
                    });
                }

                if (runButton) {
                    runButton.addEventListener('click', () => {
                        this.startThermoSimulation();
                    });
                }

                if (stopButton) {
                    stopButton.addEventListener('click', () => {
                        this.stopThermoSimulation();
                    });
                }

                if (resetButton) {
                    resetButton.addEventListener('click', () => {
                        this.resetThermoSimulation();
                    });
                }

                // 初始化气体分子数组
                this.gasMolecules = [];
            }

            updateThermoSimulation() {
                if (!this.isRunning.thermo) return;
                this.simulateIdealGas();
            }

            startThermoSimulation() {
                this.isRunning.thermo = true;
                this.initializeGasMolecules();
                
                if (!this.animations.thermo) {
                    this.animations.thermo = setInterval(() => {
                        this.updateThermoSimulation();
                    }, 50);
                }
            }

            stopThermoSimulation() {
                this.isRunning.thermo = false;
                if (this.animations.thermo) {
                    clearInterval(this.animations.thermo);
                    this.animations.thermo = null;
                }
            }

            resetThermoSimulation() {
                this.stopThermoSimulation();
                this.gasMolecules = [];
                const canvas = this.canvases.thermo;
                const ctx = this.contexts.thermo;
                if (canvas && ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }

            initializeGasMolecules() {
                const canvas = this.canvases.thermo;
                if (!canvas) return;
                
                this.gasMolecules = [];
                const numMolecules = 50;
                
                for (let i = 0; i < numMolecules; i++) {
                    this.gasMolecules.push({
                        x: Math.random() * (canvas.width - 20) + 10,
                        y: Math.random() * (canvas.height - 20) + 10,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        radius: 3
                    });
                }
            }

            simulateIdealGas() {
                const canvas = this.canvases.thermo;
                const ctx = this.contexts.thermo;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const temperature = parseFloat(document.getElementById('temperature')?.value || 300);
                const pressure = parseFloat(document.getElementById('pressure')?.value || 1);
                const volume = parseFloat(document.getElementById('volume')?.value || 1);
                
                // 根据温度调整分子速度
                const speedFactor = Math.sqrt(temperature / 300);
                
                // 更新分子位置
                this.gasMolecules.forEach(molecule => {
                    molecule.x += molecule.vx * speedFactor;
                    molecule.y += molecule.vy * speedFactor;
                    
                    // 边界碰撞
                    if (molecule.x <= molecule.radius || molecule.x >= canvas.width - molecule.radius) {
                        molecule.vx *= -1;
                        molecule.x = Math.max(molecule.radius, Math.min(canvas.width - molecule.radius, molecule.x));
                    }
                    if (molecule.y <= molecule.radius || molecule.y >= canvas.height - molecule.radius) {
                        molecule.vy *= -1;
                        molecule.y = Math.max(molecule.radius, Math.min(canvas.height - molecule.radius, molecule.y));
                    }
                });
                
                // 绘制分子
                ctx.fillStyle = '#e74c3c';
                this.gasMolecules.forEach(molecule => {
                    ctx.beginPath();
                    ctx.arc(molecule.x, molecule.y, molecule.radius, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // 绘制容器
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
                
                // 显示信息
                const infoElement = document.getElementById('thermo-info');
                if (infoElement) {
                    const avgKineticEnergy = this.calculateAverageKineticEnergy();
                    infoElement.innerHTML = `
                        <strong>理想气体模拟</strong><br>
                        温度: ${temperature.toFixed(1)} K<br>
                        压强: ${pressure.toFixed(1)} atm<br>
                        体积: ${volume.toFixed(1)} L<br>
                        分子数: ${this.gasMolecules.length}<br>
                        平均动能: ${avgKineticEnergy.toFixed(2)} J
                    `;
                }
            }

            calculateAverageKineticEnergy() {
                if (this.gasMolecules.length === 0) return 0;
                
                const totalKE = this.gasMolecules.reduce((sum, molecule) => {
                    const speed = Math.sqrt(molecule.vx * molecule.vx + molecule.vy * molecule.vy);
                    return sum + 0.5 * speed * speed; // 假设质量为1
                }, 0);
                
                return totalKE / this.gasMolecules.length;
            }

            calculateElectricFlux() {
                return 1.0; // 简化返回
            }
        }

        // 初始化模拟器
        document.addEventListener('DOMContentLoaded', () => {
            new PhysicsSimulator();
        });
    </script>
</body>
</html> 