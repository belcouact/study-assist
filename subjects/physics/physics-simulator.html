<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理模拟器 - 学习助手</title>
    <link rel="icon" href="../../assets/icons/logo_btrfly.ico" type="image/x-icon">
    <link rel="stylesheet" href="../../css/common.css">
    <link rel="stylesheet" href="../../css/components.css">
    <link rel="stylesheet" href="../../css/utilities.css">
    <link rel="stylesheet" href="../../css/responsive.css">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        .simulator-page {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem 0;
        }

        .simulator-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            margin: 2rem auto;
            max-width: 1400px;
        }

        .simulator-header {
            background: linear-gradient(135deg, #4361ee, #7209b7);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .simulator-header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .simulator-header p {
            margin: 1rem 0 0 0;
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .simulator-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            overflow-x: auto;
        }

        .simulator-tab {
            flex: 1;
            min-width: 150px;
            padding: 1rem 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .simulator-tab.active {
            background: white;
            color: #4361ee;
            border-bottom: 3px solid #4361ee;
        }

        .simulator-tab:hover {
            background: rgba(67, 97, 238, 0.1);
            color: #4361ee;
        }

        .simulator-content {
            padding: 2rem;
            min-height: 600px;
        }

        .simulation-panel {
            display: none;
        }

        .simulation-panel.active {
            display: block;
        }

        .simulation-workspace {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
            height: 600px;
        }

        .simulation-controls {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .simulation-display {
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .simulation-canvas {
            width: 100%;
            height: 100%;
            display: block;
            background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f8f9fa 75%), 
                        linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            border-radius: 13px;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }

        .control-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .control-input:focus {
            outline: none;
            border-color: #4361ee;
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
        }

        .control-slider {
            width: 100%;
            margin: 0.5rem 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            transition: background 0.3s ease;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4361ee, #7209b7);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(67, 97, 238, 0.3);
        }

        .control-button {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(135deg, #4361ee, #7209b7);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.5rem;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(67, 97, 238, 0.3);
        }

        .control-button:active {
            transform: translateY(0);
        }

        .control-button.secondary {
            background: linear-gradient(135deg, #6c757d, #495057);
        }

        .control-button.danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }

        .simulation-info {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            border: 1px solid #4361ee;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .simulation-info h4 {
            margin: 0 0 0.5rem 0;
            color: #4361ee;
            font-weight: 600;
        }

        .simulation-info p {
            margin: 0;
            font-size: 0.9rem;
            color: #333;
        }

        /* Enhanced physics objects */
        .physics-object {
            position: absolute;
            border-radius: 50%;
            transition: all 0.1s ease;
        }

        .projectile {
            width: 12px;
            height: 12px;
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff4444);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.6), 0 0 30px rgba(255, 68, 68, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .pendulum-bob {
            width: 24px;
            height: 24px;
            background: radial-gradient(circle at 30% 30%, #6c95ff, #4361ee);
            box-shadow: 0 0 20px rgba(67, 97, 238, 0.5), 0 0 40px rgba(67, 97, 238, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
        }

        .pendulum-string {
            position: absolute;
            background: linear-gradient(to bottom, #333, #666);
            transform-origin: top center;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .wave-particle {
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #9c27b0, #7209b7);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.6);
        }

        .electric-charge {
            border-radius: 50%;
            border: 3px solid;
            position: absolute;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .charge-positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff4444);
            border-color: #cc0000;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
        }

        .charge-negative {
            background: radial-gradient(circle at 30% 30%, #4fc3f7, #2196f3);
            border-color: #0066cc;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.6);
        }

        .electric-charge:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.8);
        }

        .ray-light {
            stroke: #ffeb3b;
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 0 8px #ffeb3b) drop-shadow(0 0 16px #ffc107);
        }

        .lens {
            fill: rgba(67, 97, 238, 0.2);
            stroke: #4361ee;
            stroke-width: 3;
            filter: drop-shadow(0 0 5px rgba(67, 97, 238, 0.3));
        }

        .mirror {
            stroke: #666;
            stroke-width: 5;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
        }

        /* Particle system effects */
        .particle-explosion {
            position: absolute;
            pointer-events: none;
        }

        .spark-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: radial-gradient(circle, #ffeb3b, #ff9800);
            border-radius: 50%;
            animation: sparkle 1s ease-out forwards;
        }

        @keyframes sparkle {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.3);
            }
        }

        /* Wave effects */
        .wave-ripple {
            position: absolute;
            border: 2px solid rgba(67, 97, 238, 0.6);
            border-radius: 50%;
            animation: ripple 2s ease-out infinite;
        }

        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* Field visualization */
        .field-line {
            stroke: rgba(67, 97, 238, 0.7);
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(67, 97, 238, 0.3));
        }

        .magnetic-field-line {
            stroke: rgba(255, 107, 53, 0.7);
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(255, 107, 53, 0.3));
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .simulation-workspace {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .simulation-controls {
                order: 2;
                max-height: 300px;
            }
            
            .simulation-display {
                height: 400px;
                order: 1;
            }
            
            .simulator-tabs {
                flex-wrap: wrap;
            }
            
            .simulator-tab {
                min-width: 120px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            .simulator-content {
                padding: 1rem;
            }
            
            .simulation-workspace {
                gap: 1rem;
            }
            
            .simulation-display {
                height: 300px;
            }
        }

        /* Enhanced electromagnetic controls */
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .checkbox-group label:hover {
            background-color: rgba(67, 97, 238, 0.1);
        }

        .checkbox-group input[type="checkbox"] {
            margin-right: 0.5rem;
            transform: scale(1.1);
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .data-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0.6rem;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            border-left: 3px solid #4361ee;
        }

        .data-label {
            font-weight: 600;
            color: #333;
            font-size: 0.85rem;
        }

        .data-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #4361ee;
            font-size: 0.9rem;
        }

        .info-section {
            margin-bottom: 1rem;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(67, 97, 238, 0.2);
        }

        .info-section h5 {
            margin: 0 0 0.6rem 0;
            color: #4361ee;
            font-weight: 700;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .formula-list, .constants-list, .learning-points, .operation-guide {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .formula-item, .constant-item, .point-item, .guide-item {
            padding: 0.4rem 0.6rem;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            font-size: 0.85rem;
            line-height: 1.4;
            border-left: 2px solid #4361ee;
        }

        .formula-item strong, .constant-item strong, .guide-item strong {
            color: #4361ee;
            font-weight: 600;
        }

        .point-item {
            border-left-color: #28a745;
        }

        .guide-item {
            border-left-color: #ffc107;
        }

        /* Advanced visualization indicators */
        .field-strength-indicator {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #4361ee;
            border-radius: 6px;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            font-weight: bold;
            color: #4361ee;
            pointer-events: none;
            z-index: 1000;
        }

        .measurement-tool {
            cursor: crosshair;
        }

        .particle-trail {
            stroke: rgba(255, 255, 0, 0.7);
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5, 5;
            animation: dash 1s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }
    </style>
</head>
<body>
    <header class="main-header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <a href="../../index.html">
                        <i class="fas fa-graduation-cap" style="background: linear-gradient(90deg, #4361ee, #7209b7); -webkit-background-clip: text; background-clip: text; color: transparent;"></i>
                        <span>Alex的学习助手</span>
                    </a>
                </div>
                <nav class="main-nav">
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="main.html">物理</a></li>
                        <li><a href="../../index.html#subjects">科目</a></li>
                        <li><a href="../../tts.html">语音</a></li>
                        <li><a href="../../draw.html">绘图</a></li>
                    </ul>
                </nav>
                <button class="mobile-menu-toggle" aria-label="切换菜单">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
        </div>
    </header>

    <main class="simulator-page">
        <div class="container">
            <div class="simulator-container">
                <div class="simulator-header">
                    <h1><i class="fas fa-atom"></i> 物理模拟器</h1>
                    <p>通过交互式模拟探索物理世界的奥秘</p>
                </div>

                <div class="simulator-tabs">
                    <button class="simulator-tab active" data-tab="mechanics">
                        <i class="fas fa-cogs"></i> 力学
                    </button>
                    <button class="simulator-tab" data-tab="electromagnetism">
                        <i class="fas fa-bolt"></i> 电磁学
                    </button>
                    <button class="simulator-tab" data-tab="optics">
                        <i class="fas fa-glasses"></i> 光学
                    </button>
                    <button class="simulator-tab" data-tab="waves">
                        <i class="fas fa-water"></i> 波动
                    </button>
                    <button class="simulator-tab" data-tab="thermodynamics">
                        <i class="fas fa-temperature-high"></i> 热力学
                    </button>
                </div>

                <div class="simulator-content">
                    <!-- 力学模拟 -->
                    <div class="simulation-panel active" id="mechanics-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-cogs"></i> 力学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="mechanics-type">
                                        <option value="projectile">抛体运动</option>
                                        <option value="pendulum">单摆</option>
                                        <option value="collision">碰撞</option>
                                        <option value="spring">弹簧振动</option>
                                    </select>
                                </div>

                                <div id="projectile-controls">
                                    <div class="control-group">
                                        <label>初始速度 (m/s): <span id="velocity-value">20</span></label>
                                        <input type="range" class="control-slider" id="initial-velocity" min="5" max="50" value="20">
                                    </div>
                                    <div class="control-group">
                                        <label>发射角度 (°): <span id="angle-value">45</span></label>
                                        <input type="range" class="control-slider" id="launch-angle" min="0" max="90" value="45">
                                    </div>
                                    <div class="control-group">
                                        <label>重力加速度 (m/s²): <span id="gravity-value">9.8</span></label>
                                        <input type="range" class="control-slider" id="gravity" min="1" max="20" value="9.8" step="0.1">
                                    </div>
                                </div>

                                <div id="pendulum-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>摆长 (m): <span id="pendulum-length-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="pendulum-length" min="0.5" max="3" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>初始角度 (°): <span id="pendulum-angle-value">30</span></label>
                                        <input type="range" class="control-slider" id="pendulum-angle" min="5" max="60" value="30">
                                    </div>
                                </div>

                                <div id="collision-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>球1质量 (kg): <span id="mass1-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="mass1" min="0.5" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>球2质量 (kg): <span id="mass2-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="mass2" min="0.5" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>球1初速度 (m/s): <span id="velocity1-value">5</span></label>
                                        <input type="range" class="control-slider" id="velocity1" min="0" max="10" value="5" step="0.5">
                                    </div>
                                    <div class="control-group">
                                        <label>球2初速度 (m/s): <span id="velocity2-value">0</span></label>
                                        <input type="range" class="control-slider" id="velocity2" min="0" max="10" value="0" step="0.5">
                                    </div>
                                    <div class="control-group">
                                        <label>恢复系数: <span id="restitution-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="restitution" min="0" max="1" value="1.0" step="0.1">
                                    </div>
                                </div>

                                <div id="spring-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>弹簧常数 (N/m): <span id="spring-k-value">10</span></label>
                                        <input type="range" class="control-slider" id="spring-k" min="1" max="50" value="10">
                                    </div>
                                    <div class="control-group">
                                        <label>质量 (kg): <span id="spring-mass-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="spring-mass" min="0.1" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>初始位移 (m): <span id="spring-displacement-value">0.5</span></label>
                                        <input type="range" class="control-slider" id="spring-displacement" min="0.1" max="2" value="0.5" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>阻尼系数: <span id="damping-value">0.1</span></label>
                                        <input type="range" class="control-slider" id="damping" min="0" max="1" value="0.1" step="0.05">
                                    </div>
                                </div>

                                <button class="control-button" id="start-mechanics">开始模拟</button>
                                <button class="control-button secondary" id="reset-mechanics">重置</button>
                                <button class="control-button secondary" id="pause-mechanics">暂停</button>

                                <div class="simulation-info">
                                    <h4>实时数据</h4>
                                    <p id="mechanics-info">点击开始模拟查看实时数据</p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="mechanics-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 电磁学模拟 -->
                    <div class="simulation-panel" id="electromagnetism-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-bolt"></i> 电磁学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="em-type">
                                        <option value="electric-field">电场分析</option>
                                        <option value="magnetic-field">磁场分析</option>
                                        <option value="electromagnetic-induction">电磁感应</option>
                                        <option value="circuit">电路分析</option>
                                        <option value="electromagnetic-waves">电磁波</option>
                                        <option value="lorentz-force">洛伦兹力</option>
                                        <option value="capacitor">电容器</option>
                                        <option value="electric-motor">电动机</option>
                                        <option value="generator">发电机</option>
                                        <option value="transformer">变压器</option>
                                    </select>
                                </div>

                                <div id="electric-field-controls">
                                    <div class="control-group">
                                        <label>电荷配置</label>
                                        <select class="control-input" id="charge-config">
                                            <option value="dipole">电偶极子</option>
                                            <option value="quadrupole">四极子</option>
                                            <option value="line">线电荷</option>
                                            <option value="ring">环形电荷</option>
                                            <option value="custom">自定义</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>电荷强度 (μC): <span id="charge-strength-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="charge-strength" min="0.1" max="10" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>介电常数: <span id="dielectric-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="dielectric" min="1" max="10" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>可视化选项</label>
                                        <div class="checkbox-group">
                                            <label><input type="checkbox" id="show-field-lines" checked> 电场线</label>
                                            <label><input type="checkbox" id="show-equipotential" checked> 等势线</label>
                                            <label><input type="checkbox" id="show-field-vectors"> 场矢量</label>
                                            <label><input type="checkbox" id="show-field-magnitude"> 场强热力图</label>
                                            <label><input type="checkbox" id="show-grid"> 坐标网格</label>
                                        </div>
                                    </div>
                                    <div class="control-group">
                                        <label>测试电荷 (nC): <span id="test-charge-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="test-charge" min="-5" max="5" value="1.0" step="0.1">
                                    </div>
                                </div>

                                <div id="magnetic-field-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>电流源类型</label>
                                        <select class="control-input" id="current-source">
                                            <option value="straight">无限长直导线</option>
                                            <option value="loop">圆形线圈</option>
                                            <option value="solenoid">螺线管</option>
                                            <option value="helmholtz">亥姆霍兹线圈</option>
                                            <option value="toroidal">环形线圈</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>电流强度 (A): <span id="current-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="current" min="0.1" max="10" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>线圈半径 (cm): <span id="coil-radius-value">5</span></label>
                                        <input type="range" class="control-slider" id="coil-radius" min="2" max="15" value="5" step="0.5">
                                    </div>
                                    <div class="control-group">
                                        <label>线圈匝数: <span id="turns-value">100</span></label>
                                        <input type="range" class="control-slider" id="turns" min="10" max="500" value="100" step="10">
                                    </div>
                                    <div class="control-group">
                                        <label>磁场可视化</label>
                                        <div class="checkbox-group">
                                            <label><input type="checkbox" id="show-magnetic-lines" checked> 磁感线</label>
                                            <label><input type="checkbox" id="show-flux-density"> 磁感应强度等值线</label>
                                            <label><input type="checkbox" id="show-3d-field"> 3D磁场</label>
                                            <label><input type="checkbox" id="show-compass"> 磁针</label>
                                        </div>
                                    </div>
                                    <div class="control-group">
                                        <label>带电粒子</label>
                                            <button class="control-button secondary" id="add-particle">添加带电粒子</button>
                                    </div>
                                </div>

                                <div id="induction-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>感应类型</label>
                                        <select class="control-input" id="induction-type">
                                            <option value="moving-magnet">运动磁铁</option>
                                            <option value="changing-current">变化电流</option>
                                            <option value="rotating-coil">旋转线圈</option>
                                            <option value="transformer">变压器</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>线圈匝数: <span id="coil-turns-value">50</span></label>
                                        <input type="range" class="control-slider" id="coil-turns" min="10" max="200" value="50" step="5">
                                    </div>
                                    <div class="control-group">
                                        <label>磁场变化率 (T/s): <span id="flux-rate-value">0.5</span></label>
                                        <input type="range" class="control-slider" id="flux-rate" min="0.1" max="2" value="0.5" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>线圈电阻 (Ω): <span id="coil-resistance-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="coil-resistance" min="0.1" max="10" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>显示选项</label>
                                        <div class="checkbox-group">
                                            <label><input type="checkbox" id="show-induced-emf" checked> 感应电动势</label>
                                            <label><input type="checkbox" id="show-induced-current" checked> 感应电流</label>
                                            <label><input type="checkbox" id="show-flux-lines"> 磁通量线</label>
                                            <label><input type="checkbox" id="show-lenz-law"> 楞次定律演示</label>
                                        </div>
                                    </div>
                                </div>

                                <div id="circuit-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>电路类型</label>
                                        <select class="control-input" id="circuit-type">
                                            <option value="dc-series">直流串联</option>
                                            <option value="dc-parallel">直流并联</option>
                                            <option value="rc-circuit">RC电路</option>
                                            <option value="rl-circuit">RL电路</option>
                                            <option value="rlc-circuit">RLC电路</option>
                                            <option value="ac-circuit">交流电路</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>电压源 (V): <span id="voltage-value">12</span></label>
                                        <input type="range" class="control-slider" id="voltage" min="1" max="50" value="12" step="1">
                                    </div>
                                    <div class="control-group">
                                        <label>低温热源 (K): <span id="cold-reservoir-value">300</span></label>
                                        <input type="range" class="control-slider" id="cold-reservoir" min="200" max="350" value="300">
                                    </div>
                                    <div class="control-group">
                                        <label>工作气体体积 (L): <span id="gas-volume-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="gas-volume" min="0.5" max="3" value="1.0" step="0.1">
                                    </div>
                                </div>

                                <button class="control-button" id="start-thermo">开始模拟</button>
                                <button class="control-button secondary" id="reset-thermo">重置</button>
                                <button class="control-button secondary" id="pause-thermo">暂停</button>

                                <div class="simulation-info">
                                    <h4>热力学数据</h4>
                                    <p id="thermo-info">平均动能: <span id="avg-kinetic">--</span><br>体积: <span id="volume">--</span></p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="thermo-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 光学模拟 -->
                    <div class="simulation-panel" id="optics-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-eye"></i> 光学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="optics-type">
                                        <option value="reflection">反射</option>
                                        <option value="refraction">折射</option>
                                        <option value="lens">透镜</option>
                                        <option value="interference">干涉</option>
                                        <option value="diffraction">衍射</option>
                                        <option value="polarization">偏振</option>
                                    </select>
                                </div>

                                <div id="reflection-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>入射角度: <span id="incident-angle-value">45</span>°</label>
                                        <input type="range" class="control-slider" id="incident-angle" min="0" max="90" value="45">
                                    </div>
                                    <div class="control-group">
                                        <label>反射角度: <span id="reflection-angle-value">45</span>°</label>
                                        <input type="range" class="control-slider" id="reflection-angle" min="0" max="90" value="45">
                                    </div>
                                    <div class="control-group">
                                        <label>介质1折射率: <span id="n1-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="n1" min="1" max="3" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>介质2折射率: <span id="n2-value">1.5</span></label>
                                        <input type="range" class="control-slider" id="n2" min="1" max="3" value="1.5" step="0.1">
                                    </div>
                                </div>

                                <div id="refraction-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>入射角度: <span id="incident-angle-value">45</span>°</label>
                                        <input type="range" class="control-slider" id="incident-angle" min="0" max="90" value="45">
                                    </div>
                                    <div class="control-group">
                                        <label>折射角度: <span id="refraction-angle-value">30</span>°</label>
                                        <input type="range" class="control-slider" id="refraction-angle" min="0" max="90" value="30">
                                    </div>
                                    <div class="control-group">
                                        <label>介质1折射率: <span id="n1-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="n1" min="1" max="3" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>介质2折射率: <span id="n2-value">1.5</span></label>
                                        <input type="range" class="control-slider" id="n2" min="1" max="3" value="1.5" step="0.1">
                                    </div>
                                </div>

                                <div id="lens-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>透镜类型</label>
                                        <select class="control-input" id="lens-type">
                                            <option value="converging">凸透镜</option>
                                            <option value="diverging">凹透镜</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>焦距 (cm): <span id="focal-length-value">10</span></label>
                                        <input type="range" class="control-slider" id="focal-length" min="1" max="20" value="10">
                                    </div>
                                    <div class="control-group">
                                        <label>物距 (cm): <span id="object-distance-value">20</span></label>
                                        <input type="range" class="control-slider" id="object-distance" min="1" max="40" value="20">
                                    </div>
                                    <div class="control-group">
                                        <label>像距 (cm): <span id="image-distance-value">10</span></label>
                                        <input type="range" class="control-slider" id="image-distance" min="1" max="40" value="10">
                                    </div>
                                </div>

                                <div id="interference-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>干涉类型</label>
                                        <select class="control-input" id="interference-type">
                                            <option value="double-slit">双缝干涉</option>
                                            <option value="young">杨氏干涉</option>
                                            <option value="michaelson">米歇尔逊干涉</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>光源波长 (nm): <span id="wavelength-value">500</span></label>
                                        <input type="range" class="control-slider" id="wavelength" min="300" max="800" value="500">
                                    </div>
                                    <div class="control-group">
                                        <label>缝距 (μm): <span id="slit-separation-value">100</span></label>
                                        <input type="range" class="control-slider" id="slit-separation" min="10" max="500" value="100">
                                    </div>
                                    <div class="control-group">
                                        <label>相位差 (π): <span id="phase-difference-value">0</span></label>
                                        <input type="range" class="control-slider" id="phase-difference" min="0" max="2" value="0" step="0.1">
                                    </div>
                                </div>

                                <div id="diffraction-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>衍射类型</label>
                                        <select class="control-input" id="diffraction-type">
                                            <option value="single-slit">单缝衍射</option>
                                            <option value="double-slit">双缝衍射</option>
                                            <option value="circular">圆孔衍射</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>光源波长 (nm): <span id="wavelength-value">500</span></label>
                                        <input type="range" class="control-slider" id="wavelength" min="300" max="800" value="500">
                                    </div>
                                    <div class="control-group">
                                        <label>缝宽 (μm): <span id="slit-width-value">100</span></label>
                                        <input type="range" class="control-slider" id="slit-width" min="10" max="500" value="100">
                                    </div>
                                    <div class="control-group">
                                        <label>孔径 (μm): <span id="aperture-value">100</span></label>
                                        <input type="range" class="control-slider" id="aperture" min="10" max="500" value="100">
                                    </div>
                                </div>

                                <div id="polarization-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>偏振类型</label>
                                        <select class="control-input" id="polarization-type">
                                            <option value="malus">马吕斯定律</option>
                                            <option value="brewster">布儒斯特角</option>
                                            <option value="polarizer">偏振片</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>入射角度: <span id="incident-angle-value">45</span>°</label>
                                        <input type="range" class="control-slider" id="incident-angle" min="0" max="90" value="45">
                                    </div>
                                    <div class="control-group">
                                        <label>偏振角度: <span id="polarization-angle-value">0</span>°</label>
                                        <input type="range" class="control-slider" id="polarization-angle" min="0" max="90" value="0">
                                    </div>
                                </div>

                                <button class="control-button" id="start-optics">开始模拟</button>
                                <button class="control-button secondary" id="reset-optics">重置</button>
                                <button class="control-button secondary" id="pause-optics">暂停</button>

                                <div class="simulation-info">
                                    <h4>光学数据</h4>
                                    <p id="optics-info">点击开始模拟查看实时数据</p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="optics-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 波动模拟 -->
                    <div class="simulation-panel" id="waves-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-wave-square"></i> 波动模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="waves-type">
                                        <option value="standing">站立波</option>
                                        <option value="traveling">波的传播</option>
                                        <option value="interference">波的干涉</option>
                                        <option value="diffraction">波的衍射</option>
                                        <option value="reflection">波的反射</option>
                                        <option value="refraction">波的折射</option>
                                    </select>
                                </div>

                                <div id="standing-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>波长 (cm): <span id="wavelength-value">5</span></label>
                                        <input type="range" class="control-slider" id="wavelength" min="1" max="20" value="5">
                                    </div>
                                    <div class="control-group">
                                        <label>振幅 (cm): <span id="amplitude-value">2</span></label>
                                        <input type="range" class="control-slider" id="amplitude" min="0.1" max="10" value="2" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>频率 (Hz): <span id="frequency-value">1</span></label>
                                        <input type="range" class="control-slider" id="frequency" min="0.1" max="5" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>相位差 (π): <span id="phase-difference-value">0</span></label>
                                        <input type="range" class="control-slider" id="phase-difference" min="0" max="2" value="0" step="0.1">
                                    </div>
                                </div>

                                <div id="traveling-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>波长 (cm): <span id="wavelength-value">5</span></label>
                                        <input type="range" class="control-slider" id="wavelength" min="1" max="20" value="5">
                                    </div>
                                    <div class="control-group">
                                        <label>振幅 (cm): <span id="amplitude-value">2</span></label>
                                        <input type="range" class="control-slider" id="amplitude" min="0.1" max="10" value="2" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>频率 (Hz): <span id="frequency-value">1</span></label>
                                        <input type="range" class="control-slider" id="frequency" min="0.1" max="5" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>相位差 (π): <span id="phase-difference-value">0</span></label>
                                        <input type="range" class="control-slider" id="phase-difference" min="0" max="2" value="0" step="0.1">
                                    </div>
                                </div>

                                <div id="interference-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>波长 (cm): <span id="wavelength-value">5</span></label>
                                        <input type="range" class="control-slider" id="wavelength" min="1" max="20" value="5">
                                    </div>
                                    <div class="control-group">
                                        <label>振幅 (cm): <span id="amplitude-value">2</span></label>
                                        <input type="range" class="control-slider" id="amplitude" min="0.1" max="10" value="2" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>频率 (Hz): <span id="frequency-value">1</span></label>
                                        <input type="range" class="control-slider" id="frequency" min="0.1" max="5" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>相位差 (π): <span id="phase-difference-value">0</span></label>
                                        <input type="range" class="control-slider" id="phase-difference" min="0" max="2" value="0" step="0.1">
                                    </div>
                                </div>

                                <div id="diffraction-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>波长 (cm): <span id="wavelength-value">5</span></label>
                                        <input type="range" class="control-slider" id="wavelength" min="1" max="20" value="5">
                                    </div>
                                    <div class="control-group">
                                        <label>振幅 (cm): <span id="amplitude-value">2</span></label>
                                        <input type="range" class="control-slider" id="amplitude" min="0.1" max="10" value="2" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>频率 (Hz): <span id="frequency-value">1</span></label>
                                        <input type="range" class="control-slider" id="frequency" min="0.1" max="5" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>相位差 (π): <span id="phase-difference-value">0</span></label>
                                        <input type="range" class="control-slider" id="phase-difference" min="0" max="2" value="0" step="0.1">
                                    </div>
                                </div>

                                <div id="reflection-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>波长 (cm): <span id="wavelength-value">5</span></label>
                                        <input type="range" class="control-slider" id="wavelength" min="1" max="20" value="5">
                                    </div>
                                    <div class="control-group">
                                        <label>振幅 (cm): <span id="amplitude-value">2</span></label>
                                        <input type="range" class="control-slider" id="amplitude" min="0.1" max="10" value="2" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>频率 (Hz): <span id="frequency-value">1</span></label>
                                        <input type="range" class="control-slider" id="frequency" min="0.1" max="5" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>相位差 (π): <span id="phase-difference-value">0</span></label>
                                        <input type="range" class="control-slider" id="phase-difference" min="0" max="2" value="0" step="0.1">
                                    </div>
                                </div>

                                <div id="refraction-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>波长 (cm): <span id="wavelength-value">5</span></label>
                                        <input type="range" class="control-slider" id="wavelength" min="1" max="20" value="5">
                                    </div>
                                    <div class="control-group">
                                        <label>振幅 (cm): <span id="amplitude-value">2</span></label>
                                        <input type="range" class="control-slider" id="amplitude" min="0.1" max="10" value="2" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>频率 (Hz): <span id="frequency-value">1</span></label>
                                        <input type="range" class="control-slider" id="frequency" min="0.1" max="5" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>相位差 (π): <span id="phase-difference-value">0</span></label>
                                        <input type="range" class="control-slider" id="phase-difference" min="0" max="2" value="0" step="0.1">
                                    </div>
                                </div>

                                <button class="control-button" id="start-waves">开始模拟</button>
                                <button class="control-button secondary" id="reset-waves">重置</button>
                                <button class="control-button secondary" id="pause-waves">暂停</button>

                                <div class="simulation-info">
                                    <h4>波动数据</h4>
                                    <p id="waves-info">点击开始模拟查看实时数据</p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="waves-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 热力学模拟 -->
                    <div class="simulation-panel" id="thermodynamics-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-thermometer-half"></i> 热力学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="thermo-type">
                                        <option value="ideal-gas">理想气体</option>
                                        <option value="heat-transfer">热传导</option>
                                        <option value="convection">对流</option>
                                        <option value="radiation">辐射</option>
                                        <option value="phase-change">相变</option>
                                        <option value="chemical">化学反应</option>
                                    </select>
                                </div>

                                <div id="ideal-gas-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>气体类型</label>
                                        <select class="control-input" id="gas-type">
                                            <option value="monatomic">单原子气体</option>
                                            <option value="diatomic">双原子气体</option>
                                            <option value="polyatomic">多原子气体</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>温度 (K): <span id="temperature-value">300</span></label>
                                        <input type="range" class="control-slider" id="temperature" min="200" max="500" value="300">
                                    </div>
                                    <div class="control-group">
                                        <label>压力 (atm): <span id="pressure-value">1</span></label>
                                        <input type="range" class="control-slider" id="pressure" min="0.5" max="2" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>体积 (L): <span id="volume-value">1</span></label>
                                        <input type="range" class="control-slider" id="volume" min="0.5" max="3" value="1" step="0.1">
                                    </div>
                                </div>

                                <div id="heat-transfer-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>传导类型</label>
                                        <select class="control-input" id="conduction-type">
                                            <option value="steady">稳态传导</option>
                                            <option value="transient">瞬态传导</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>热传导率 (W/m·K): <span id="conductivity-value">0.5</span></label>
                                        <input type="range" class="control-slider" id="conductivity" min="0.1" max="1" value="0.5" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>热源温度 (K): <span id="hot-source-value">500</span></label>
                                        <input type="range" class="control-slider" id="hot-source" min="300" max="800" value="500">
                                    </div>
                                    <div class="control-group">
                                        <label>冷源温度 (K): <span id="cold-source-value">200</span></label>
                                        <input type="range" class="control-slider" id="cold-source" min="100" max="300" value="200">
                                    </div>
                                </div>

                                <div id="convection-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>对流类型</label>
                                        <select class="control-input" id="convection-type">
                                            <option value="forced">强制对流</option>
                                            <option value="natural">自然对流</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>流体温度 (K): <span id="fluid-temperature-value">300</span></label>
                                        <input type="range" class="control-slider" id="fluid-temperature" min="200" max="500" value="300">
                                    </div>
                                    <div class="control-group">
                                        <label>流速 (m/s): <span id="flow-speed-value">1</span></label>
                                        <input type="range" class="control-slider" id="flow-speed" min="0.1" max="5" value="1" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>热传导率 (W/m·K): <span id="conductivity-value">0.5</span></label>
                                        <input type="range" class="control-slider" id="conductivity" min="0.1" max="1" value="0.5" step="0.1">
                                    </div>
                                </div>

                                <div id="radiation-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>辐射类型</label>
                                        <select class="control-input" id="radiation-type">
                                            <option value="blackbody">黑体辐射</option>
                                            <option value="graybody">灰体辐射</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label>温度 (K): <span id="temperature-value">300</span></label>
                                        <input type="range" class="control-slider" id="temperature" min="200" max="500" value="300">
                                    </div>
                                    <div class="control-group">
                                        <label>表面温度 (K): <span id="surface-temperature-value">300</span></label>
                                        <input type="range" class="control-slider" id="surface-temperature" min="200" max="500" value="300">
                                    </div>
                                    <div class="control-group">
                                        <label>环境温度 (K): <span id="ambient-temperature-value">300</span></label>
    </footer>

    <script src="../../js/common.js"></script>
    <script src="../../js/navigation.js"></script>
    <script>
        // 物理模拟器主要功能
        class PhysicsSimulator {
            constructor() {
                this.currentTab = 'mechanics';
                this.animations = {};
                this.isRunning = {
                    mechanics: false,
                    em: false,
                    optics: false,
                    waves: false,
                    thermo: false
                };
                
                // 初始化电磁学相关数组
                this.electricCharges = [];
                this.magneticSources = [];
                
                this.initializeCanvases();
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // 标签切换
                document.querySelectorAll('.simulator-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchTab(e.target.dataset.tab);
                    });
                });

                // 力学控制
                this.setupMechanicsControls();
                this.setupElectromagnetismControls();
                this.setupOpticsControls();
                this.setupWavesControls();
                this.setupThermodynamicsControls();
            }

            initializeCanvases() {
                this.canvases = {
                    mechanics: document.getElementById('mechanics-canvas'),
                    em: document.getElementById('em-canvas'),
                    optics: document.getElementById('optics-canvas'),
                    waves: document.getElementById('waves-canvas'),
                    thermo: document.getElementById('thermo-canvas')
                };

                this.contexts = {};
                Object.keys(this.canvases).forEach(key => {
                    this.contexts[key] = this.canvases[key].getContext('2d');
                });
            }

            switchTab(tabName) {
                // 停止当前动画
                if (this.animations[this.currentTab]) {
                    cancelAnimationFrame(this.animations[this.currentTab]);
                }

                // 更新标签状态
                document.querySelectorAll('.simulator-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

                // 更新面板显示
                document.querySelectorAll('.simulation-panel').forEach(panel => {
                    panel.classList.remove('active');
                });
                document.getElementById(`${tabName}-panel`).classList.add('active');

                this.currentTab = tabName;
            }

            setupMechanicsControls() {
                const typeSelect = document.getElementById('mechanics-type');
                const startBtn = document.getElementById('start-mechanics');
                const resetBtn = document.getElementById('reset-mechanics');
                const pauseBtn = document.getElementById('pause-mechanics');

                // 类型切换
                if (typeSelect) {
                    typeSelect.addEventListener('change', (e) => {
                        this.switchMechanicsType(e.target.value);
                    });
                }

                // 滑块更新
                if (document.getElementById('initial-velocity')) {
                    document.getElementById('initial-velocity').addEventListener('input', (e) => {
                        document.getElementById('velocity-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('launch-angle')) {
                    document.getElementById('launch-angle').addEventListener('input', (e) => {
                        document.getElementById('angle-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('gravity')) {
                    document.getElementById('gravity').addEventListener('input', (e) => {
                        document.getElementById('gravity-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('pendulum-length')) {
                    document.getElementById('pendulum-length').addEventListener('input', (e) => {
                        document.getElementById('pendulum-length-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('pendulum-angle')) {
                    document.getElementById('pendulum-angle').addEventListener('input', (e) => {
                        document.getElementById('pendulum-angle-value').textContent = e.target.value;
                    });
                }

                // 碰撞控制
                if (document.getElementById('mass1')) {
                    document.getElementById('mass1').addEventListener('input', (e) => {
                        document.getElementById('mass1-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('mass2')) {
                    document.getElementById('mass2').addEventListener('input', (e) => {
                        document.getElementById('mass2-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('velocity1')) {
                    document.getElementById('velocity1').addEventListener('input', (e) => {
                        document.getElementById('velocity1-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('velocity2')) {
                    document.getElementById('velocity2').addEventListener('input', (e) => {
                        document.getElementById('velocity2-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('restitution')) {
                    document.getElementById('restitution').addEventListener('input', (e) => {
                        document.getElementById('restitution-value').textContent = e.target.value;
                    });
                }

                // 弹簧控制
                if (document.getElementById('spring-k')) {
                    document.getElementById('spring-k').addEventListener('input', (e) => {
                        document.getElementById('spring-k-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('spring-mass')) {
                    document.getElementById('spring-mass').addEventListener('input', (e) => {
                        document.getElementById('spring-mass-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('spring-displacement')) {
                    document.getElementById('spring-displacement').addEventListener('input', (e) => {
                        document.getElementById('spring-displacement-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('damping')) {
                    document.getElementById('damping').addEventListener('input', (e) => {
                        document.getElementById('damping-value').textContent = e.target.value;
                    });
                }

                // 按钮控制
                if (startBtn) startBtn.addEventListener('click', () => this.startMechanicsSimulation());
                if (resetBtn) resetBtn.addEventListener('click', () => this.resetMechanicsSimulation());
                if (pauseBtn) pauseBtn.addEventListener('click', () => this.pauseMechanicsSimulation());
            }

            switchMechanicsType(type) {
                document.getElementById('projectile-controls').style.display = 
                    type === 'projectile' ? 'block' : 'none';
                document.getElementById('pendulum-controls').style.display = 
                    type === 'pendulum' ? 'block' : 'none';
                document.getElementById('collision-controls').style.display = 
                    type === 'collision' ? 'block' : 'none';
                document.getElementById('spring-controls').style.display = 
                    type === 'spring' ? 'block' : 'none';
            }

            startMechanicsSimulation() {
                const type = document.getElementById('mechanics-type').value;
                this.isRunning.mechanics = true;

                if (type === 'projectile') {
                    this.simulateProjectileMotion();
                } else if (type === 'pendulum') {
                    this.simulatePendulum();
                } else if (type === 'collision') {
                    this.simulateCollision();
                } else if (type === 'spring') {
                    this.simulateSpring();
                }
            }

            simulateProjectileMotion() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const velocity = parseFloat(document.getElementById('initial-velocity').value);
                const angle = parseFloat(document.getElementById('launch-angle').value) * Math.PI / 180;
                const gravity = parseFloat(document.getElementById('gravity').value);

                const vx = velocity * Math.cos(angle);
                const vy = velocity * Math.sin(angle);

                let t = 0;
                const dt = 0.02;
                const scale = 8; // 像素/米
                
                // 空气阻力系数 (可调节)
                const airResistance = 0.01;
                const mass = 1; // kg

                // 存储轨迹点用于绘制完整轨迹
                const trajectoryPoints = [];
                let currentVx = vx;
                let currentVy = vy;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制坐标系和网格
                    this.drawCoordinateSystem(ctx, canvas, scale);

                    // 计算当前位置 (考虑空气阻力)
                    const x = 50 + t * currentVx * scale;
                    const y = canvas.height - 80 - (currentVy * t - 0.5 * gravity * t * t) * scale;

                    // 空气阻力计算
                    const speed = Math.sqrt(currentVx * currentVx + currentVy * currentVy);
                    const dragForceX = -airResistance * speed * currentVx;
                    const dragForceY = -airResistance * speed * currentVy;
                    
                    // 更新速度（考虑重力和空气阻力）
                    currentVx += (dragForceX / mass) * dt;
                    currentVy += (-gravity + dragForceY / mass) * dt;

                    // 存储轨迹点
                    if (t % 0.1 < dt) { // 每0.1秒记录一个点
                        trajectoryPoints.push({x: x, y: y, t: t});
                    }

                    // 绘制完整轨迹
                    this.drawTrajectory(ctx, trajectoryPoints);

                    // 绘制理论轨迹（无空气阻力）
                    this.drawTheoreticalTrajectory(ctx, canvas, vx, vy, gravity, scale);

                    if (y <= canvas.height - 80 && x < canvas.width - 50) {
                        // 绘制抛体（增强效果）
                        this.drawProjectile(ctx, x, y, currentVx, currentVy);

                        // 绘制速度分解
                        this.drawVelocityComponents(ctx, x, y, currentVx, currentVy);

                        // 绘制轨迹切线和法线
                        this.drawTangentAndNormal(ctx, x, y, currentVx, currentVy);

                        // 实时物理数据分析
                        const height = Math.max(0, (canvas.height - 80 - y) / scale);
                        const distance = (x - 50) / scale;
                        const totalSpeed = Math.sqrt(currentVx * currentVx + currentVy * currentVy);
                        const kineticEnergy = 0.5 * mass * totalSpeed * totalSpeed;
                        const potentialEnergy = mass * gravity * height;
                        const totalEnergy = kineticEnergy + potentialEnergy;
                        
                        // 计算理论值对比
                        const theoreticalRange = (vx * vx * Math.sin(2 * angle)) / gravity;
                        const maxHeight = (vy * vy) / (2 * gravity);

                        document.getElementById('mechanics-info').innerHTML = `
                            <strong>实时飞行数据:</strong><br>
                            时间: ${t.toFixed(2)}s<br>
                            位置: (${distance.toFixed(1)}m, ${height.toFixed(1)}m)<br>
                            速度: ${totalSpeed.toFixed(2)}m/s<br>
                            水平速度: ${currentVx.toFixed(2)}m/s<br>
                            垂直速度: ${currentVy.toFixed(2)}m/s<br>
                            <strong>能量分析:</strong><br>
                            动能: ${kineticEnergy.toFixed(2)}J<br>
                            势能: ${potentialEnergy.toFixed(2)}J<br>
                            总能量: ${totalEnergy.toFixed(2)}J<br>
                            <strong>理论对比:</strong><br>
                            理论射程: ${theoreticalRange.toFixed(1)}m<br>
                            最大高度: ${maxHeight.toFixed(1)}m<br>
                            空气阻力效应: ${((1 - distance/theoreticalRange)*100).toFixed(1)}%
                        `;

                        t += dt;
                        this.animations.mechanics = requestAnimationFrame(animate);
                    } else {
                        // 着陆分析
                        const finalDistance = (x - 50) / scale;
                        const flightTime = t;
                        this.isRunning.mechanics = false;
                        
                        document.getElementById('mechanics-info').innerHTML += `<br><strong style="color: #ff4444;">着陆分析:</strong><br>
                            实际射程: ${finalDistance.toFixed(1)}m<br>
                            飞行时间: ${flightTime.toFixed(2)}s<br>
                            着陆速度: ${Math.sqrt(currentVx*currentVx + currentVy*currentVy).toFixed(2)}m/s`;
                    }
                };

                animate();
            }

            drawCoordinateSystem(ctx, canvas, scale) {
                // 绘制网格
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                // 垂直网格线（每10米）
                for (let x = 50; x < canvas.width - 50; x += 10 * scale) {
                    ctx.beginPath();
                    ctx.moveTo(x, 50);
                    ctx.lineTo(x, canvas.height - 80);
                    ctx.stroke();
                }
                
                // 水平网格线（每5米）
                for (let y = canvas.height - 80; y > 50; y -= 5 * scale) {
                    ctx.beginPath();
                    ctx.moveTo(50, y);
                    ctx.lineTo(canvas.width - 50, y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // 绘制坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // X轴
                ctx.moveTo(50, canvas.height - 80);
                ctx.lineTo(canvas.width - 50, canvas.height - 80);
                // Y轴
                ctx.moveTo(50, canvas.height - 80);
                ctx.lineTo(50, 50);
                ctx.stroke();

                // 坐标轴标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i <= 100; i += 20) {
                    const x = 50 + i * scale;
                    if (x < canvas.width - 50) {
                        ctx.fillText(`${i}m`, x, canvas.height - 60);
                    }
                }
                
                ctx.textAlign = 'right';
                for (let i = 0; i <= 50; i += 10) {
                    const y = canvas.height - 80 - i * scale;
                    if (y > 50) {
                        ctx.fillText(`${i}m`, 45, y + 3);
                    }
                }
            }

            drawTrajectory(ctx, points) {
                if (points.length < 2) return;
                
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                
                points.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();

                // 绘制时间标记点
                ctx.fillStyle = '#4361ee';
                points.forEach((point, index) => {
                    if (index % 5 === 0) { // 每0.5秒标记一次
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.fillStyle = '#666';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${point.t.toFixed(1)}s`, point.x, point.y - 8);
                        ctx.fillStyle = '#4361ee';
                    }
                });
            }

            drawTheoreticalTrajectory(ctx, canvas, vx, vy, gravity, scale) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                const maxTime = (2 * vy) / gravity;
                for (let t = 0; t <= maxTime; t += 0.1) {
                    const x = 50 + vx * t * scale;
                    const y = canvas.height - 80 - (vy * t - 0.5 * gravity * t * t) * scale;
                    
                    if (t === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            drawProjectile(ctx, x, y, vx, vy) {
                // 主体抛体
                const gradient = ctx.createRadialGradient(x - 4, y - 4, 0, x, y, 10);
                gradient.addColorStop(0, '#ff8888');
                gradient.addColorStop(1, '#ff4444');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
                
                // 运动轨迹效果
                const speed = Math.sqrt(vx * vx + vy * vy);
                ctx.fillStyle = `rgba(255, 68, 68, ${Math.min(0.5, speed * 0.02)})`;
                ctx.beginPath();
                ctx.arc(x - vx * 0.5, y + vy * 0.5, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#cc0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.stroke();
            }

            drawVelocityComponents(ctx, x, y, vx, vy) {
                const scale = 5;
                
                // 总速度矢量
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + vx * scale, y - vy * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, x + vx * scale, y - vy * scale, Math.atan2(-vy, vx), '#ff6b35');
                
                // 水平分量
                ctx.strokeStyle = '#35ff6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + vx * scale, y);
                ctx.stroke();
                this.drawArrowHead(ctx, x + vx * scale, y, 0, '#35ff6b');
                
                // 垂直分量
                ctx.strokeStyle = '#6b35ff';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y - vy * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, x, y - vy * scale, -Math.PI/2, '#6b35ff');
                ctx.setLineDash([]);
                
                // 速度标签
                ctx.fillStyle = '#333';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`v=${Math.sqrt(vx*vx+vy*vy).toFixed(1)}`, x + vx * scale + 5, y - vy * scale - 5);
                ctx.fillText(`vₓ=${vx.toFixed(1)}`, x + vx * scale + 5, y + 12);
                ctx.fillText(`vᵧ=${vy.toFixed(1)}`, x - 40, y - vy * scale);
            }

            drawArrowHead(ctx, x, y, angle, color) {
                ctx.fillStyle = color;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-8, -3);
                ctx.lineTo(-8, 3);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            drawTangentAndNormal(ctx, x, y, vx, vy) {
                if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) return;
                
                const speed = Math.sqrt(vx * vx + vy * vy);
                const unitX = vx / speed;
                const unitY = vy / speed;
                
                // 切线方向
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([2, 4]);
                ctx.beginPath();
                ctx.moveTo(x - unitX * 30, y + unitY * 30);
                ctx.lineTo(x + unitX * 30, y - unitY * 30);
                ctx.stroke();
                
                // 法线方向（垂直于切线）
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.moveTo(x - unitY * 20, y - unitX * 20);
                ctx.lineTo(x + unitY * 20, y + unitX * 20);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            simulatePendulum() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const length = parseFloat(document.getElementById('pendulum-length').value);
                const initialAngle = parseFloat(document.getElementById('pendulum-angle').value) * Math.PI / 180;
                const gravity = 9.8;
                
                let angle = initialAngle;
                let angularVelocity = 0;
                const dt = 0.01;
                const scale = 200; // 像素/米
                const damping = 0.995; // 阻尼系数
                
                const centerX = canvas.width / 2;
                const centerY = 100;
                
                // 用于绘制相位图的数据
                const phaseData = [];
                const energyData = [];
                let time = 0;
                
                // 理论周期计算
                const theoreticalPeriod = 2 * Math.PI * Math.sqrt(length / gravity);
                const theoreticalFrequency = 1 / theoreticalPeriod;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制背景网格和坐标系
                    this.drawPendulumBackground(ctx, canvas, centerX, centerY, length, scale);

                    // 计算摆球位置
                    const bobX = centerX + length * scale * Math.sin(angle);
                    const bobY = centerY + length * scale * Math.cos(angle);

                    // 绘制摆线
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(bobX, bobY);
                    ctx.stroke();

                    // 绘制固定点
                    ctx.fillStyle = '#666';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // 绘制摆球（增强效果）
                    this.drawPendulumBob(ctx, bobX, bobY, angularVelocity);

                    // 绘制运动轨迹
                    this.drawPendulumTrajectory(ctx, centerX, centerY, length * scale, angle);

                    // 绘制力的分析
                    this.drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity);

                    // 绘制速度矢量
                    this.drawAngularVelocity(ctx, canvas, bobX, bobY, angularVelocity, length);

                    // 绘制相位图
                    this.drawPhasePortrait(ctx, canvas, phaseData);

                    // 绘制能量图表
                    this.drawEnergyPlot(ctx, canvas, energyData, time);

                    // 物理计算（非线性单摆方程）
                    const angularAcceleration = -(gravity / length) * Math.sin(angle);
                    angularVelocity += angularAcceleration * dt;
                    angularVelocity *= damping; // 应用阻尼
                    angle += angularVelocity * dt;

                    // 记录相位数据
                    if (time % 0.1 < dt) {
                        phaseData.push({angle: angle, velocity: angularVelocity});
                        if (phaseData.length > 200) phaseData.shift();
                        
                        // 能量计算
                        const kineticEnergy = 0.5 * length * length * angularVelocity * angularVelocity;
                        const potentialEnergy = gravity * length * (1 - Math.cos(angle));
                        const totalEnergy = kineticEnergy + potentialEnergy;
                        
                        energyData.push({
                            time: time,
                            ke: kineticEnergy,
                            pe: potentialEnergy,
                            total: totalEnergy
                        });
                        if (energyData.length > 300) energyData.shift();
                    }

                    // 计算实际周期（通过零点检测）
                    const currentPeriod = this.calculatePeriod(angle, angularVelocity, time);
                    const actualFrequency = currentPeriod > 0 ? 1 / currentPeriod : 0;

                    // 更新信息
                    const ke = 0.5 * length * length * angularVelocity * angularVelocity;
                    const pe = gravity * length * (1 - Math.cos(angle));
                    const totalEnergy = ke + pe;
                    const maxAngle = Math.acos(1 - totalEnergy / (gravity * length));
                    
                    document.getElementById('mechanics-info').innerHTML = `
                        <strong>单摆运动分析:</strong><br>
                        时间: ${time.toFixed(2)}s<br>
                        角度: ${(angle * 180 / Math.PI).toFixed(2)}°<br>
                        角速度: ${angularVelocity.toFixed(3)} rad/s<br>
                        角加速度: ${(-(gravity/length)*Math.sin(angle)).toFixed(3)} rad/s²<br>
                        <strong>能量分析:</strong><br>
                        动能: ${ke.toFixed(4)}J<br>
                        势能: ${pe.toFixed(4)}J<br>
                        总能量: ${totalEnergy.toFixed(4)}J<br>
                        最大角度: ±${(maxAngle * 180 / Math.PI).toFixed(1)}°<br>
                        <strong>周期分析:</strong><br>
                        理论周期: ${theoreticalPeriod.toFixed(3)}s<br>
                        实际周期: ${currentPeriod.toFixed(3)}s<br>
                        频率: ${actualFrequency.toFixed(3)}Hz<br>
                        阻尼比: ${((1 - damping) * 1000).toFixed(1)}‰
                    `;

                    time += dt;
                    this.animations.mechanics = requestAnimationFrame(animate);
                };

                animate();
            }

            drawPendulumBackground(ctx, canvas, centerX, centerY, length, scale) {
                // 绘制摆动范围圆弧
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, length * scale, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 绘制垂直参考线
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX, centerY + length * scale + 20);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 绘制角度标记
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.6)';
                ctx.lineWidth = 1;
                for (let i = -60; i <= 60; i += 15) {
                    const angleRad = i * Math.PI / 180;
                    const x1 = centerX + (length * scale - 10) * Math.sin(angleRad);
                    const y1 = centerY + (length * scale - 10) * Math.cos(angleRad);
                    const x2 = centerX + (length * scale + 10) * Math.sin(angleRad);
                    const y2 = centerY + (length * scale + 10) * Math.cos(angleRad);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    
                    // 角度标签
                    if (i % 30 === 0 && i !== 0) {
                        ctx.fillStyle = '#666';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${i}°`, x2, y2 - 5);
                    }
                }
            }

            drawPendulumBob(ctx, x, y, angularVelocity) {
                // 主体摆球
                const radius = 20;
                const gradient = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, radius);
                gradient.addColorStop(0, '#88ccff');
                gradient.addColorStop(1, '#4361ee');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // 运动轨迹效果
                const speed = Math.abs(angularVelocity);
                ctx.fillStyle = `rgba(67, 97, 238, ${Math.min(0.3, speed * 0.1)})`;
                ctx.beginPath();
                ctx.arc(x - angularVelocity * 10, y, radius * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#2c5aa0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x - 6, y - 6, 6, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawPendulumTrajectory(ctx, centerX, centerY, radius, currentAngle) {
                // 绘制摆动轨迹弧线
                ctx.strokeStyle = 'rgba(67, 97, 238, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, -Math.PI/3, Math.PI/3);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 高亮当前位置
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, currentAngle - 0.05, currentAngle + 0.05);
                ctx.stroke();
            }

            drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity) {
                const scale = 20;
                const mg = gravity; // 简化显示
                
                // 重力 (向下)
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX, bobY + mg * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX, bobY + mg * scale, Math.PI/2, '#ff4444');
                
                // 重力的切向分量
                const tangentialForce = mg * Math.sin(angle);
                const tangentX = bobX - tangentialForce * scale * Math.cos(angle);
                const tangentY = bobY - tangentialForce * scale * Math.sin(angle);
                
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(tangentX, tangentY);
                ctx.stroke();
                this.drawArrowHead(ctx, tangentX, tangentY, angle - Math.PI/2, '#ff8800');
                
                // 重力的径向分量
                const radialForce = mg * Math.cos(angle);
                const radialX = bobX - radialForce * scale * Math.sin(angle);
                const radialY = bobY - radialForce * scale * Math.cos(angle);
                
                ctx.strokeStyle = '#8844ff';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(radialX, radialY);
                ctx.stroke();
                this.drawArrowHead(ctx, radialX, radialY, angle + Math.PI, '#8844ff');
                ctx.setLineDash([]);
                
                // 力的标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('mg', bobX + 5, bobY + mg * scale);
                ctx.fillText('mg sin θ', tangentX + 5, tangentY);
                ctx.fillText('mg cos θ', radialX + 5, radialY);
            }

            drawAngularVelocity(ctx, canvas, bobX, bobY, angularVelocity, length) {
                if (Math.abs(angularVelocity) < 0.01) return;
                
                const scale = 100;
                const velocityMagnitude = Math.abs(angularVelocity) * length * scale;
                const direction = angularVelocity > 0 ? 1 : -1;
                
                // 切向速度矢量
                const vx = bobX + velocityMagnitude * direction * Math.cos(Math.atan2(bobY - 100, bobX - canvas.width/2) + Math.PI/2);
                const vy = bobY + velocityMagnitude * direction * Math.sin(Math.atan2(bobY - 100, bobX - canvas.width/2) + Math.PI/2);
                
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(vx, vy);
                ctx.stroke();
                
                const angle = Math.atan2(vy - bobY, vx - bobX);
                this.drawArrowHead(ctx, vx, vy, angle, '#00ff88');
                
                // 速度标签
                ctx.fillStyle = '#00aa66';
                ctx.font = 'bold 10px Arial';
                ctx.fillText(`v=${Math.abs(angularVelocity * length).toFixed(2)}m/s`, vx + 5, vy);
            }

            drawPhasePortrait(ctx, canvas, phaseData) {
                if (phaseData.length < 2) return;
                
                const plotX = canvas.width - 200;
                const plotY = 50;
                const plotWidth = 140;
                const plotHeight = 140;
                
                // 绘制相位图背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 坐标轴
                ctx.beginPath();
                ctx.moveTo(plotX + plotWidth/2, plotY);
                ctx.lineTo(plotX + plotWidth/2, plotY + plotHeight);
                ctx.moveTo(plotX, plotY + plotHeight/2);
                ctx.lineTo(plotX + plotWidth, plotY + plotHeight/2);
                ctx.stroke();
                
                // 绘制相位轨迹
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                phaseData.forEach((point, index) => {
                    const x = plotX + plotWidth/2 + (point.angle / Math.PI) * plotWidth * 0.4;
                    const y = plotY + plotHeight/2 - point.velocity * plotHeight * 0.1;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('相位图', plotX + plotWidth/2, plotY - 5);
                ctx.fillText('θ', plotX + plotWidth + 5, plotY + plotHeight/2);
                ctx.save();
                ctx.translate(plotX - 10, plotY + plotHeight/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('ω', 0, 0);
                ctx.restore();
            }

            drawEnergyPlot(ctx, canvas, energyData, currentTime) {
                if (energyData.length < 2) return;
                
                const plotX = 50;
                const plotY = canvas.height - 150;
                const plotWidth = 300;
                const plotHeight = 100;
                
                // 绘制能量图背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 找出最大能量用于归一化
                const maxEnergy = Math.max(...energyData.map(d => d.total));
                
                // 绘制能量曲线
                const colors = {ke: '#ff6b35', pe: '#4361ee', total: '#333'};
                const labels = {ke: '动能', pe: '势能', total: '总能量'};
                
                Object.keys(colors).forEach(energyType => {
                    ctx.strokeStyle = colors[energyType];
                    ctx.lineWidth = energyType === 'total' ? 3 : 2;
                    ctx.setLineDash(energyType === 'total' ? [5, 5] : []);
                    ctx.beginPath();
                    
                    energyData.forEach((point, index) => {
                        const x = plotX + (index / energyData.length) * plotWidth;
                        const y = plotY + plotHeight - (point[energyType] / maxEnergy) * plotHeight;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                });
                ctx.setLineDash([]);
                
                // 图例
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                Object.keys(colors).forEach((energyType, index) => {
                    ctx.fillStyle = colors[energyType];
                    ctx.fillRect(plotX + 10, plotY + 10 + index * 15, 10, 2);
                    ctx.fillStyle = '#333';
                    ctx.fillText(labels[energyType], plotX + 25, plotY + 15 + index * 15);
                });
                
                ctx.textAlign = 'center';
                ctx.fillText('能量-时间图', plotX + plotWidth/2, plotY - 5);
            }

            calculatePeriod(angle, angularVelocity, time) {
                // 简化的周期计算：检测角度零点
                if (!this.lastZeroCrossing) this.lastZeroCrossing = 0;
                if (!this.zeroCrossings) this.zeroCrossings = [];
                
                if (Math.abs(angle) < 0.01 && angularVelocity > 0) {
                    if (time - this.lastZeroCrossing > 1) { // 避免噪音
                        this.zeroCrossings.push(time);
                        this.lastZeroCrossing = time;
                        
                        if (this.zeroCrossings.length >= 3) {
                            const period = 2 * (this.zeroCrossings[this.zeroCrossings.length - 1] - 
                                            this.zeroCrossings[this.zeroCrossings.length - 3]);
                            return period;
                        }
                    }
                }
                
                return 0;
            }

            resetMechanicsSimulation() {
                this.isRunning.mechanics = false;
                if (this.animations.mechanics) {
                    cancelAnimationFrame(this.animations.mechanics);
                }
                this.contexts.mechanics.clearRect(0, 0, this.canvases.mechanics.width, this.canvases.mechanics.height);
                document.getElementById('mechanics-info').textContent = '点击开始模拟查看实时数据';
            }

            pauseMechanicsSimulation() {
                this.isRunning.mechanics = !this.isRunning.mechanics;
                if (this.isRunning.mechanics) {
                    const type = document.getElementById('mechanics-type').value;
                    if (type === 'projectile') {
                        this.simulateProjectileMotion();
                    } else if (type === 'pendulum') {
                        this.simulatePendulum();
                    } else if (type === 'collision') {
                        this.simulateCollision();
                    } else if (type === 'spring') {
                        this.simulateSpring();
                    }
                }
            }

            simulateCollision() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const m1 = parseFloat(document.getElementById('mass1').value);
                const m2 = parseFloat(document.getElementById('mass2').value);
                let v1 = parseFloat(document.getElementById('velocity1').value);
                let v2 = parseFloat(document.getElementById('velocity2').value);
                const e = parseFloat(document.getElementById('restitution').value);

                // 初始化多个碰撞球体
                const balls = [
                    {
                        id: 1,
                        x: 150,
                        y: canvas.height / 2,
                        vx: v1,
                        vy: 0,
                        mass: m1,
                        radius: Math.max(15, Math.min(35, m1 * 12)),
                        color: '#ff4444',
                        trail: []
                    },
                    {
                        id: 2,
                        x: canvas.width - 150,
                        y: canvas.height / 2,
                        vx: -v2,
                        vy: 0,
                        mass: m2,
                        radius: Math.max(15, Math.min(35, m2 * 12)),
                        color: '#4444ff',
                        trail: []
                    }
                ];

                let time = 0;
                let collisionOccurred = false;
                let collisionTime = 0;
                const dt = 0.016; // 60 FPS
                
                // 保存初始动量和能量
                const initialMomentum = {
                    x: m1 * v1 + m2 * (-v2),
                    y: 0
                };
                const initialKE = 0.5 * m1 * v1 * v1 + 0.5 * m2 * v2 * v2;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制实验室坐标系
                    this.drawLabFrame(ctx, canvas);

                    // 绘制质心坐标系
                    this.drawCenterOfMassFrame(ctx, canvas, balls);

                    // 更新球体位置
                    balls.forEach(ball => {
                        ball.x += ball.vx * dt * 60; // 像素/秒转换
                        ball.y += ball.vy * dt * 60;
                        
                        // 记录轨迹
                        if (time % 0.1 < dt) {
                            ball.trail.push({x: ball.x, y: ball.y, time: time});
                            if (ball.trail.length > 100) ball.trail.shift();
                        }

                        // 边界反弹
                        if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
                            ball.vx *= -0.9; // 轻微能量损失
                            ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
                        }
                        if (ball.y - ball.radius <= 0 || ball.y + ball.radius >= canvas.height) {
                            ball.vy *= -0.9;
                            ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));
                        }
                    });

                    // 检测和处理碰撞
                    this.handleCollisions(balls, e, ctx);

                    // 绘制轨迹
                    balls.forEach(ball => {
                        this.drawTrail(ctx, ball.trail, ball.color);
                    });

                    // 绘制球体
                    balls.forEach(ball => {
                        this.drawCollisionBall(ctx, ball);
                    });

                    // 绘制速度矢量
                    balls.forEach(ball => {
                        this.drawVelocityVector2D(ctx, ball);
                    });

                    // 绘制动量守恒分析
                    this.drawMomentumAnalysis(ctx, canvas, balls, initialMomentum);

                    // 绘制能量分析图表
                    this.drawEnergyConservationChart(ctx, canvas, balls, initialKE, time);

                    // 计算当前物理量
                    const currentMomentum = {
                        x: balls.reduce((sum, ball) => sum + ball.mass * ball.vx, 0),
                        y: balls.reduce((sum, ball) => sum + ball.mass * ball.vy, 0)
                    };
                    const currentKE = balls.reduce((sum, ball) => 
                        sum + 0.5 * ball.mass * (ball.vx * ball.vx + ball.vy * ball.vy), 0);
                    
                    const momentumMagnitude = Math.sqrt(currentMomentum.x * currentMomentum.x + currentMomentum.y * currentMomentum.y);
                    const initialMomentumMagnitude = Math.sqrt(initialMomentum.x * initialMomentum.x + initialMomentum.y * initialMomentum.y);
                    
                    // 计算质心
                    const totalMass = balls.reduce((sum, ball) => sum + ball.mass, 0);
                    const cmVx = currentMomentum.x / totalMass;
                    const cmVy = currentMomentum.y / totalMass;

                    document.getElementById('mechanics-info').innerHTML = `
                        <strong>碰撞实验分析:</strong><br>
                        时间: ${time.toFixed(2)}s<br>
                        <strong>球体1:</strong> v = ${Math.sqrt(balls[0].vx*balls[0].vx + balls[0].vy*balls[0].vy).toFixed(2)} m/s<br>
                        <strong>球体2:</strong> v = ${Math.sqrt(balls[1].vx*balls[1].vx + balls[1].vy*balls[1].vy).toFixed(2)} m/s<br>
                        <strong>守恒定律验证:</strong><br>
                        动量守恒: ${((Math.abs(momentumMagnitude - initialMomentumMagnitude) < 0.1) ? '✓' : '✗')}<br>
                        初始动量: ${initialMomentumMagnitude.toFixed(3)} kg⋅m/s<br>
                        当前动量: ${momentumMagnitude.toFixed(3)} kg⋅m/s<br>
                        <strong>能量分析:</strong><br>
                        初始动能: ${initialKE.toFixed(3)} J<br>
                        当前动能: ${currentKE.toFixed(3)} J<br>
                        能量损失: ${((initialKE - currentKE) / initialKE * 100).toFixed(1)}%<br>
                        <strong>质心运动:</strong><br>
                        质心速度: (${cmVx.toFixed(2)}, ${cmVy.toFixed(2)}) m/s<br>
                        恢复系数: ${e}
                    `;

                    time += dt;
                    this.animations.mechanics = requestAnimationFrame(animate);
                };

                animate();
            }

            drawLabFrame(ctx, canvas) {
                // 绘制实验室坐标系网格
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                for (let x = 0; x <= canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // 绘制坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.moveTo(50, 0);
                ctx.lineTo(50, canvas.height);
                ctx.stroke();

                // 坐标轴标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('实验室坐标系', canvas.width / 2, 20);
                ctx.fillText('x', canvas.width - 20, canvas.height / 2 - 10);
                ctx.fillText('y', 60, 20);
            }

            drawCenterOfMassFrame(ctx, canvas, balls) {
                // 计算质心位置
                const totalMass = balls.reduce((sum, ball) => sum + ball.mass, 0);
                const cmX = balls.reduce((sum, ball) => sum + ball.mass * ball.x, 0) / totalMass;
                const cmY = balls.reduce((sum, ball) => sum + ball.mass * ball.y, 0) / totalMass;

                // 绘制质心
                ctx.fillStyle = '#ff6b35';
                ctx.strokeStyle = '#cc4400';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cmX, cmY, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // 质心标签
                ctx.fillStyle = '#cc4400';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CM', cmX, cmY - 15);

                // 绘制质心坐标系（相对于质心的虚线）
                ctx.strokeStyle = 'rgba(255, 107, 53, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(cmX - 100, cmY);
                ctx.lineTo(cmX + 100, cmY);
                ctx.moveTo(cmX, cmY - 50);
                ctx.lineTo(cmX, cmY + 50);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            handleCollisions(balls, restitution, ctx) {
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        const ball1 = balls[i];
                        const ball2 = balls[j];
                        
                        const dx = ball2.x - ball1.x;
                        const dy = ball2.y - ball1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < ball1.radius + ball2.radius) {
                            // 碰撞检测成功，进行2D弹性碰撞计算
                            
                            // 单位法向量
                            const nx = dx / distance;
                            const ny = dy / distance;
                            
                            // 单位切向量
                            const tx = -ny;
                            const ty = nx;
                            
                            // 投影速度到法向和切向
                            const v1n = ball1.vx * nx + ball1.vy * ny;
                            const v1t = ball1.vx * tx + ball1.vy * ty;
                            const v2n = ball2.vx * nx + ball2.vy * ny;
                            const v2t = ball2.vx * tx + ball2.vy * ty;
                            
                            // 2D弹性碰撞公式
                            const v1nNew = ((ball1.mass - restitution * ball2.mass) * v1n + 
                                           ball2.mass * (1 + restitution) * v2n) / (ball1.mass + ball2.mass);
                            const v2nNew = ((ball2.mass - restitution * ball1.mass) * v2n + 
                                           ball1.mass * (1 + restitution) * v1n) / (ball1.mass + ball2.mass);
                            
                            // 切向速度保持不变
                            const v1tNew = v1t;
                            const v2tNew = v2t;
                            
                            // 转换回直角坐标系
                            ball1.vx = v1nNew * nx + v1tNew * tx;
                            ball1.vy = v1nNew * ny + v1tNew * ty;
                            ball2.vx = v2nNew * nx + v2tNew * tx;
                            ball2.vy = v2nNew * ny + v2tNew * ty;
                            
                            // 分离重叠的球体
                            const overlap = ball1.radius + ball2.radius - distance;
                            ball1.x -= overlap * 0.5 * nx;
                            ball1.y -= overlap * 0.5 * ny;
                            ball2.x += overlap * 0.5 * nx;
                            ball2.y += overlap * 0.5 * ny;
                            
                            // 碰撞特效
                            this.createCollisionEffect(ctx, (ball1.x + ball2.x) / 2, (ball1.y + ball2.y) / 2);
                        }
                    }
                }
            }

            drawTrail(ctx, trail, color) {
                if (trail.length < 2) return;
                
                ctx.strokeStyle = color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                
                trail.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
            }

            drawCollisionBall(ctx, ball) {
                // 主体球
                const gradient = ctx.createRadialGradient(
                    ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0,
                    ball.x, ball.y, ball.radius
                );
                gradient.addColorStop(0, ball.color.replace('44', '88'));
                gradient.addColorStop(1, ball.color);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                ctx.fill();

                // 边框
                ctx.strokeStyle = ball.color.replace('44', '22');
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                ctx.stroke();

                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.2, 0, 2 * Math.PI);
                ctx.fill();

                // 球体标签
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${ball.id}`, ball.x, ball.y + 4);
                ctx.fillText(`${ball.mass}kg`, ball.x, ball.y + ball.radius + 15);
            }

            drawVelocityVector2D(ctx, ball) {
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (speed < 0.1) return;
                
                const scale = 20;
                const vx = ball.vx * scale;
                const vy = ball.vy * scale;
                
                // 速度矢量
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + vx, ball.y + vy);
                ctx.stroke();
                
                // 箭头
                const angle = Math.atan2(vy, vx);
                this.drawArrowHead(ctx, ball.x + vx, ball.y + vy, angle, '#00ff88');
                
                // 速度分量
                ctx.strokeStyle = '#88ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                
                // x分量
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + vx, ball.y);
                ctx.stroke();
                
                // y分量
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x, ball.y + vy);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 速度标签
                ctx.fillStyle = '#006644';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`v=${speed.toFixed(1)}m/s`, ball.x + vx + 5, ball.y + vy - 5);
                ctx.fillText(`vₓ=${ball.vx.toFixed(1)}`, ball.x + vx + 5, ball.y + 10);
                ctx.fillText(`vᵧ=${ball.vy.toFixed(1)}`, ball.x - 40, ball.y + vy);
            }

            drawMomentumAnalysis(ctx, canvas, balls, initialMomentum) {
                const plotX = canvas.width - 250;
                const plotY = 50;
                const plotWidth = 200;
                const plotHeight = 150;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('动量分析', plotX + plotWidth/2, plotY + 20);
                
                // 计算当前总动量
                const currentMomentum = {
                    x: balls.reduce((sum, ball) => sum + ball.mass * ball.vx, 0),
                    y: balls.reduce((sum, ball) => sum + ball.mass * ball.vy, 0)
                };
                
                const scale = 5;
                const centerX = plotX + plotWidth/2;
                const centerY = plotY + plotHeight/2 + 20;
                
                // 绘制坐标轴
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(plotX + 20, centerY);
                ctx.lineTo(plotX + plotWidth - 20, centerY);
                ctx.moveTo(centerX, plotY + 30);
                ctx.lineTo(centerX, plotY + plotHeight - 20);
                ctx.stroke();
                
                // 初始动量矢量
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + initialMomentum.x * scale, centerY - initialMomentum.y * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, centerX + initialMomentum.x * scale, centerY - initialMomentum.y * scale,
                                  Math.atan2(-initialMomentum.y, initialMomentum.x), '#ff6b35');
                
                // 当前动量矢量
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + currentMomentum.x * scale, centerY - currentMomentum.y * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, centerX + currentMomentum.x * scale, centerY - currentMomentum.y * scale,
                                  Math.atan2(-currentMomentum.y, currentMomentum.x), '#4361ee');
                
                // 图例
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ff6b35';
                ctx.fillText('初始动量', plotX + 10, plotY + plotHeight - 25);
                ctx.fillStyle = '#4361ee';
                ctx.fillText('当前动量', plotX + 10, plotY + plotHeight - 10);
            }

            drawPendulumBob(ctx, x, y, angularVelocity) {
                // 主体摆球
                const radius = 20;
                const gradient = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, radius);
                gradient.addColorStop(0, '#88ccff');
                gradient.addColorStop(1, '#4361ee');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // 运动轨迹效果
                const speed = Math.abs(angularVelocity);
                ctx.fillStyle = `rgba(67, 97, 238, ${Math.min(0.3, speed * 0.1)})`;
                ctx.beginPath();
                ctx.arc(x - angularVelocity * 10, y, radius * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#2c5aa0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x - 6, y - 6, 6, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawPendulumTrajectory(ctx, centerX, centerY, length, currentAngle) {
                // 绘制摆动轨迹弧线
                ctx.strokeStyle = 'rgba(67, 97, 238, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, length, -Math.PI/3, Math.PI/3);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 当前位置标记
                const x = centerX + length * Math.sin(currentAngle);
                const y = centerY + length * Math.cos(currentAngle);
                ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity) {
                const scale = 20;
                const mass = 1; // kg
                
                // 重力
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX, bobY + gravity * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX, bobY + gravity * scale, Math.PI/2, '#ff4444');
                
                // 张力
                const tension = gravity * Math.cos(angle);
                ctx.strokeStyle = '#44ff44';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX - tension * scale * Math.sin(angle), bobY - tension * scale * Math.cos(angle));
                ctx.stroke();
                this.drawArrowHead(ctx, bobX - tension * scale * Math.sin(angle), bobY - tension * scale * Math.cos(angle), -angle - Math.PI/2, '#44ff44');
                
                // 切向力
                const tangentialForce = gravity * Math.sin(angle);
                ctx.strokeStyle = '#4444ff';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX + tangentialForce * scale * Math.cos(angle), bobY + tangentialForce * scale * Math.sin(angle));
                ctx.stroke();
                this.drawArrowHead(ctx, bobX + tangentialForce * scale * Math.cos(angle), bobY + tangentialForce * scale * Math.sin(angle), angle, '#4444ff');
                
                // 力的标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('mg', bobX + 5, bobY + gravity * scale + 15);
                ctx.fillText('T', bobX - tension * scale * Math.sin(angle) - 15, bobY - tension * scale * Math.cos(angle));
                ctx.fillText('F_t', bobX + tangentialForce * scale * Math.cos(angle) + 5, bobY + tangentialForce * scale * Math.sin(angle));
            }

            drawAngularVelocity(ctx, canvas, bobX, bobY, angularVelocity, length) {
                if (Math.abs(angularVelocity) < 0.01) return;
                
                const scale = 50;
                const velocityMagnitude = Math.abs(angularVelocity) * length;
                
                // 线速度矢量（切向）
                const angle = Math.atan2(bobY - 100, bobX - canvas.width/2) + Math.PI/2;
                const vx = velocityMagnitude * scale * Math.cos(angle) * (angularVelocity > 0 ? 1 : -1);
                const vy = velocityMagnitude * scale * Math.sin(angle) * (angularVelocity > 0 ? 1 : -1);
                
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX + vx, bobY + vy);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX + vx, bobY + vy, Math.atan2(vy, vx), '#ff6b35');
                
                // 速度标签
                ctx.fillStyle = '#ff6b35';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`v=${velocityMagnitude.toFixed(2)}m/s`, bobX + vx + 5, bobY + vy - 5);
                ctx.fillText(`ω=${angularVelocity.toFixed(3)}rad/s`, bobX + 25, bobY - 25);
            }

            drawPhasePortrait(ctx, canvas, phaseData) {
                if (phaseData.length < 2) return;
                
                const plotX = canvas.width - 200;
                const plotY = 50;
                const plotWidth = 150;
                const plotHeight = 150;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 坐标轴
                ctx.strokeStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(plotX + plotWidth/2, plotY);
                ctx.lineTo(plotX + plotWidth/2, plotY + plotHeight);
                ctx.moveTo(plotX, plotY + plotHeight/2);
                ctx.lineTo(plotX + plotWidth, plotY + plotHeight/2);
                ctx.stroke();
                
                // 相位轨迹
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                phaseData.forEach((point, index) => {
                    const x = plotX + plotWidth/2 + point.angle * plotWidth/4;
                    const y = plotY + plotHeight/2 - point.velocity * plotHeight/10;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('相位图', plotX + plotWidth/2, plotY - 5);
                ctx.font = '10px Arial';
                ctx.fillText('θ', plotX + plotWidth - 10, plotY + plotHeight - 5);
                ctx.fillText('ω', plotX + 5, plotY + 10);
            }

            drawEnergyPlot(ctx, canvas, energyData, currentTime) {
                if (energyData.length < 2) return;
                
                const plotX = canvas.width - 200;
                const plotY = 220;
                const plotWidth = 150;
                const plotHeight = 100;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 找到最大能量值用于缩放
                const maxEnergy = Math.max(...energyData.map(d => Math.max(d.ke, d.pe, d.total)));
                
                // 绘制能量曲线
                const drawEnergyLine = (data, color, property) => {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    data.forEach((point, index) => {
                        const x = plotX + (index / data.length) * plotWidth;
                        const y = plotY + plotHeight - (point[property] / maxEnergy) * plotHeight;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                };
                
                drawEnergyLine(energyData, '#ff4444', 'ke');  // 动能
                drawEnergyLine(energyData, '#44ff44', 'pe');  // 势能
                drawEnergyLine(energyData, '#4444ff', 'total'); // 总能量
                
                // 图例
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ff4444';
                ctx.fillText('动能', plotX + 5, plotY + 15);
                ctx.fillStyle = '#44ff44';
                ctx.fillText('势能', plotX + 5, plotY + 30);
                ctx.fillStyle = '#4444ff';
                ctx.fillText('总能量', plotX + 5, plotY + 45);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('能量-时间图', plotX + plotWidth/2, plotY - 5);
            }

            calculatePeriod(angle, angularVelocity, currentTime) {
                // 简化的周期计算（通过零点检测）
                if (!this.lastZeroCrossing) this.lastZeroCrossing = 0;
                
                if (Math.abs(angle) < 0.01 && angularVelocity > 0) {
                    const period = currentTime - this.lastZeroCrossing;
                    this.lastZeroCrossing = currentTime;
                    return period > 0.5 ? period : 0; // 过滤噪声
                }
                return 0;
            }

            // 电磁学模拟函数

            simulateRefraction() {
                const canvas = this.canvases.optics;
                const ctx = this.contexts.optics;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const incidentAngle = parseFloat(document.getElementById('incident-angle').value) * Math.PI / 180;
                const n1 = parseFloat(document.getElementById('refractive-index-1').value);
                const n2 = parseFloat(document.getElementById('refractive-index-2').value);

                // 计算折射角 (斯涅尔定律)
                const sinRefracted = (n1 / n2) * Math.sin(incidentAngle);
                const refractedAngle = Math.asin(Math.min(1, Math.abs(sinRefracted)));

                // 绘制界面
                ctx.fillStyle = 'rgba(67, 97, 238, 0.1)';
                ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();

                // 绘制法线
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 100);
                ctx.lineTo(canvas.width / 2, canvas.height - 100);
                ctx.stroke();
                ctx.setLineDash([]);

                // 绘制入射光线
                const incidentX = canvas.width / 2 - 150 * Math.sin(incidentAngle);
                const incidentY = canvas.height / 2 - 150 * Math.cos(incidentAngle);
                
                ctx.strokeStyle = '#ffeb3b';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(incidentX, incidentY);
                ctx.lineTo(canvas.width / 2, canvas.height / 2);
                ctx.stroke();

                // 绘制折射光线
                if (sinRefracted <= 1) {
                    const refractedX = canvas.width / 2 + 150 * Math.sin(refractedAngle);
                    const refractedY = canvas.height / 2 + 150 * Math.cos(refractedAngle);
                    
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, canvas.height / 2);
                    ctx.lineTo(refractedX, refractedY);
                    ctx.stroke();
                }

                // 更新信息
                document.getElementById('optics-info').innerHTML = `
                    入射角: ${(incidentAngle * 180 / Math.PI).toFixed(1)}°<br>
                    折射角: ${sinRefracted <= 1 ? (refractedAngle * 180 / Math.PI).toFixed(1) + '°' : '全反射'}<br>
                    n₁ = ${n1}, n₂ = ${n2}<br>
                    ${sinRefracted > 1 ? '发生全反射！' : ''}
                `;
            }

            resetOpticsSimulation() {
                this.isRunning.optics = false;
                this.contexts.optics.clearRect(0, 0, this.canvases.optics.width, this.canvases.optics.height);
                document.getElementById('optics-info').textContent = '调整参数观察光线传播规律';
            }

            setupWavesControls() {
                const startBtn = document.getElementById('start-waves');
                const resetBtn = document.getElementById('reset-waves');
                const pauseBtn = document.getElementById('pause-waves');

                if (document.getElementById('wave-frequency')) {
                    document.getElementById('wave-frequency').addEventListener('input', (e) => {
                        document.getElementById('frequency-value').textContent = e.target.value;
                        this.updateWaveInfo();
                    });
                }

                if (document.getElementById('wave-amplitude')) {
                    document.getElementById('wave-amplitude').addEventListener('input', (e) => {
                        document.getElementById('amplitude-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('wave-speed')) {
                    document.getElementById('wave-speed').addEventListener('input', (e) => {
                        document.getElementById('wave-speed-value').textContent = e.target.value;
                        this.updateWaveInfo();
                    });
                }

                if (startBtn) startBtn.addEventListener('click', () => this.startWavesSimulation());
                if (resetBtn) resetBtn.addEventListener('click', () => this.resetWavesSimulation());
                if (pauseBtn) pauseBtn.addEventListener('click', () => this.pauseWavesSimulation());

                this.updateWaveInfo();
            }

            updateWaveInfo() {
                const frequencyEl = document.getElementById('wave-frequency');
                const speedEl = document.getElementById('wave-speed');
                const wavelengthEl = document.getElementById('wavelength');
                const periodEl = document.getElementById('period');

                if (frequencyEl && speedEl && wavelengthEl && periodEl) {
                    const frequency = parseFloat(frequencyEl.value);
                    const speed = parseFloat(speedEl.value);
                    const wavelength = speed / frequency;
                    const period = 1 / frequency;

                    wavelengthEl.textContent = wavelength.toFixed(1) + 'm';
                    periodEl.textContent = period.toFixed(2) + 's';
                }
            }

            startWavesSimulation() {
                this.isRunning.waves = true;
                this.simulateWaves();
            }

            simulateWaves() {
                const canvas = this.canvases.waves;
                const ctx = this.contexts.waves;
                
                const frequency = parseFloat(document.getElementById('wave-frequency').value);
                const amplitude = parseFloat(document.getElementById('wave-amplitude').value);
                const speed = parseFloat(document.getElementById('wave-speed').value);
                const type = document.getElementById('wave-type').value;

                let time = 0;
                const wavelength = speed / frequency;
                const period = 1 / frequency;
                const omega = 2 * Math.PI * frequency;
                const k = 2 * Math.PI / wavelength;
                const dt = 0.02;
                
                // Initialize wave data storage
                let waveHistory = [];
                let particleData = [];
                let energyData = [];
                
                // Create particle array for wave motion
                for (let i = 0; i < 100; i++) {
                    particleData.push({
                        x: i * (canvas.width / 100),
                        y: canvas.height / 2,
                        equilibriumY: canvas.height / 2,
                        velocity: 0,
                        displacement: 0
                    });
                }

                const animate = () => {
                    if (!this.isRunning.waves) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制增强的坐标系和网格
                    this.drawAdvancedWaveGrid(ctx, canvas, wavelength, amplitude);

                    if (type === 'transverse') {
                        this.drawAdvancedTransverseWave(ctx, canvas, amplitude, k, omega, time, particleData);
                    } else if (type === 'longitudinal') {
                        this.drawAdvancedLongitudinalWave(ctx, canvas, amplitude, k, omega, time, particleData);
                    } else if (type === 'standing') {
                        this.drawAdvancedStandingWave(ctx, canvas, amplitude, k, omega, time);
                    } else if (type === 'interference') {
                        this.drawAdvancedWaveInterference(ctx, canvas, amplitude, k, omega, time);
                    }

                    // 绘制高级波形分析
                    this.drawWaveformAnalysis(ctx, canvas, frequency, amplitude, speed, wavelength, period, time);

                    // 绘制粒子运动轨迹和速度矢量
                    this.drawParticleMotionAnalysis(ctx, canvas, type, amplitude, k, omega, time, particleData);

                    // 绘制能量密度和传播
                    this.drawWaveEnergyAnalysis(ctx, canvas, type, amplitude, k, omega, time);

                    // 绘制频谱和波包分析
                    this.drawFrequencySpectrumAnalysis(ctx, canvas, frequency, amplitude, time);

                    // 绘制波的干涉和衍射效应
                    this.drawWaveInterferenceEffects(ctx, canvas, wavelength, amplitude, time);

                    // 存储波形历史数据
                    if (time % 0.1 < dt) {
                        waveHistory.push({
                            time: time,
                            amplitude: amplitude,
                            frequency: frequency,
                            energy: 0.5 * amplitude * amplitude * omega * omega
                        });
                        if (waveHistory.length > 200) waveHistory.shift();
                    }

                    // 实时更新高级波动物理量
                    const instantaneousPower = 0.5 * amplitude * amplitude * omega * omega * speed;
                    const energyDensity = 0.5 * amplitude * amplitude * omega * omega;
                    const intensity = energyDensity * speed;
                    const impedance = Math.sqrt(1.0); // 简化阻抗
                    const phaseVelocity = speed;
                    const groupVelocity = speed; // 对于非色散介质

                    document.getElementById('waves-info').innerHTML = `
                        <strong>高级波动分析:</strong><br>
                        频率: ${frequency.toFixed(3)} Hz<br>
                        波长: ${wavelength.toFixed(2)} m<br>
                        周期: ${period.toFixed(3)} s<br>
                        相速度: ${phaseVelocity.toFixed(1)} m/s<br>
                        群速度: ${groupVelocity.toFixed(1)} m/s<br>
                        振幅: ${amplitude.toFixed(1)} 单位<br>
                        <strong>能量与功率分析:</strong><br>
                        瞬时功率: ${instantaneousPower.toFixed(3)} W<br>
                        能量密度: ${energyDensity.toFixed(3)} J/m³<br>
                        波强度: ${intensity.toFixed(3)} W/m²<br>
                        波阻抗: ${impedance.toFixed(3)} Ω<br>
                        <strong>波动现象:</strong><br>
                        • 波的叠加原理<br>
                        • 驻波的节点和反节点<br>
                        • 干涉和衍射效应<br>
                        • 多普勒效应<br>
                        • 波的反射和透射<br>
                        • 能量传播分析<br>
                        <strong>数学描述:</strong><br>
                        y = A sin(kx - ωt + φ)<br>
                        k = 2π/λ = ${k.toFixed(3)} rad/m<br>
                        ω = 2πf = ${omega.toFixed(3)} rad/s<br>
                        相位: φ = ${(k * 0 - omega * time).toFixed(2)} rad
                    `;

                    time += dt;
                    this.animations.waves = requestAnimationFrame(animate);
                };

                animate();
            }

            drawAdvancedWaveGrid(ctx, canvas, wavelength, amplitude) {
                // 绘制精密网格系统
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([1, 3]);
                
                const scale = 50; // 像素每单位长度
                const waveScale = Math.max(20, wavelength * 2);
                
                // 垂直网格线（每个波长标记）
                for (let x = 0; x <= canvas.width; x += waveScale) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // 水平网格线（每个振幅标记）
                const ampScale = Math.max(20, amplitude);
                for (let y = canvas.height/2 - 3*ampScale; y <= canvas.height/2 + 3*ampScale; y += ampScale) {
                    if (y > 0 && y < canvas.height) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                }
                ctx.setLineDash([]);

                // 绘制主坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // X轴（传播方向）
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                // Y轴（振动方向）
                ctx.moveTo(50, 50);
                ctx.lineTo(50, canvas.height - 50);
                ctx.stroke();

                // 坐标轴标签和刻度
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                
                // X轴标签（距离/波长）
                for (let i = 1; i <= 5; i++) {
                    const x = i * waveScale;
                    if (x < canvas.width - 20) {
                        ctx.fillText(`${i}λ`, x, canvas.height / 2 + 20);
                        // 刻度线
                        ctx.beginPath();
                        ctx.moveTo(x, canvas.height / 2 - 5);
                        ctx.lineTo(x, canvas.height / 2 + 5);
                        ctx.stroke();
                    }
                }
                
                // Y轴标签（振幅）
                ctx.textAlign = 'right';
                ctx.fillText('+A', 45, canvas.height / 2 - amplitude - 5);
                ctx.fillText('-A', 45, canvas.height / 2 + amplitude + 15);
                ctx.fillText('0', 45, canvas.height / 2 + 5);
                
                // 轴标题
                ctx.textAlign = 'center';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('位移 (m)', 25, 30);
                ctx.fillText('传播方向 →', canvas.width / 2, canvas.height - 10);
            }

            drawPendulumBob(ctx, x, y, angularVelocity) {
                // 主体摆球
                const radius = 20;
                const gradient = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, radius);
                gradient.addColorStop(0, '#88ccff');
                gradient.addColorStop(1, '#4361ee');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // 运动轨迹效果
                const speed = Math.abs(angularVelocity);
                ctx.fillStyle = `rgba(67, 97, 238, ${Math.min(0.3, speed * 0.1)})`;
                ctx.beginPath();
                ctx.arc(x - angularVelocity * 10, y, radius * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#2c5aa0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x - 6, y - 6, 6, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawPendulumTrajectory(ctx, centerX, centerY, length, currentAngle) {
                // 绘制摆动轨迹弧线
                ctx.strokeStyle = 'rgba(67, 97, 238, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, length, -Math.PI/3, Math.PI/3);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 当前位置标记
                const x = centerX + length * Math.sin(currentAngle);
                const y = centerY + length * Math.cos(currentAngle);
                ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity) {
                const scale = 20;
                const mass = 1; // kg
                
                // 重力
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX, bobY + gravity * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX, bobY + gravity * scale, Math.PI/2, '#ff4444');
                
                // 张力
                const tension = gravity * Math.cos(angle);
                ctx.strokeStyle = '#44ff44';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX - tension * scale * Math.sin(angle), bobY - tension * scale * Math.cos(angle));
                ctx.stroke();
                this.drawArrowHead(ctx, bobX - tension * scale * Math.sin(angle), bobY - tension * scale * Math.cos(angle), -angle - Math.PI/2, '#44ff44');
                
                // 切向力
                const tangentialForce = gravity * Math.sin(angle);
                ctx.strokeStyle = '#4444ff';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX + tangentialForce * scale * Math.cos(angle), bobY + tangentialForce * scale * Math.sin(angle));
                ctx.stroke();
                this.drawArrowHead(ctx, bobX + tangentialForce * scale * Math.cos(angle), bobY + tangentialForce * scale * Math.sin(angle), angle, '#4444ff');
                
                // 力的标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('mg', bobX + 5, bobY + gravity * scale + 15);
                ctx.fillText('T', bobX - tension * scale * Math.sin(angle) - 15, bobY - tension * scale * Math.cos(angle));
                ctx.fillText('F_t', bobX + tangentialForce * scale * Math.cos(angle) + 5, bobY + tangentialForce * scale * Math.sin(angle));
            }

            simulateLens() {
                const canvas = this.canvases.optics;
                const ctx = this.contexts.optics;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const focalLength = parseFloat(document.getElementById('focal-length').value);
                const objectDistance = parseFloat(document.getElementById('object-distance').value);
                const lensType = document.getElementById('lens-type').value;

                const lensX = canvas.width / 2;
                const scale = 5; // 像素/cm

                // 绘制透镜
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 4;
                if (lensType === 'convex') {
                    // 凸透镜
                    ctx.beginPath();
                    ctx.arc(lensX - 20, canvas.height / 2, 100, -Math.PI/6, Math.PI/6);
                    ctx.arc(lensX + 20, canvas.height / 2, 100, Math.PI - Math.PI/6, Math.PI + Math.PI/6);
                    ctx.stroke();
                } else {
                    // 凹透镜
                    ctx.beginPath();
                    ctx.arc(lensX + 60, canvas.height / 2, 100, Math.PI - Math.PI/6, Math.PI + Math.PI/6);
                    ctx.arc(lensX - 60, canvas.height / 2, 100, -Math.PI/6, Math.PI/6);
                    ctx.stroke();
                }

                // 绘制光轴
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(50, canvas.height / 2);
                ctx.lineTo(canvas.width - 50, canvas.height / 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // 绘制物体
                const objectX = lensX - objectDistance * scale;
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(objectX, canvas.height / 2);
                ctx.lineTo(objectX, canvas.height / 2 - 40);
                ctx.stroke();

                // 计算像距
                let imageDistance;
                if (lensType === 'convex') {
                    imageDistance = (focalLength * objectDistance) / (objectDistance - focalLength);
                } else {
                    imageDistance = -(focalLength * objectDistance) / (objectDistance + focalLength);
                }

                if (isFinite(imageDistance)) {
                    const imageX = lensX + imageDistance * scale;
                    const magnification = -imageDistance / objectDistance;
                    
                    // 绘制像
                    ctx.strokeStyle = magnification > 0 ? '#4361ee' : '#ff4444';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(imageX, canvas.height / 2);
                    ctx.lineTo(imageX, canvas.height / 2 - 40 * magnification);
                    ctx.stroke();

                    document.getElementById('optics-info').innerHTML = `
                        物距: ${objectDistance}cm<br>
                        焦距: ${focalLength}cm<br>
                        像距: ${imageDistance.toFixed(1)}cm<br>
                        放大倍数: ${magnification.toFixed(2)}<br>
                        像的性质: ${magnification > 0 ? '正立' : '倒立'}，${Math.abs(magnification) > 1 ? '放大' : '缩小'}
                    `;
                } else {
                    document.getElementById('optics-info').innerHTML = `
                        物距: ${objectDistance}cm<br>
                        焦距: ${focalLength}cm<br>
                        无法成像（物体在焦点上）
                    `;
                }
            }

            simulateInterference() {
                const canvas = this.canvases.optics;
                const ctx = this.contexts.optics;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const wavelength = parseFloat(document.getElementById('light-wavelength').value);
                const slitSpacing = parseFloat(document.getElementById('slit-spacing').value);
                const screenDistance = parseFloat(document.getElementById('screen-distance').value);

                // 绘制双缝
                const slitX = 200;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(slitX, 100);
                ctx.lineTo(slitX, canvas.height / 2 - 30);
                ctx.moveTo(slitX, canvas.height / 2 + 30);
                ctx.lineTo(slitX, canvas.height - 100);
                ctx.stroke();

                // 绘制屏幕
                const screenX = slitX + screenDistance * 100;
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(screenX, 100);
                ctx.lineTo(screenX, canvas.height - 100);
                ctx.stroke();

                // 计算干涉条纹
                const k = 2 * Math.PI / wavelength;
                const slitSeparation = slitSpacing / 1000; // 转换为mm

                // 绘制干涉条纹
                for (let y = 100; y < canvas.height - 100; y += 2) {
                    const screenY = y - canvas.height / 2;
                    const pathDiff = slitSeparation * screenY / (screenDistance * 1000);
                    const phase = k * pathDiff;
                    const intensity = Math.pow(Math.cos(phase / 2), 2);
                    
                    const brightness = Math.floor(255 * intensity);
                    ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                    ctx.fillRect(screenX - 5, y, 10, 2);
                }

                document.getElementById('optics-info').innerHTML = `
                    波长: ${wavelength}nm<br>
                    缝间距: ${slitSpacing}μm<br>
                    屏幕距离: ${screenDistance}m<br>
                    观察到明暗相间的干涉条纹
                `;
            }

            drawAdvancedStandingWave(ctx, canvas, amplitude, k, omega, time) {
                // 绘制驻波的包络线
                ctx.strokeStyle = 'rgba(255, 107, 53, 0.4)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                // 上包络线
                for (let x = 0; x <= canvas.width; x += 2) {
                    const envelope = amplitude * Math.abs(Math.sin(k * x / 10));
                    const y = canvas.height / 2 - envelope;
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                // 下包络线
                for (let x = canvas.width; x >= 0; x -= 2) {
                    const envelope = amplitude * Math.abs(Math.sin(k * x / 10));
                    const y = canvas.height / 2 + envelope;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 绘制实时驻波
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 4;
                ctx.beginPath();
                
                for (let x = 0; x <= canvas.width; x += 2) {
                    const envelope = amplitude * Math.abs(Math.sin(k * x / 10));
                    const y = canvas.height / 2 + envelope * Math.cos(omega * time);
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 标记节点和反节点
                const nodeSpacing = Math.PI / k * 10;
                
                // 节点（振幅为零的点）
                ctx.fillStyle = '#e74c3c';
                for (let i = 0; i <= canvas.width / nodeSpacing; i++) {
                    const x = i * nodeSpacing;
                    if (x > 0 && x < canvas.width) {
                        ctx.beginPath();
                        ctx.arc(x, canvas.height / 2, 8, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // 节点标签
                        ctx.fillStyle = '#333';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('节点', x, canvas.height / 2 + 25);
                        ctx.fillText(`N${i}`, x, canvas.height / 2 + 40);
                        ctx.fillStyle = '#e74c3c';
                    }
                }
                
                // 反节点（振幅最大的点）
                ctx.fillStyle = '#3498db';
                for (let i = 0; i <= canvas.width / nodeSpacing; i++) {
                    const x = (i + 0.5) * nodeSpacing;
                    if (x > 0 && x < canvas.width) {
                        const envelope = amplitude * Math.abs(Math.sin(k * x / 10));
                        const y = canvas.height / 2 + envelope * Math.cos(omega * time);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // 反节点标签
                        ctx.fillStyle = '#333';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('反节点', x, canvas.height / 2 - 30);
                        ctx.fillText(`A${i}`, x, canvas.height / 2 - 15);
                        
                        // 振幅指示器
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(x, canvas.height / 2 - envelope);
                        ctx.lineTo(x, canvas.height / 2 + envelope);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#3498db';
                    }
                }
                
                // 绘制驻波分析图
                this.drawStandingWaveAnalysis(ctx, canvas, amplitude, k, omega, time);
            }

            drawStandingWaveAnalysis(ctx, canvas, amplitude, k, omega, time) {
                const analysisX = 20;
                const analysisY = 20;
                const analysisWidth = 200;
                const analysisHeight = 120;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(analysisX, analysisY, analysisWidth, analysisHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(analysisX, analysisY, analysisWidth, analysisHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('驻波分析', analysisX + analysisWidth / 2, analysisY + 15);
                
                // 绘制振幅分布
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = 0; x < analysisWidth; x += 2) {
                    const position = x / analysisWidth * canvas.width;
                    const envelope = amplitude * Math.abs(Math.sin(k * position / 10));
                    const y = analysisY + analysisHeight - 20 - (envelope / amplitude) * 60;
                    
                    if (x === 0) {
                        ctx.moveTo(analysisX + x, y);
                    } else {
                        ctx.lineTo(analysisX + x, y);
                    }
                }
                ctx.stroke();
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('振幅包络', analysisX + 5, analysisY + 35);
                ctx.fillText('节点间距: λ/2', analysisX + 5, analysisY + 50);
                ctx.fillText('反节点振幅: 2A', analysisX + 5, analysisY + 65);
                ctx.fillText('相位关系: 原地振动', analysisX + 5, analysisY + 80);
                
                // 绘制能量分布
                ctx.fillStyle = 'rgba(52, 152, 219, 0.3)';
                for (let x = 0; x < analysisWidth; x += 4) {
                    const position = x / analysisWidth * canvas.width;
                    const envelope = amplitude * Math.abs(Math.sin(k * position / 10));
                    const energy = envelope * envelope;
                    const height = (energy / (amplitude * amplitude)) * 20;
                    ctx.fillRect(analysisX + x, analysisY + analysisHeight - 20, 3, -height);
                }
            }

            drawAdvancedWaveInterference(ctx, canvas, amplitude, k, omega, time) {
                // 双源干涉
                const source1X = canvas.width * 0.2;
                const source1Y = canvas.height * 0.4;
                const source2X = canvas.width * 0.2;
                const source2Y = canvas.height * 0.6;
                const sourceSpacing = Math.abs(source2Y - source1Y);
                
                // 绘制干涉图样
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let x = 0; x < canvas.width; x += 2) {
                    for (let y = 0; y < canvas.height; y += 2) {
                        // 计算到两个源的距离
                        const r1 = Math.sqrt((x - source1X) * (x - source1X) + (y - source1Y) * (y - source1Y));
                        const r2 = Math.sqrt((x - source2X) * (x - source2X) + (y - source2Y) * (y - source2Y));
                        
                        // 计算相位差
                        const phase1 = k * r1 / 10 - omega * time;
                        const phase2 = k * r2 / 10 - omega * time;
                        const phaseDiff = phase2 - phase1;
                        
                        // 计算干涉强度
                        const wave1 = amplitude * Math.sin(phase1) / Math.max(1, r1 / 50);
                        const wave2 = amplitude * Math.sin(phase2) / Math.max(1, r2 / 50);
                        const resultant = wave1 + wave2;
                        
                        // 转换为颜色
                        const intensity = Math.abs(resultant);
                        const normalized = Math.min(255, intensity * 50);
                        
                        // 设置像素颜色
                        const index = (y * canvas.width + x) * 4;
                        if (index < data.length) {
                            data[index] = resultant > 0 ? normalized : 0;     // R
                            data[index + 1] = normalized * 0.5;               // G
                            data[index + 2] = resultant < 0 ? normalized : 0; // B
                            data[index + 3] = normalized;                     // A
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // 绘制波源
                ctx.fillStyle = '#ffeb3b';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                
                // 源1
                ctx.beginPath();
                ctx.arc(source1X, source1Y, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // 源2
                ctx.beginPath();
                ctx.arc(source2X, source2Y, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // 绘制同心圆表示波阵面
                this.drawWaveFronts(ctx, source1X, source1Y, k, omega, time, '#ff6b35');
                this.drawWaveFronts(ctx, source2X, source2Y, k, omega, time, '#4361ee');
                
                // 绘制干涉分析
                this.drawInterferenceAnalysis(ctx, canvas, sourceSpacing, k, amplitude);
                
                // 标记构造性和破坏性干涉区域
                this.markInterferenceRegions(ctx, canvas, source1X, source1Y, source2X, source2Y, k, omega, time);
            }

            drawWaveFronts(ctx, centerX, centerY, k, omega, time, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                
                const waveLength = 2 * Math.PI / k * 10;
                const phase = omega * time;
                
                for (let i = 1; i <= 5; i++) {
                    const radius = (i * waveLength + phase * 5) % (waveLength * 5);
                    if (radius > 10) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                }
                ctx.globalAlpha = 1;
            }

            drawInterferenceAnalysis(ctx, canvas, sourceSpacing, k, amplitude) {
                const analysisX = canvas.width - 180;
                const analysisY = 20;
                const analysisWidth = 160;
                const analysisHeight = 140;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(analysisX, analysisY, analysisWidth, analysisHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(analysisX, analysisY, analysisWidth, analysisHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('双缝干涉分析', analysisX + analysisWidth / 2, analysisY + 15);
                
                // 干涉条纹强度分布
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let y = 0; y < analysisHeight - 40; y += 2) {
                    const angle = (y - (analysisHeight - 40) / 2) / 100;
                    const pathDiff = sourceSpacing * Math.sin(angle);
                    const phase = k * pathDiff / 10;
                    const intensity = 4 * amplitude * amplitude * Math.cos(phase / 2) * Math.cos(phase / 2);
                    const x = (intensity / (4 * amplitude * amplitude)) * 60;
                    
                    if (y === 0) {
                        ctx.moveTo(analysisX + 20 + x, analysisY + 30 + y);
                    } else {
                        ctx.lineTo(analysisX + 20 + x, analysisY + 30 + y);
                    }
                }
                ctx.stroke();
                
                // 标签和公式
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('强度: I = 4I₀cos²(δ/2)', analysisX + 5, analysisY + analysisHeight - 25);
                ctx.fillText('相位差: δ = kd sinθ', analysisX + 5, analysisY + analysisHeight - 15);
                ctx.fillText('明纹: δ = 2nπ', analysisX + 5, analysisY + analysisHeight - 5);
            }

            markInterferenceRegions(ctx, canvas, x1, y1, x2, y2, k, omega, time) {
                // 标记特殊干涉线
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                // 零级明纹（等光程线）
                const midY = (y1 + y2) / 2;
                ctx.beginPath();
                ctx.moveTo(Math.max(x1, x2), midY);
                ctx.lineTo(canvas.width, midY);
                ctx.stroke();
                
                // 一级明纹线
                const wavelength = 2 * Math.PI / k * 10;
                const spacing = Math.abs(y2 - y1);
                const angle1 = Math.asin(wavelength / spacing);
                
                if (!isNaN(angle1)) {
                    // 上一级明纹
                    ctx.beginPath();
                    ctx.moveTo(Math.max(x1, x2), midY);
                    ctx.lineTo(canvas.width, midY - (canvas.width - Math.max(x1, x2)) * Math.tan(angle1));
                    ctx.stroke();
                    
                    // 下一级明纹
                    ctx.beginPath();
                    ctx.moveTo(Math.max(x1, x2), midY);
                    ctx.lineTo(canvas.width, midY + (canvas.width - Math.max(x1, x2)) * Math.tan(angle1));
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                
                // 标记明暗纹
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('0级明纹', canvas.width - 50, midY + 5);
                if (!isNaN(angle1)) {
                    ctx.fillText('±1级明纹', canvas.width - 50, midY - 30);
                }
            }

            calculateElectricField(x, y) {
                let Ex = 0, Ey = 0;
                const k = 8.99e9; // 库仑常数 (简化)
                
                this.electricCharges.forEach(charge => {
                    const dx = x - charge.x;
                    const dy = y - charge.y;
                    const r2 = dx * dx + dy * dy;
                    const r = Math.sqrt(r2);
                    
                    if (r > charge.radius) {
                        const E = k * Math.abs(charge.charge) / r2;
                        Ex += E * dx / r * Math.sign(charge.charge);
                        Ey += E * dy / r * Math.sign(charge.charge);
                    }
                });
                
                return { x: Ex, y: Ey };
            }

            calculateElectricPotential(x, y) {
                let potential = 0;
                const k = 8.99e9; // 库仑常数
                
                this.electricCharges.forEach(charge => {
                    const dx = x - charge.x;
                    const dy = y - charge.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    if (r > charge.radius) {
                        potential += k * charge.charge / r;
                    }
                });
                
                return potential;
            }

            drawElectricFieldAnalysis(ctx, canvas) {
                const analysisX = 20;
                const analysisY = 20;
                const analysisWidth = 250;
                const analysisHeight = 150;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(analysisX, analysisY, analysisWidth, analysisHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(analysisX, analysisY, analysisWidth, analysisHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('电场分析面板', analysisX + analysisWidth / 2, analysisY + 18);
                
                // 计算关键点的电场
                const centerField = this.calculateElectricField(canvas.width / 2, canvas.height / 2);
                const centerMagnitude = Math.sqrt(centerField.x ** 2 + centerField.y ** 2);
                const centerPotential = this.calculateElectricPotential(canvas.width / 2, canvas.height / 2);
                
                // 显示实时数据
                ctx.fillStyle = '#333';
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('中心点电场分析:', analysisX + 10, analysisY + 40);
                ctx.fillText(`电场强度: ${centerMagnitude.toFixed(2)} N/C`, analysisX + 10, analysisY + 55);
                ctx.fillText(`电势: ${centerPotential.toFixed(2)} V`, analysisX + 10, analysisY + 70);
                ctx.fillText(`场强方向: ${Math.atan2(centerField.y, centerField.x).toFixed(2)} rad`, analysisX + 10, analysisY + 85);
                
                // 绘制电场矢量图示
                const vectorX = analysisX + 180;
                const vectorY = analysisY + 60;
                const scale = 0.01;
                
                // 绘制坐标系
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(vectorX - 30, vectorY);
                ctx.lineTo(vectorX + 30, vectorY);
                ctx.moveTo(vectorX, vectorY - 30);
                ctx.lineTo(vectorX, vectorY + 30);
                ctx.stroke();
                
                // 绘制电场矢量
                if (centerMagnitude > 0.1) {
                    const vectorLength = Math.min(25, centerMagnitude * scale);
                    const endX = vectorX + centerField.x * scale;
                    const endY = vectorY - centerField.y * scale; // Y轴翻转
                    
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(vectorX, vectorY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    const angle = Math.atan2(-centerField.y, centerField.x);
                    this.drawArrowHead(ctx, endX, endY, angle, '#e74c3c');
                }
                
                // 标签
                ctx.fillStyle = '#666';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('E⃗', vectorX + 35, vectorY + 5);
                ctx.fillText('电场矢量图', vectorX, vectorY + 45);
                
                // 显示物理常数
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('物理常数:', analysisX + 10, analysisY + 105);
                ctx.fillText('k = 8.99×10⁹ N⋅m²/C²', analysisX + 10, analysisY + 120);
                ctx.fillText('ε₀ = 8.85×10⁻¹² C²/N⋅m²', analysisX + 10, analysisY + 135);
            }

            drawElectricPotentialDistribution(ctx, canvas) {
                // 简化实现，避免过长
                const plotX = canvas.width - 200;
                const plotY = 200;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, 180, 100);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(plotX, plotY, 180, 100);
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('电势分布', plotX + 90, plotY + 20);
            }

            drawGaussianSurfaceDemo(ctx, canvas) {
                // 简化实现
                const x = 20, y = 350;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(x, y, 150, 80);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(x, y, 150, 80);
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('高斯定律: ∮E⋅dA = Q/ε₀', x + 75, y + 40);
            }

            calculateElectrostaticEnergy() {
                return 1.0; // 简化返回
            }

            setupElectromagnetismControls() {
                const typeSelect = document.getElementById('em-type');
                const strengthSlider = document.getElementById('magnetic-strength');
                const currentSlider = document.getElementById('current');
                const wireShapeSelect = document.getElementById('wire-shape');
                const chargeSlider = document.getElementById('charge-strength');
                const startButton = document.getElementById('start-em');
                const resetButton = document.getElementById('reset-em');
                const addChargeButton = document.getElementById('add-charge');

                if (typeSelect) {
                    typeSelect.addEventListener('change', () => {
                        this.switchElectromagnetismType(typeSelect.value);
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (strengthSlider) {
                    strengthSlider.addEventListener('input', (e) => {
                        document.getElementById('magnetic-strength-value').textContent = e.target.value;
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (currentSlider) {
                    currentSlider.addEventListener('input', (e) => {
                        document.getElementById('current-value').textContent = e.target.value;
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (wireShapeSelect) {
                    wireShapeSelect.addEventListener('change', () => {
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (chargeSlider) {
                    chargeSlider.addEventListener('input', (e) => {
                        document.getElementById('charge-strength-value').textContent = e.target.value;
                        this.updateElectromagnetismSimulation();
                    });
                }

                // 添加其他滑块的事件监听器
                const chargeCountSlider = document.getElementById('charge-count');
                if (chargeCountSlider) {
                    chargeCountSlider.addEventListener('input', (e) => {
                        document.getElementById('charge-count-value').textContent = e.target.value;
                        this.updateElectromagnetismSimulation();
                    });
                }

                if (startButton) {
                    startButton.addEventListener('click', () => {
                        if (this.isRunning.em) {
                            this.stopElectromagnetismSimulation();
                            startButton.textContent = '开始模拟';
                        } else {
                            this.startElectromagnetismSimulation();
                            startButton.textContent = '停止模拟';
                        }
                    });
                }

                if (resetButton) {
                    resetButton.addEventListener('click', () => {
                        this.resetElectromagnetismSimulation();
                        if (startButton) {
                            startButton.textContent = '开始模拟';
                        }
                    });
                }

                if (addChargeButton) {
                    addChargeButton.addEventListener('click', () => {
                        this.addElectricCharge();
                    });
                }

                // 初始化电荷数组
                this.electricCharges = [];
                this.magneticSources = [];
            }

            updateElectromagnetismSimulation() {
                if (!this.isRunning.em) return;
                
                const type = document.getElementById('em-type')?.value || 'electric-field';
                
                switch(type) {
                    case 'electric-field':
                        this.simulateElectricField();
                        break;
                    case 'magnetic-field':
                        this.simulateMagneticField();
                        break;
                    case 'electromagnetic-induction':
                        this.simulateElectromagneticInduction();
                        break;
                    case 'circuit':
                        this.simulateCircuit();
                        break;
                    case 'electromagnetic-waves':
                        this.simulateElectromagneticWaves();
                        break;
                    case 'lorentz-force':
                        this.simulateLorentzForce();
                        break;
                    case 'capacitor':
                        this.simulateCapacitor();
                        break;
                    case 'electric-motor':
                        this.simulateElectricMotor();
                        break;
                    case 'generator':
                        this.simulateGenerator();
                        break;
                    case 'transformer':
                        this.simulateTransformer();
                        break;
                    default:
                        this.simulateElectricField();
                }
            }

            startElectromagnetismSimulation() {
                this.isRunning.em = true;
                this.updateElectromagnetismSimulation();
                
                // 开始动画循环
                if (!this.animations.em) {
                    this.animations.em = setInterval(() => {
                        this.updateElectromagnetismSimulation();
                    }, 50);
                }
            }

            stopElectromagnetismSimulation() {
                this.isRunning.em = false;
                if (this.animations.em) {
                    clearInterval(this.animations.em);
                    this.animations.em = null;
                }
            }

            resetElectromagnetismSimulation() {
                this.stopElectromagnetismSimulation();
                this.electricCharges = [];
                this.magneticSources = [];
                
                const canvas = this.canvases.em;
                const ctx = this.contexts.em;
                if (canvas && ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }

            simulateMagneticField() {
                const canvas = this.canvases.em;
                const ctx = this.contexts.em;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const current = parseFloat(document.getElementById('current')?.value || 1);
                const wireType = document.getElementById('wire-type')?.value || 'straight';
                
                // 绘制坐标系和测量标尺
                this.drawMagneticFieldGrid(ctx, canvas);
                
                // 绘制磁感应强度等值线
                this.drawMagneticFluxDensityLines(ctx, canvas, current, wireType);
                
                // 绘制3D磁场可视化
                this.drawMagnetic3DField(ctx, canvas, current, wireType);
                
                // 根据导线类型绘制磁场
                switch (wireType) {
                    case 'straight':
                        this.drawStraightWireMagneticField(ctx, canvas, current);
                        break;
                    case 'loop':
                        this.drawLoopMagneticField(ctx, canvas, current);
                        break;
                    case 'solenoid':
                        this.drawSolenoidMagneticField(ctx, canvas, current);
                        break;
                    case 'helmholtz':
                        this.drawHelmholtzCoilField(ctx, canvas, current);
                        break;
                }
                
                // 绘制带电粒子轨迹（如果存在）
                if (this.chargedParticles && this.chargedParticles.length > 0) {
                    this.simulateChargedParticleMotion(ctx, canvas, current, wireType);
                }
                
                // 显示详细的磁场信息
                this.updateMagneticFieldInfo(current, wireType);
            }

            drawMagneticFieldGrid(ctx, canvas) {
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([1, 3]);
                
                const gridSize = 40;
                
                // 绘制极坐标网格（适合磁场）
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // 绘制同心圆
                for (let r = gridSize; r < Math.min(canvas.width, canvas.height) / 2; r += gridSize) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                // 绘制径向线
                for (let angle = 0; angle < 2 * Math.PI; angle += Math.PI / 8) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(angle) * Math.min(canvas.width, canvas.height) / 2,
                        centerY + Math.sin(angle) * Math.min(canvas.width, canvas.height) / 2
                    );
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                
                // 绘制距离标签
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                
                for (let r = gridSize; r < Math.min(canvas.width, canvas.height) / 2; r += gridSize) {
                    const distance = (r / gridSize * 0.05).toFixed(2);
                    ctx.fillText(`${distance}m`, centerX + r, centerY - 5);
                }
            }

            drawMagneticFluxDensityLines(ctx, canvas, current, wireType) {
                ctx.strokeStyle = 'rgba(0, 150, 255, 0.6)';
                ctx.lineWidth = 1;
                
                const fluxDensities = [0.1, 0.2, 0.5, 1.0, 2.0, 5.0]; // 毫特斯拉
                
                fluxDensities.forEach(targetB => {
                    this.drawMagneticFluxContour(ctx, canvas, targetB, current, wireType);
                });
                
                // 绘制磁感应强度标签
                ctx.fillStyle = '#0096ff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('磁感应强度等值线 (mT)', 10, 35);
            }

            drawMagneticFluxContour(ctx, canvas, targetB, current, wireType) {
                const step = 10;
                const tolerance = 0.05;
                
                for (let x = 0; x < canvas.width; x += step * 2) {
                    for (let y = 0; y < canvas.height; y += step * 2) {
                        const B = this.calculateMagneticField(x, y, current, wireType);
                        const magnitude = Math.sqrt(B.x * B.x + B.y * B.y);
                        
                        if (Math.abs(magnitude - targetB) < tolerance) {
                            this.traceMagneticFluxLine(ctx, canvas, x, y, targetB, current, wireType, tolerance);
                        }
                    }
                }
            }

            traceMagneticFluxLine(ctx, canvas, startX, startY, targetB, current, wireType, tolerance) {
                const points = [];
                const visited = new Set();
                const queue = [{x: startX, y: startY}];
                
                while (queue.length > 0 && points.length < 30) {
                    const current_point = queue.shift();
                    const key = `${Math.round(current_point.x/8)},${Math.round(current_point.y/8)}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    const B = this.calculateMagneticField(current_point.x, current_point.y, current, wireType);
                    const magnitude = Math.sqrt(B.x * B.x + B.y * B.y);
                    
                    if (Math.abs(magnitude - targetB) < tolerance) {
                        points.push(current_point);
                        
                        // 检查相邻点
                        const neighbors = [
                            {x: current_point.x + 8, y: current_point.y},
                            {x: current_point.x - 8, y: current_point.y},
                            {x: current_point.x, y: current_point.y + 8},
                            {x: current_point.x, y: current_point.y - 8}
                        ];
                        
                        neighbors.forEach(neighbor => {
                            if (neighbor.x >= 0 && neighbor.x < canvas.width && 
                                neighbor.y >= 0 && neighbor.y < canvas.height) {
                                queue.push(neighbor);
                            }
                        });
                    }
                }
                
                // 绘制磁感应强度等值线
                if (points.length > 2) {
                    ctx.beginPath();
                    points.forEach((point, index) => {
                        if (index === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.stroke();
                }
            }

            calculateMagneticField(x, y, current, wireType) {
                const mu0 = 4 * Math.PI * 1e-7; // 真空磁导率
                const centerX = this.canvases.em.width / 2;
                const centerY = this.canvases.em.height / 2;
                
                let Bx = 0, By = 0;
                
                switch (wireType) {
                    case 'straight':
                        // 无限长直导线的磁场
                        const r = Math.abs(x - centerX) * 0.01; // 转换为米
                        if (r > 0.001) {
                            const B = mu0 * current / (2 * Math.PI * r);
                            // 磁场方向垂直于径向
                            const sign = y > centerY ? 1 : -1;
                            By = sign * B * 1000; // 转换为毫特斯拉
                        }
                        break;
                        
                    case 'loop':
                        // 圆形线圈的磁场（轴上）
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const rho = Math.sqrt(dx * dx + dy * dy) * 0.01;
                        const z = 0.01; // 假设观察点在线圈平面上方1cm
                        const a = 0.05; // 线圈半径5cm
                        
                        if (rho < a * 3) { // 只在线圈附近计算
                            const factor = mu0 * current * a * a / (2 * Math.pow(a * a + z * z, 1.5));
                            By = -factor * 1000; // 转换为毫特斯拉
                        }
                        break;
                        
                    case 'solenoid':
                        // 螺线管内部磁场
                        const solenoidLength = 0.2; // 20cm
                        const n = 100; // 100匝/米
                        if (Math.abs(x - centerX) < 100 && Math.abs(y - centerY) < 50) {
                            By = mu0 * n * current * 1000; // 转换为毫特斯拉
                        }
                        break;
                        
                    case 'helmholtz':
                        // 亥姆霍兹线圈
                        const coilSeparation = 0.1; // 10cm
                        const coilRadius = 0.05; // 5cm
                        
                        // 简化计算：两个线圈的叠加
                        const z1 = (y - centerY + 25) * 0.01;
                        const z2 = (y - centerY - 25) * 0.01;
                        const rho_h = Math.abs(x - centerX) * 0.01;
                        
                        if (rho_h < coilRadius * 2) {
                            const B1 = mu0 * current * coilRadius * coilRadius / (2 * Math.pow(coilRadius * coilRadius + z1 * z1, 1.5));
                            const B2 = mu0 * current * coilRadius * coilRadius / (2 * Math.pow(coilRadius * coilRadius + z2 * z2, 1.5));
                            By = (B1 + B2) * 1000; // 转换为毫特斯拉
                        }
                        break;
                }
                
                return { x: Bx, y: By };
            }

            drawMagnetic3DField(ctx, canvas, current, wireType) {
                // 绘制3D效果的磁场线
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.4)';
                ctx.lineWidth = 2;
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // 绘制磁场线的3D投影
                for (let angle = 0; angle < 2 * Math.PI; angle += Math.PI / 6) {
                    const startRadius = 30;
                    const endRadius = Math.min(canvas.width, canvas.height) / 3;
                    
                    ctx.beginPath();
                    
                    for (let r = startRadius; r <= endRadius; r += 5) {
                        const x = centerX + r * Math.cos(angle);
                        const y = centerY + r * Math.sin(angle);
                        
                        // 添加3D深度效果
                        const depth = Math.sin(r * 0.02) * 10;
                        const x3d = x + depth * Math.cos(angle + Math.PI/2);
                        const y3d = y + depth * Math.sin(angle + Math.PI/2);
                        
                        if (r === startRadius) {
                            ctx.moveTo(x3d, y3d);
                        } else {
                            ctx.lineTo(x3d, y3d);
                        }
                    }
                    
                    ctx.stroke();
                }
            }

            simulateElectricField() {
                const canvas = this.canvases.em;
                const ctx = this.contexts.em;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const chargeAmount = parseFloat(document.getElementById('charge-strength')?.value || 1);
                const showFieldLines = document.getElementById('show-field-lines')?.checked;
                
                // 如果没有电荷，创建一些默认电荷配置
                if (this.electricCharges.length === 0) {
                    this.electricCharges = [
                        { x: canvas.width * 0.3, y: canvas.height * 0.5, charge: chargeAmount },
                        { x: canvas.width * 0.7, y: canvas.height * 0.5, charge: -chargeAmount }
                    ];
                }
                
                // 绘制坐标网格和标尺
                this.drawElectricFieldGrid(ctx, canvas);
                
                // 绘制等势线
                this.drawEquipotentialLines(ctx, canvas);
                
                // 绘制电场线
                if (showFieldLines) {
                    this.drawElectricFieldLines(ctx, canvas);
                }
                
                // 绘制电场强度热力图
                this.drawElectricFieldHeatmap(ctx, canvas);
                
                // 绘制电荷
                this.drawElectricCharges(ctx);
                
                // 绘制电场矢量（更密集的网格）
                this.drawElectricFieldVectors(ctx, canvas);
                
                // 绘制测试电荷（如果存在）
                if (this.testCharge) {
                    this.drawTestCharge(ctx, canvas);
                    this.calculateTestChargeForce(ctx, canvas);
                }
                
                // 显示详细的物理信息
                this.updateElectricFieldInfo(chargeAmount);
            }

            drawElectricFieldGrid(ctx, canvas) {
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                const gridSize = 50;
                
                // 绘制网格
                for (let x = 0; x <= canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                
                // 绘制坐标标签
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                
                for (let x = gridSize; x < canvas.width; x += gridSize) {
                    const realX = ((x - canvas.width/2) / gridSize * 0.1).toFixed(1);
                    ctx.fillText(`${realX}m`, x, canvas.height - 5);
                }
                
                ctx.textAlign = 'right';
                for (let y = gridSize; y < canvas.height; y += gridSize) {
                    const realY = ((canvas.height/2 - y) / gridSize * 0.1).toFixed(1);
                    ctx.fillText(`${realY}m`, canvas.width - 5, y);
                }
            }

            drawEquipotentialLines(ctx, canvas) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
                ctx.lineWidth = 1;
                
                const potentials = [-50, -20, -10, -5, -2, -1, 1, 2, 5, 10, 20, 50]; // 伏特
                
                potentials.forEach(targetPotential => {
                    this.drawEquipotentialContour(ctx, canvas, targetPotential);
                });
                
                // 绘制等势线标签
                ctx.fillStyle = '#00aa00';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('等势线 (V)', 10, 20);
            }

            drawEquipotentialContour(ctx, canvas, targetPotential) {
                const step = 8;
                const tolerance = 1.0;
                
                for (let startX = 0; startX < canvas.width; startX += step * 4) {
                    for (let startY = 0; startY < canvas.height; startY += step * 4) {
                        const potential = this.calculateElectricPotential(startX, startY);
                        
                        if (Math.abs(potential - targetPotential) < tolerance) {
                            this.traceEquipotentialLine(ctx, canvas, startX, startY, targetPotential, tolerance);
                        }
                    }
                }
            }

            traceEquipotentialLine(ctx, canvas, startX, startY, targetPotential, tolerance) {
                const points = [];
                const visited = new Set();
                const queue = [{x: startX, y: startY}];
                
                while (queue.length > 0 && points.length < 50) {
                    const current = queue.shift();
                    const key = `${Math.round(current.x/5)},${Math.round(current.y/5)}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    const potential = this.calculateElectricPotential(current.x, current.y);
                    
                    if (Math.abs(potential - targetPotential) < tolerance) {
                        points.push(current);
                        
                        // 检查相邻点
                        const neighbors = [
                            {x: current.x + 5, y: current.y},
                            {x: current.x - 5, y: current.y},
                            {x: current.x, y: current.y + 5},
                            {x: current.x, y: current.y - 5}
                        ];
                        
                        neighbors.forEach(neighbor => {
                            if (neighbor.x >= 0 && neighbor.x < canvas.width && 
                                neighbor.y >= 0 && neighbor.y < canvas.height) {
                                queue.push(neighbor);
                            }
                        });
                    }
                }
                
                // 绘制等势线
                if (points.length > 2) {
                    ctx.beginPath();
                    points.forEach((point, index) => {
                        if (index === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.stroke();
                }
            }

            calculateElectricPotential(x, y) {
                let potential = 0;
                const k = 8.99e9; // 库仑常数
                
                this.electricCharges.forEach(charge => {
                    const dx = x - charge.x;
                    const dy = y - charge.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    if (r > charge.radius) {
                        potential += k * charge.charge / r;
                    }
                });
                
                return potential * 1e-9; // 转换为合理的电压值
            }

            drawElectricFieldHeatmap(ctx, canvas) {
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let x = 0; x < canvas.width; x += 3) {
                    for (let y = 0; y < canvas.height; y += 3) {
                        const field = this.calculateElectricField(x, y);
                        const magnitude = Math.sqrt(field.x * field.x + field.y * field.y);
                        
                        // 将电场强度映射到颜色
                        const intensity = Math.min(magnitude * 50000, 255);
                        
                        // 填充3x3区域
                        for (let dx = 0; dx < 3; dx++) {
                            for (let dy = 0; dy < 3; dy++) {
                                const index = ((y + dy) * canvas.width + (x + dx)) * 4;
                                
                                if (index < data.length) {
                                    data[index] = intensity; // Red
                                    data[index + 1] = 0; // Green
                                    data[index + 2] = 255 - intensity; // Blue
                                    data[index + 3] = 25; // Alpha (透明度)
                                }
                            }
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }

            drawTestCharge(ctx, canvas) {
                if (!this.testCharge) return;
                
                const radius = 12;
                
                // 绘制测试电荷
                ctx.fillStyle = this.testCharge.charge > 0 ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 165, 0, 0.8)';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.arc(this.testCharge.x, this.testCharge.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // 绘制符号
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('T', this.testCharge.x, this.testCharge.y);
                
                // 绘制轨迹
                if (this.testChargeTrajectory && this.testChargeTrajectory.length > 1) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    this.testChargeTrajectory.forEach((point, index) => {
                        if (index === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    
                    ctx.stroke();
                }
            }

            calculateTestChargeForce(ctx, canvas) {
                if (!this.testCharge) return;
                
                const field = this.calculateElectricField(this.testCharge.x, this.testCharge.y);
                const force = {
                    x: field.x * this.testCharge.charge * 1e-6,
                    y: field.y * this.testCharge.charge * 1e-6
                };
                
                // 绘制力矢量
                const scale = 1000000;
                const endX = this.testCharge.x + force.x * scale;
                const endY = this.testCharge.y + force.y * scale;
                
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.testCharge.x, this.testCharge.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                const angle = Math.atan2(force.y, force.x);
                this.drawArrowHead(ctx, endX, endY, angle, '#ff00ff');
                
                // 显示力的数值
                const forceMagnitude = Math.sqrt(force.x * force.x + force.y * force.y);
                ctx.fillStyle = '#ff00ff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`F = ${(forceMagnitude * 1e6).toExponential(2)} N`, this.testCharge.x + 20, this.testCharge.y - 20);
            }

            updateElectricFieldInfo(chargeAmount) {
                const infoElement = document.getElementById('em-info');
                if (!infoElement) return;
                
                // 计算总电荷和电偶极矩
                let totalCharge = 0;
                let dipoleMoment = { x: 0, y: 0 };
                
                this.electricCharges.forEach(charge => {
                    totalCharge += charge.charge;
                    dipoleMoment.x += charge.charge * charge.x;
                    dipoleMoment.y += charge.charge * charge.y;
                });
                
                const dipoleMagnitude = Math.sqrt(dipoleMoment.x * dipoleMoment.x + dipoleMoment.y * dipoleMoment.y);
                
                // 计算系统的总电势能
                let totalEnergy = 0;
                for (let i = 0; i < this.electricCharges.length; i++) {
                    for (let j = i + 1; j < this.electricCharges.length; j++) {
                        const charge1 = this.electricCharges[i];
                        const charge2 = this.electricCharges[j];
                        const dx = charge1.x - charge2.x;
                        const dy = charge1.y - charge2.y;
                        const r = Math.sqrt(dx * dx + dy * dy) * 0.01; // 转换为米
                        
                        totalEnergy += 8.99e9 * charge1.charge * charge2.charge / r;
                    }
                }
                
                infoElement.innerHTML = `
                    <strong>电场分析</strong><br>
                    <strong>基本信息:</strong><br>
                    电荷数量: ${this.electricCharges.length}<br>
                    总电荷: ${totalCharge.toFixed(2)} C<br>
                    电偶极矩: ${(dipoleMagnitude * 0.01).toExponential(2)} C⋅m<br>
                    系统能量: ${totalEnergy.toExponential(2)} J<br>
                    <br>
                    <strong>物理常数:</strong><br>
                    库仑常数: k = 8.99×10⁹ N⋅m²/C²<br>
                    真空介电常数: ε₀ = 8.85×10⁻¹² F/m<br>
                    <br>
                    <strong>操作提示:</strong><br>
                    • 点击"添加电荷"然后点击画布<br>
                    • 右键点击可添加测试电荷<br>
                    • 拖拽电荷可改变位置<br>
                    • 绿线为等势线，热力图显示场强
                `;
            }

            drawElectricCharges(ctx) {
                this.electricCharges.forEach(charge => {
                    const radius = 15;
                    
                    // 绘制电荷主体
                    const gradient = ctx.createRadialGradient(
                        charge.x - 5, charge.y - 5, 0,
                        charge.x, charge.y, radius
                    );
                    
                    if (charge.charge > 0) {
                        gradient.addColorStop(0, '#ff8888');
                        gradient.addColorStop(1, '#ff4444');
                        ctx.fillStyle = gradient;
                    } else {
                        gradient.addColorStop(0, '#8888ff');
                        gradient.addColorStop(1, '#4444ff');
                        ctx.fillStyle = gradient;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(charge.x, charge.y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // 绘制边框
                    ctx.strokeStyle = charge.charge > 0 ? '#cc0000' : '#0000cc';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 绘制符号
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(charge.charge > 0 ? '+' : '−', charge.x, charge.y);
                    
                    // 绘制电荷量标签
                    ctx.fillStyle = '#333';
                    ctx.font = '10px Arial';
                    ctx.fillText(`${Math.abs(charge.charge).toFixed(1)}C`, charge.x, charge.y + 25);
                });
            }

            drawElectricFieldLines(ctx, canvas) {
                if (this.electricCharges.length === 0) return;
                
                ctx.strokeStyle = 'rgba(67, 97, 238, 0.6)';
                ctx.lineWidth = 2;
                
                // 为每个正电荷绘制电场线
                this.electricCharges.forEach(charge => {
                    if (charge.charge > 0) {
                        // 从正电荷向外绘制多条电场线
                        for (let angle = 0; angle < 2 * Math.PI; angle += Math.PI / 8) {
                            this.drawFieldLine(ctx, canvas, charge.x, charge.y, angle);
                        }
                    }
                });
            }

            drawFieldLine(ctx, canvas, startX, startY, angle) {
                const step = 5;
                const maxSteps = 100;
                let x = startX;
                let y = startY;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                for (let i = 0; i < maxSteps; i++) {
                    // 计算该点的电场方向
                    const field = this.calculateElectricField(x, y);
                    const fieldMagnitude = Math.sqrt(field.x * field.x + field.y * field.y);
                    
                    if (fieldMagnitude < 0.01) break; // 电场太小，停止绘制
                    
                    // 沿电场方向移动
                    const dx = (field.x / fieldMagnitude) * step;
                    const dy = (field.y / fieldMagnitude) * step;
                    
                    x += dx;
                    y += dy;
                    
                    // 检查边界
                    if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) break;
                    
                    // 检查是否接近负电荷
                    let nearNegativeCharge = false;
                    this.electricCharges.forEach(charge => {
                        if (charge.charge < 0) {
                            const dist = Math.sqrt((x - charge.x) ** 2 + (y - charge.y) ** 2);
                            if (dist < 20) nearNegativeCharge = true;
                        }
                    });
                    
                    if (nearNegativeCharge) break;
                    
                    ctx.lineTo(x, y);
                }
                
                ctx.stroke();
                
                // 绘制箭头
                if (x > 0 && x < canvas.width && y > 0 && y < canvas.height) {
                    const field = this.calculateElectricField(x, y);
                    const fieldMagnitude = Math.sqrt(field.x * field.x + field.y * field.y);
                    if (fieldMagnitude > 0.01) {
                        const arrowAngle = Math.atan2(field.y, field.x);
                        this.drawArrowHead(ctx, x, y, arrowAngle, 'rgba(67, 97, 238, 0.6)');
                    }
                }
            }

            calculateElectricField(x, y) {
                let Ex = 0;
                let Ey = 0;
                const k = 8.99e9; // 库仑常数 (简化为1用于可视化)
                
                this.electricCharges.forEach(charge => {
                    const dx = x - charge.x;
                    const dy = y - charge.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    if (r > 1) { // 避免除零
                        const E = k * Math.abs(charge.charge) / (r * r);
                        const Ex_component = E * (dx / r) * Math.sign(charge.charge);
                        const Ey_component = E * (dy / r) * Math.sign(charge.charge);
                        
                        Ex += Ex_component;
                        Ey += Ey_component;
                    }
                });
                
                return { x: Ex * 0.0001, y: Ey * 0.0001 }; // 缩放因子用于可视化
            }

            drawElectricFieldVectors(ctx, canvas) {
                const gridSize = 40;
                const vectorScale = 1000;
                
                ctx.strokeStyle = 'rgba(255, 107, 53, 0.7)';
                ctx.lineWidth = 1;
                
                for (let x = gridSize; x < canvas.width; x += gridSize) {
                    for (let y = gridSize; y < canvas.height; y += gridSize) {
                        // 检查是否太接近电荷
                        let tooClose = false;
                        this.electricCharges.forEach(charge => {
                            const dist = Math.sqrt((x - charge.x) ** 2 + (y - charge.y) ** 2);
                            if (dist < 30) tooClose = true;
                        });
                        
                        if (!tooClose) {
                            const field = this.calculateElectricField(x, y);
                            const magnitude = Math.sqrt(field.x * field.x + field.y * field.y);
                            
                            if (magnitude > 0.001) {
                                const endX = x + field.x * vectorScale;
                                const endY = y + field.y * vectorScale;
                                
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(endX, endY);
                                ctx.stroke();
                                
                                // 绘制小箭头
                                const angle = Math.atan2(field.y, field.x);
                                this.drawSmallArrowHead(ctx, endX, endY, angle);
                            }
                        }
                    }
                }
            }

            drawSmallArrowHead(ctx, x, y, angle) {
                ctx.fillStyle = 'rgba(255, 107, 53, 0.7)';
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-6, -2);
                ctx.lineTo(-6, 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            switchElectromagnetismType(type) {
                // 隐藏所有控制组
                document.getElementById('electric-field-controls').style.display = 'none';
                document.getElementById('magnetic-field-controls').style.display = 'none';
                document.getElementById('induction-controls').style.display = 'none';
                document.getElementById('circuit-controls').style.display = 'none';
                
                // 显示对应的控制组
                switch(type) {
                    case 'electric-field':
                        document.getElementById('electric-field-controls').style.display = 'block';
                        break;
                    case 'magnetic-field':
                        document.getElementById('magnetic-field-controls').style.display = 'block';
                        break;
                    case 'electromagnetic-induction':
                        document.getElementById('induction-controls').style.display = 'block';
                        break;
                    case 'circuit':
                        document.getElementById('circuit-controls').style.display = 'block';
                        break;
                }
            }

            simulateCircuit() {
                const canvas = this.canvases.em;
                const ctx = this.contexts.em;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const voltage = parseFloat(document.getElementById('voltage')?.value || 12);
                const resistance = parseFloat(document.getElementById('resistance')?.value || 10);
                const circuitType = document.getElementById('circuit-type')?.value || 'series';
                
                // 计算电流 (欧姆定律)
                const current = voltage / resistance;
                const power = voltage * current;
                
                // 绘制电路图
                this.drawCircuitDiagram(ctx, canvas, circuitType, voltage, resistance, current);
                
                // 绘制电流流动动画
                this.drawCurrentFlow(ctx, canvas, current);
                
                // 更新信息显示
                const infoElement = document.getElementById('em-info');
                if (infoElement) {
                    infoElement.innerHTML = `
                        <strong>电路分析</strong><br>
                        电压: ${voltage.toFixed(1)} V<br>
                        电阻: ${resistance.toFixed(1)} Ω<br>
                        电流: ${current.toFixed(2)} A<br>
                        功率: ${power.toFixed(2)} W<br>
                        欧姆定律: V = IR
                    `;
                }
            }

            drawInductionCoil(ctx, canvas, turns) {
                const centerX = canvas.width * 0.3;
                const centerY = canvas.height * 0.5;
                const coilWidth = 80;
                const coilHeight = 120;
                
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                
                // 绘制线圈
                for (let i = 0; i < turns; i++) {
                    const y = centerY - coilHeight/2 + (coilHeight * i / turns);
                    ctx.beginPath();
                    ctx.arc(centerX, y, coilWidth/turns, 0, Math.PI);
                    ctx.stroke();
                }
                
                // 绘制连接线
                ctx.beginPath();
                ctx.moveTo(centerX - coilWidth/2, centerY - coilHeight/2);
                ctx.lineTo(centerX - coilWidth/2 - 20, centerY - coilHeight/2);
                ctx.moveTo(centerX - coilWidth/2, centerY + coilHeight/2);
                ctx.lineTo(centerX - coilWidth/2 - 20, centerY + coilHeight/2);
                ctx.stroke();
            }

            drawMovingMagnet(ctx, canvas, speed, strength) {
                const time = Date.now() * 0.001;
                const magnetX = canvas.width * 0.6 + Math.sin(time * speed) * 100;
                const magnetY = canvas.height * 0.5;
                const magnetWidth = 60;
                const magnetHeight = 30;
                
                // 绘制磁铁
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(magnetX - magnetWidth/2, magnetY - magnetHeight/2, magnetWidth/2, magnetHeight);
                ctx.fillStyle = '#4444ff';
                ctx.fillRect(magnetX, magnetY - magnetHeight/2, magnetWidth/2, magnetHeight);
                
                // 标记N和S极
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('N', magnetX - magnetWidth/4, magnetY + 5);
                ctx.fillText('S', magnetX + magnetWidth/4, magnetY + 5);
                
                // 绘制磁场线
                this.drawMagnetFieldLines(ctx, magnetX, magnetY, magnetWidth, magnetHeight);
            }

            drawMagnetFieldLines(ctx, magnetX, magnetY, width, height) {
                ctx.strokeStyle = 'rgba(255, 107, 53, 0.6)';
                ctx.lineWidth = 2;
                
                // 简化的磁场线
                for (let i = -2; i <= 2; i++) {
                    const y = magnetY + i * 15;
                    ctx.beginPath();
                    ctx.moveTo(magnetX - width/2 - 30, y);
                    ctx.quadraticCurveTo(magnetX, y - 20, magnetX + width/2 + 30, y);
                    ctx.stroke();
                }
            }

            drawInducedCurrent(ctx, canvas, speed, strength) {
                const current = speed * strength * 0.5; // 简化计算
                if (Math.abs(current) < 0.1) return;
                
                const centerX = canvas.width * 0.3;
                const centerY = canvas.height * 0.5;
                
                // 绘制电流方向箭头
                ctx.strokeStyle = current > 0 ? '#00ff00' : '#ff0000';
                ctx.lineWidth = 3;
                
                const arrowY = centerY + (current > 0 ? -60 : 60);
                ctx.beginPath();
                ctx.moveTo(centerX - 30, arrowY);
                ctx.lineTo(centerX + 30, arrowY);
                ctx.stroke();
                
                this.drawArrowHead(ctx, centerX + 30, arrowY, current > 0 ? 0 : Math.PI, ctx.strokeStyle);
                
                // 电流强度标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`I = ${Math.abs(current).toFixed(2)}A`, centerX, arrowY + 20);
            }

            drawCircuitDiagram(ctx, canvas, type, voltage, resistance, current) {
                const centerX = canvas.width * 0.5;
                const centerY = canvas.height * 0.5;
                const circuitSize = 150;
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                
                // 绘制电路框架
                ctx.beginPath();
                ctx.rect(centerX - circuitSize, centerY - circuitSize/2, circuitSize * 2, circuitSize);
                ctx.stroke();
                
                // 绘制电池
                this.drawBattery(ctx, centerX - circuitSize/2, centerY - circuitSize/2 - 20, voltage);
                
                // 绘制电阻
                this.drawResistor(ctx, centerX + circuitSize/2, centerY, resistance);
                
                // 绘制电流方向
                this.drawCurrentDirection(ctx, centerX, centerY + circuitSize/2 + 20, current);
            }

            drawBattery(ctx, x, y, voltage) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                
                // 正极
                ctx.beginPath();
                ctx.moveTo(x, y - 15);
                ctx.lineTo(x, y + 15);
                ctx.stroke();
                
                // 负极
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(x + 15, y - 10);
                ctx.lineTo(x + 15, y + 10);
                ctx.stroke();
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${voltage}V`, x + 7, y + 35);
                ctx.fillText('+', x - 10, y);
                ctx.fillText('-', x + 25, y);
            }

            drawResistor(ctx, x, y, resistance) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                
                // 电阻符号 (锯齿形)
                ctx.beginPath();
                ctx.moveTo(x - 20, y);
                ctx.lineTo(x - 15, y - 10);
                ctx.lineTo(x - 5, y + 10);
                ctx.lineTo(x + 5, y - 10);
                ctx.lineTo(x + 15, y + 10);
                ctx.lineTo(x + 20, y);
                ctx.stroke();
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${resistance}Ω`, x, y + 25);
            }

            drawCurrentDirection(ctx, x, y, current) {
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(x - 30, y);
                ctx.lineTo(x + 30, y);
                ctx.stroke();
                
                this.drawArrowHead(ctx, x + 30, y, 0, '#ff4444');
                
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`I = ${current.toFixed(2)}A`, x, y + 20);
            }

            drawCurrentFlow(ctx, canvas, current) {
                // 简单的电流流动动画点
                const time = Date.now() * 0.005;
                const centerX = canvas.width * 0.5;
                const centerY = canvas.height * 0.5;
                const circuitSize = 150;
                
                ctx.fillStyle = '#ffff00';
                
                for (let i = 0; i < 8; i++) {
                    const progress = (time + i * 0.3) % 1;
                    let x, y;
                    
                    if (progress < 0.25) {
                        // 顶边
                        x = centerX - circuitSize + progress * 4 * circuitSize;
                        y = centerY - circuitSize/2;
                    } else if (progress < 0.5) {
                        // 右边
                        x = centerX + circuitSize;
                        y = centerY - circuitSize/2 + (progress - 0.25) * 4 * circuitSize;
                    } else if (progress < 0.75) {
                        // 底边
                        x = centerX + circuitSize - (progress - 0.5) * 4 * circuitSize;
                        y = centerY + circuitSize/2;
                    } else {
                        // 左边
                        x = centerX - circuitSize;
                        y = centerY + circuitSize/2 - (progress - 0.75) * 4 * circuitSize;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            updatePhysicsExplanation(type) {
                const explanationDiv = document.getElementById('physics-explanation');
                const learningPoints = document.getElementById('key-concepts');
                
                const explanations = {
                    'electric-field': {
                        text: `<strong>电场基本原理：</strong>电场是带电体周围存在的特殊物质，能够对其中的电荷产生作用力。<br>
                        <strong>库仑定律：</strong>F = k·q₁q₂/r²<br>
                        <strong>电场强度：</strong>E = F/q = k·Q/r²<br>
                        <strong>电势：</strong>V = k·Q/r`,
                        points: [
                            '电场线从正电荷出发，终止于负电荷',
                            '电场线越密集，电场强度越大',
                            '电场线不相交，不闭合',
                            '等势线与电场线垂直'
                        ]
                    },
                    'magnetic-field': {
                        text: `<strong>磁场基本原理：</strong>磁场是由运动电荷或电流产生的场，能够对其中的运动电荷产生洛伦兹力。<br>
                        <strong>毕奥-萨伐尔定律：</strong>dB = (μ₀/4π)·(I·dl×r)/r³<br>
                        <strong>安培环路定律：</strong>∮B·dl = μ₀I<br>
                        <strong>洛伦兹力：</strong>F = q(v×B)`,
                        points: [
                            '磁感线是闭合曲线',
                            '右手定则确定磁场方向',
                            '磁感线越密集，磁感应强度越大',
                            '磁场对运动电荷产生洛伦兹力'
                        ]
                    },
                    'electromagnetic-induction': {
                        text: `<strong>电磁感应原理：</strong>变化的磁场产生电场，是发电机和变压器的工作原理。<br>
                        <strong>法拉第定律：</strong>ε = -dΦ/dt = -N·dB/dt·S<br>
                        <strong>楞次定律：</strong>感应电流的方向总是要阻碍引起它的磁通量的变化<br>
                        <strong>自感：</strong>L = Φ/I，ε = -L·dI/dt`,
                        points: [
                            '磁通量变化产生感应电动势',
                            '楞次定律确定感应电流方向',
                            '感应电动势与磁通量变化率成正比',
                            '自感和互感现象的应用'
                        ]
                    },
                    'circuit': {
                        text: `<strong>电路分析原理：</strong>研究电路中电流、电压、功率分布的科学。<br>
                        <strong>欧姆定律：</strong>V = I·R<br>
                        <strong>功率：</strong>P = V·I = I²·R = V²/R<br>
                        <strong>阻抗：</strong>Z = √(R² + (ωL - 1/ωC)²)`,
                        points: [
                            '基尔霍夫电流定律和电压定律',
                            '串联电路和并联电路的特性',
                            'RC、RL、RLC电路的频率响应',
                            '交流电路的阻抗和相位'
                        ]
                    },
                    'electromagnetic-waves': {
                        text: `<strong>电磁波原理：</strong>同步变化的电场和磁场在空间的传播，速度等于光速。<br>
                        <strong>波动方程：</strong>E = E₀·cos(kx - ωt + φ)<br>
                        <strong>关系式：</strong>c = λf，c = 1/√(μ₀ε₀)<br>
                        <strong>坡印廷矢量：</strong>S = (1/μ₀)·E×B`,
                        points: [
                            '电场和磁场相互垂直且垂直于传播方向',
                            '电磁波携带能量和动量',
                            '坡印廷矢量表示能量流密度',
                            '不同频率的电磁波有不同应用'
                        ]
                    },
                    'lorentz-force': {
                        text: `<strong>洛伦兹力原理：</strong>运动电荷在电磁场中受到的作用力，是电场力和磁场力的合力。<br>
                        <strong>洛伦兹力：</strong>F = q(E + v×B)<br>
                        <strong>回旋半径：</strong>r = mv/(qB)<br>
                        <strong>回旋频率：</strong>f = qB/(2πm)`,
                        points: [
                            '电场力与速度无关，总是沿电场方向',
                            '磁场力垂直于速度和磁场方向',
                            '洛伦兹力改变速度方向，不改变速率',
                            '带电粒子在磁场中做圆周运动'
                        ]
                    }
                };

                if (explanations[type]) {
                    explanationDiv.innerHTML = explanations[type].text;
                    learningPoints.innerHTML = explanations[type].points
                        .map(point => `<li>${point}</li>`)
                        .join('');
                }
            }

            updateInductionData() {
                const turns = parseFloat(document.getElementById('coil-turns')?.value || 50);
                const fluxRate = parseFloat(document.getElementById('flux-rate')?.value || 0.5);
                const resistance = parseFloat(document.getElementById('coil-resistance')?.value || 1.0);
                const motionSpeed = parseFloat(document.getElementById('motion-speed')?.value || 1.0);

                // 计算感应电动势
                const inducedEMF = turns * fluxRate * motionSpeed;
                const inducedCurrent = inducedEMF / resistance;
                const inducedPower = inducedEMF * inducedCurrent;
                const magneticFlux = fluxRate * this.simulationTime || 0;

                // 更新显示
                if (document.getElementById('induced-emf-display')) {
                    document.getElementById('induced-emf-display').textContent = inducedEMF.toFixed(3);
                }
                if (document.getElementById('induced-current-display')) {
                    document.getElementById('induced-current-display').textContent = inducedCurrent.toFixed(3);
                }
                if (document.getElementById('induced-power-display')) {
                    document.getElementById('induced-power-display').textContent = inducedPower.toFixed(3);
                }
                if (document.getElementById('magnetic-flux-display')) {
                    document.getElementById('magnetic-flux-display').textContent = magneticFlux.toFixed(3);
                }
            }

            updateCircuitAnalysis() {
                const voltage = parseFloat(document.getElementById('voltage')?.value || 12);
                const resistance = parseFloat(document.getElementById('resistance')?.value || 100);
                const capacitance = parseFloat(document.getElementById('capacitance')?.value || 10) * 1e-6;
                const inductance = parseFloat(document.getElementById('inductance')?.value || 10) * 1e-3;
                const frequency = parseFloat(document.getElementById('ac-frequency')?.value || 50);

                const omega = 2 * Math.PI * frequency;
                const XL = omega * inductance;
                const XC = 1 / (omega * capacitance);
                const impedance = Math.sqrt(resistance * resistance + (XL - XC) * (XL - XC));
                
                const current = voltage / impedance;
                const power = current * current * resistance;
                const phaseDifference = Math.atan2((XL - XC), resistance) * 180 / Math.PI;

                // 更新显示
                if (document.getElementById('circuit-current')) {
                    document.getElementById('circuit-current').textContent = current.toFixed(3);
                }
                if (document.getElementById('circuit-power')) {
                    document.getElementById('circuit-power').textContent = power.toFixed(3);
                }
                if (document.getElementById('circuit-impedance')) {
                    document.getElementById('circuit-impedance').textContent = impedance.toFixed(1);
                }
                if (document.getElementById('phase-difference')) {
                    document.getElementById('phase-difference').textContent = phaseDifference.toFixed(1);
                }
            }
        }

        // 初始化模拟器
        document.addEventListener('DOMContentLoaded', () => {
            new PhysicsSimulator();
        });
    </script>
</body>
</html> 