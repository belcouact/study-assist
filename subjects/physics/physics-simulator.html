<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理模拟器 - 学习助手</title>
    <link rel="icon" href="../../assets/icons/logo_btrfly.ico" type="image/x-icon">
    <link rel="stylesheet" href="../../css/common.css">
    <link rel="stylesheet" href="../../css/components.css">
    <link rel="stylesheet" href="../../css/utilities.css">
    <link rel="stylesheet" href="../../css/responsive.css">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        .simulator-page {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem 0;
        }

        .simulator-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            margin: 2rem auto;
            max-width: 1400px;
        }

        .simulator-header {
            background: linear-gradient(135deg, #4361ee, #7209b7);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .simulator-header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .simulator-header p {
            margin: 1rem 0 0 0;
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .simulator-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            overflow-x: auto;
        }

        .simulator-tab {
            flex: 1;
            min-width: 150px;
            padding: 1rem 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .simulator-tab.active {
            background: white;
            color: #4361ee;
            border-bottom: 3px solid #4361ee;
        }

        .simulator-tab:hover {
            background: rgba(67, 97, 238, 0.1);
            color: #4361ee;
        }

        .simulator-content {
            padding: 2rem;
            min-height: 600px;
        }

        .simulation-panel {
            display: none;
        }

        .simulation-panel.active {
            display: block;
        }

        .simulation-workspace {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
            height: 600px;
        }

        .simulation-controls {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .simulation-display {
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .simulation-canvas {
            width: 100%;
            height: 100%;
            display: block;
            background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f8f9fa 75%), 
                        linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            border-radius: 13px;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }

        .control-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .control-input:focus {
            outline: none;
            border-color: #4361ee;
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
        }

        .control-slider {
            width: 100%;
            margin: 0.5rem 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            transition: background 0.3s ease;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4361ee, #7209b7);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(67, 97, 238, 0.3);
        }

        .control-button {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(135deg, #4361ee, #7209b7);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.5rem;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(67, 97, 238, 0.3);
        }

        .control-button:active {
            transform: translateY(0);
        }

        .control-button.secondary {
            background: linear-gradient(135deg, #6c757d, #495057);
        }

        .control-button.danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }

        .simulation-info {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            border: 1px solid #4361ee;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .simulation-info h4 {
            margin: 0 0 0.5rem 0;
            color: #4361ee;
            font-weight: 600;
        }

        .simulation-info p {
            margin: 0;
            font-size: 0.9rem;
            color: #333;
        }

        /* Enhanced physics objects */
        .physics-object {
            position: absolute;
            border-radius: 50%;
            transition: all 0.1s ease;
        }

        .projectile {
            width: 12px;
            height: 12px;
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff4444);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.6), 0 0 30px rgba(255, 68, 68, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .pendulum-bob {
            width: 24px;
            height: 24px;
            background: radial-gradient(circle at 30% 30%, #6c95ff, #4361ee);
            box-shadow: 0 0 20px rgba(67, 97, 238, 0.5), 0 0 40px rgba(67, 97, 238, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
        }

        .pendulum-string {
            position: absolute;
            background: linear-gradient(to bottom, #333, #666);
            transform-origin: top center;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .wave-particle {
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #9c27b0, #7209b7);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.6);
        }

        .electric-charge {
            border-radius: 50%;
            border: 3px solid;
            position: absolute;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .charge-positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff4444);
            border-color: #cc0000;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
        }

        .charge-negative {
            background: radial-gradient(circle at 30% 30%, #6b6bff, #4444ff);
            border-color: #0000cc;
            box-shadow: 0 0 20px rgba(68, 68, 255, 0.6);
        }

        .charge-positive:hover, .charge-negative:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(67, 97, 238, 0.8);
        }

        .ray-light {
            stroke: #ffeb3b;
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 0 8px #ffeb3b) drop-shadow(0 0 16px #ffc107);
        }

        .lens {
            fill: rgba(67, 97, 238, 0.2);
            stroke: #4361ee;
            stroke-width: 3;
            filter: drop-shadow(0 0 5px rgba(67, 97, 238, 0.3));
        }

        .mirror {
            stroke: #666;
            stroke-width: 5;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
        }

        /* Particle system effects */
        .particle-explosion {
            position: absolute;
            pointer-events: none;
        }

        .spark-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: radial-gradient(circle, #ffeb3b, #ff9800);
            border-radius: 50%;
            animation: sparkle 1s ease-out forwards;
        }

        @keyframes sparkle {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.3);
            }
        }

        /* Wave effects */
        .wave-ripple {
            position: absolute;
            border: 2px solid rgba(67, 97, 238, 0.6);
            border-radius: 50%;
            animation: ripple 2s ease-out infinite;
        }

        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* Field visualization */
        .field-line {
            stroke: rgba(67, 97, 238, 0.7);
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(67, 97, 238, 0.3));
        }

        .magnetic-field-line {
            stroke: rgba(255, 107, 53, 0.7);
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(255, 107, 53, 0.3));
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .simulation-workspace {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .simulation-controls {
                order: 2;
                max-height: 300px;
            }
            
            .simulation-display {
                height: 400px;
                order: 1;
            }
            
            .simulator-tabs {
                flex-wrap: wrap;
            }
            
            .simulator-tab {
                min-width: 120px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            .simulator-content {
                padding: 1rem;
            }
            
            .simulation-workspace {
                gap: 1rem;
            }
            
            .simulation-display {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <header class="main-header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <a href="../../index.html">
                        <i class="fas fa-graduation-cap" style="background: linear-gradient(90deg, #4361ee, #7209b7); -webkit-background-clip: text; background-clip: text; color: transparent;"></i>
                        <span>Alex的学习助手</span>
                    </a>
                </div>
                <nav class="main-nav">
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="main.html">物理</a></li>
                        <li><a href="../../index.html#subjects">科目</a></li>
                        <li><a href="../../tts.html">语音</a></li>
                        <li><a href="../../draw.html">绘图</a></li>
                    </ul>
                </nav>
                <button class="mobile-menu-toggle" aria-label="切换菜单">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
        </div>
    </header>

    <main class="simulator-page">
        <div class="container">
            <div class="simulator-container">
                <div class="simulator-header">
                    <h1><i class="fas fa-atom"></i> 物理模拟器</h1>
                    <p>通过交互式模拟探索物理世界的奥秘</p>
                </div>

                <div class="simulator-tabs">
                    <button class="simulator-tab active" data-tab="mechanics">
                        <i class="fas fa-cogs"></i> 力学
                    </button>
                </div>

                <div class="simulator-content">
                    <!-- 力学模拟 -->
                    <div class="simulation-panel active" id="mechanics-panel">
                        <div class="simulation-workspace">
                            <div class="simulation-controls">
                                <h3><i class="fas fa-cogs"></i> 力学模拟</h3>
                                
                                <div class="control-group">
                                    <label>模拟类型</label>
                                    <select class="control-input" id="mechanics-type">
                                        <option value="projectile">抛体运动</option>
                                        <option value="pendulum">单摆</option>
                                        <option value="collision">碰撞</option>
                                        <option value="spring">弹簧振动</option>
                                    </select>
                                </div>

                                <div id="projectile-controls">
                                    <div class="control-group">
                                        <label>初始速度 (m/s): <span id="velocity-value">20</span></label>
                                        <input type="range" class="control-slider" id="initial-velocity" min="5" max="50" value="20">
                                    </div>
                                    <div class="control-group">
                                        <label>发射角度 (°): <span id="angle-value">45</span></label>
                                        <input type="range" class="control-slider" id="launch-angle" min="0" max="90" value="45">
                                    </div>
                                    <div class="control-group">
                                        <label>重力加速度 (m/s²): <span id="gravity-value">9.8</span></label>
                                        <input type="range" class="control-slider" id="gravity" min="1" max="20" value="9.8" step="0.1">
                                    </div>
                                </div>

                                <div id="pendulum-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>摆长 (m): <span id="pendulum-length-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="pendulum-length" min="0.5" max="3" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>初始角度 (°): <span id="pendulum-angle-value">30</span></label>
                                        <input type="range" class="control-slider" id="pendulum-angle" min="5" max="60" value="30">
                                    </div>
                                </div>

                                <div id="collision-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>球1质量 (kg): <span id="mass1-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="mass1" min="0.5" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>球2质量 (kg): <span id="mass2-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="mass2" min="0.5" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>球1初速度 (m/s): <span id="velocity1-value">5</span></label>
                                        <input type="range" class="control-slider" id="velocity1" min="0" max="10" value="5" step="0.5">
                                    </div>
                                    <div class="control-group">
                                        <label>球2初速度 (m/s): <span id="velocity2-value">0</span></label>
                                        <input type="range" class="control-slider" id="velocity2" min="0" max="10" value="0" step="0.5">
                                    </div>
                                    <div class="control-group">
                                        <label>恢复系数: <span id="restitution-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="restitution" min="0" max="1" value="1.0" step="0.1">
                                    </div>
                                </div>

                                <div id="spring-controls" style="display: none;">
                                    <div class="control-group">
                                        <label>弹簧常数 (N/m): <span id="spring-k-value">10</span></label>
                                        <input type="range" class="control-slider" id="spring-k" min="1" max="50" value="10">
                                    </div>
                                    <div class="control-group">
                                        <label>质量 (kg): <span id="spring-mass-value">1.0</span></label>
                                        <input type="range" class="control-slider" id="spring-mass" min="0.1" max="5" value="1.0" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>初始位移 (m): <span id="spring-displacement-value">0.5</span></label>
                                        <input type="range" class="control-slider" id="spring-displacement" min="0.1" max="2" value="0.5" step="0.1">
                                    </div>
                                    <div class="control-group">
                                        <label>阻尼系数: <span id="damping-value">0.1</span></label>
                                        <input type="range" class="control-slider" id="damping" min="0" max="1" value="0.1" step="0.05">
                                    </div>
                                </div>

                                <button class="control-button" id="start-mechanics">开始模拟</button>
                                <button class="control-button secondary" id="reset-mechanics">重置</button>
                                <button class="control-button secondary" id="pause-mechanics">暂停</button>

                                <div class="simulation-info">
                                    <h4>实时数据</h4>
                                    <p id="mechanics-info">点击开始模拟查看实时数据</p>
                                </div>
                            </div>
                            <div class="simulation-display">
                                <canvas class="simulation-canvas" id="mechanics-canvas" width="800" height="600"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="main-footer">
        <div class="container">
            <div class="footer-content">
                <p class="copyright-text">study-llm.me域名为Alex所有。保留所有权利。</p>
            </div>
        </div>
    </footer>

    <script src="../../js/common.js"></script>
    <script src="../../js/navigation.js"></script>
    
    <!-- Load modular physics simulators -->
    <script src="modules/physics-utils.js"></script>
    <script src="modules/mechanics-simulator.js"></script>
    
    <script>
        // 物理模拟器主要功能 - 重构为模块化架构
        class PhysicsSimulator {
            constructor() {
                this.currentTab = 'mechanics';
                this.animations = {};
                this.isRunning = {
                    mechanics: false
                };
                this.initializeCanvases();
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // 标签切换
                document.querySelectorAll('.simulator-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchTab(e.target.dataset.tab);
                    });
                });

                // 只保留力学控制
                this.setupMechanicsControls();
            }

            initializeCanvases() {
                this.canvases = {
                    mechanics: document.getElementById('mechanics-canvas')
                };

                this.contexts = {};
                Object.keys(this.canvases).forEach(key => {
                    this.contexts[key] = this.canvases[key].getContext('2d');
                });
            }

            switchTab(tabName) {
                // 停止当前动画
                if (this.animations[this.currentTab]) {
                    cancelAnimationFrame(this.animations[this.currentTab]);
                }

                // 更新标签状态
                document.querySelectorAll('.simulator-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

                // 更新面板显示
                document.querySelectorAll('.simulation-panel').forEach(panel => {
                    panel.classList.remove('active');
                });
                document.getElementById(`${tabName}-panel`).classList.add('active');

                this.currentTab = tabName;
            }

            setupMechanicsControls() {
                const typeSelect = document.getElementById('mechanics-type');
                const startBtn = document.getElementById('start-mechanics');
                const resetBtn = document.getElementById('reset-mechanics');
                const pauseBtn = document.getElementById('pause-mechanics');

                // 类型切换
                if (typeSelect) {
                    typeSelect.addEventListener('change', (e) => {
                        this.switchMechanicsType(e.target.value);
                    });
                }

                // 滑块更新
                if (document.getElementById('initial-velocity')) {
                    document.getElementById('initial-velocity').addEventListener('input', (e) => {
                        document.getElementById('velocity-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('launch-angle')) {
                    document.getElementById('launch-angle').addEventListener('input', (e) => {
                        document.getElementById('angle-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('gravity')) {
                    document.getElementById('gravity').addEventListener('input', (e) => {
                        document.getElementById('gravity-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('pendulum-length')) {
                    document.getElementById('pendulum-length').addEventListener('input', (e) => {
                        document.getElementById('pendulum-length-value').textContent = e.target.value;
                    });
                }

                if (document.getElementById('pendulum-angle')) {
                    document.getElementById('pendulum-angle').addEventListener('input', (e) => {
                        document.getElementById('pendulum-angle-value').textContent = e.target.value;
                    });
                }

                // 碰撞控制
                if (document.getElementById('mass1')) {
                    document.getElementById('mass1').addEventListener('input', (e) => {
                        document.getElementById('mass1-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('mass2')) {
                    document.getElementById('mass2').addEventListener('input', (e) => {
                        document.getElementById('mass2-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('velocity1')) {
                    document.getElementById('velocity1').addEventListener('input', (e) => {
                        document.getElementById('velocity1-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('velocity2')) {
                    document.getElementById('velocity2').addEventListener('input', (e) => {
                        document.getElementById('velocity2-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('restitution')) {
                    document.getElementById('restitution').addEventListener('input', (e) => {
                        document.getElementById('restitution-value').textContent = e.target.value;
                    });
                }

                // 弹簧控制
                if (document.getElementById('spring-k')) {
                    document.getElementById('spring-k').addEventListener('input', (e) => {
                        document.getElementById('spring-k-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('spring-mass')) {
                    document.getElementById('spring-mass').addEventListener('input', (e) => {
                        document.getElementById('spring-mass-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('spring-displacement')) {
                    document.getElementById('spring-displacement').addEventListener('input', (e) => {
                        document.getElementById('spring-displacement-value').textContent = e.target.value;
                    });
                }
                if (document.getElementById('damping')) {
                    document.getElementById('damping').addEventListener('input', (e) => {
                        document.getElementById('damping-value').textContent = e.target.value;
                    });
                }

                // 按钮控制
                if (startBtn) startBtn.addEventListener('click', () => this.startMechanicsSimulation());
                if (resetBtn) resetBtn.addEventListener('click', () => this.resetMechanicsSimulation());
                if (pauseBtn) pauseBtn.addEventListener('click', () => this.pauseMechanicsSimulation());
            }

            switchMechanicsType(type) {
                document.getElementById('projectile-controls').style.display = 
                    type === 'projectile' ? 'block' : 'none';
                document.getElementById('pendulum-controls').style.display = 
                    type === 'pendulum' ? 'block' : 'none';
                document.getElementById('collision-controls').style.display = 
                    type === 'collision' ? 'block' : 'none';
                document.getElementById('spring-controls').style.display = 
                    type === 'spring' ? 'block' : 'none';
            }

            startMechanicsSimulation() {
                const type = document.getElementById('mechanics-type').value;
                this.isRunning.mechanics = true;

                if (type === 'projectile') {
                    this.simulateProjectileMotion();
                } else if (type === 'pendulum') {
                    this.simulatePendulum();
                } else if (type === 'collision') {
                    this.simulateCollision();
                } else if (type === 'spring') {
                    this.simulateSpring();
                }
            }

            simulateProjectileMotion() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const velocity = parseFloat(document.getElementById('initial-velocity').value);
                const angle = parseFloat(document.getElementById('launch-angle').value) * Math.PI / 180;
                const gravity = parseFloat(document.getElementById('gravity').value);

                const vx = velocity * Math.cos(angle);
                const vy = velocity * Math.sin(angle);

                let t = 0;
                const dt = 0.02;
                const scale = 8; // 像素/米
                
                // 空气阻力系数 (可调节)
                const airResistance = 0.01;
                const mass = 1; // kg

                // 存储轨迹点用于绘制完整轨迹
                const trajectoryPoints = [];
                let currentVx = vx;
                let currentVy = vy;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制坐标系和网格
                    this.drawCoordinateSystem(ctx, canvas, scale);

                    // 计算当前位置 (考虑空气阻力)
                    const x = 50 + t * currentVx * scale;
                    const y = canvas.height - 80 - (currentVy * t - 0.5 * gravity * t * t) * scale;

                    // 空气阻力计算
                    const speed = Math.sqrt(currentVx * currentVx + currentVy * currentVy);
                    const dragForceX = -airResistance * speed * currentVx;
                    const dragForceY = -airResistance * speed * currentVy;
                    
                    // 更新速度（考虑重力和空气阻力）
                    currentVx += (dragForceX / mass) * dt;
                    currentVy += (-gravity + dragForceY / mass) * dt;

                    // 存储轨迹点
                    if (t % 0.1 < dt) { // 每0.1秒记录一个点
                        trajectoryPoints.push({x: x, y: y, t: t});
                    }

                    // 绘制完整轨迹
                    this.drawTrajectory(ctx, trajectoryPoints);

                    // 绘制理论轨迹（无空气阻力）
                    this.drawTheoreticalTrajectory(ctx, canvas, vx, vy, gravity, scale);

                    if (y <= canvas.height - 80 && x < canvas.width - 50) {
                        // 绘制抛体（增强效果）
                        this.drawProjectile(ctx, x, y, currentVx, currentVy);

                        // 绘制速度分解
                        this.drawVelocityComponents(ctx, x, y, currentVx, currentVy);

                        // 绘制轨迹切线和法线
                        this.drawTangentAndNormal(ctx, x, y, currentVx, currentVy);

                        // 实时物理数据分析
                        const height = Math.max(0, (canvas.height - 80 - y) / scale);
                        const distance = (x - 50) / scale;
                        const totalSpeed = Math.sqrt(currentVx * currentVx + currentVy * currentVy);
                        const kineticEnergy = 0.5 * mass * totalSpeed * totalSpeed;
                        const potentialEnergy = mass * gravity * height;
                        const totalEnergy = kineticEnergy + potentialEnergy;
                        
                        // 计算理论值对比
                        const theoreticalRange = (vx * vx * Math.sin(2 * angle)) / gravity;
                        const maxHeight = (vy * vy) / (2 * gravity);

                        document.getElementById('mechanics-info').innerHTML = `
                            <strong>实时飞行数据:</strong><br>
                            时间: ${t.toFixed(2)}s<br>
                            位置: (${distance.toFixed(1)}m, ${height.toFixed(1)}m)<br>
                            速度: ${totalSpeed.toFixed(2)}m/s<br>
                            水平速度: ${currentVx.toFixed(2)}m/s<br>
                            垂直速度: ${currentVy.toFixed(2)}m/s<br>
                            <strong>能量分析:</strong><br>
                            动能: ${kineticEnergy.toFixed(2)}J<br>
                            势能: ${potentialEnergy.toFixed(2)}J<br>
                            总能量: ${totalEnergy.toFixed(2)}J<br>
                            <strong>理论对比:</strong><br>
                            理论射程: ${theoreticalRange.toFixed(1)}m<br>
                            最大高度: ${maxHeight.toFixed(1)}m<br>
                            空气阻力效应: ${((1 - distance/theoreticalRange)*100).toFixed(1)}%
                        `;

                        t += dt;
                        this.animations.mechanics = requestAnimationFrame(animate);
                    } else {
                        // 着陆分析
                        const finalDistance = (x - 50) / scale;
                        const flightTime = t;
                        this.isRunning.mechanics = false;
                        
                        document.getElementById('mechanics-info').innerHTML += `<br><strong style="color: #ff4444;">着陆分析:</strong><br>
                            实际射程: ${finalDistance.toFixed(1)}m<br>
                            飞行时间: ${flightTime.toFixed(2)}s<br>
                            着陆速度: ${Math.sqrt(currentVx*currentVx + currentVy*currentVy).toFixed(2)}m/s`;
                    }
                };

                animate();
            }

            drawCoordinateSystem(ctx, canvas, scale) {
                // 绘制网格
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                // 垂直网格线（每10米）
                for (let x = 50; x < canvas.width - 50; x += 10 * scale) {
                    ctx.beginPath();
                    ctx.moveTo(x, 50);
                    ctx.lineTo(x, canvas.height - 80);
                    ctx.stroke();
                }
                
                // 水平网格线（每5米）
                for (let y = canvas.height - 80; y > 50; y -= 5 * scale) {
                    ctx.beginPath();
                    ctx.moveTo(50, y);
                    ctx.lineTo(canvas.width - 50, y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // 绘制坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // X轴
                ctx.moveTo(50, canvas.height - 80);
                ctx.lineTo(canvas.width - 50, canvas.height - 80);
                // Y轴
                ctx.moveTo(50, canvas.height - 80);
                ctx.lineTo(50, 50);
                ctx.stroke();

                // 坐标轴标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i <= 100; i += 20) {
                    const x = 50 + i * scale;
                    if (x < canvas.width - 50) {
                        ctx.fillText(`${i}m`, x, canvas.height - 60);
                    }
                }
                
                ctx.textAlign = 'right';
                for (let i = 0; i <= 50; i += 10) {
                    const y = canvas.height - 80 - i * scale;
                    if (y > 50) {
                        ctx.fillText(`${i}m`, 45, y + 3);
                    }
                }
            }

            drawTrajectory(ctx, points) {
                if (points.length < 2) return;
                
                    ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                
                points.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();

                // 绘制时间标记点
                ctx.fillStyle = '#4361ee';
                points.forEach((point, index) => {
                    if (index % 5 === 0) { // 每0.5秒标记一次
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.fillStyle = '#666';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${point.t.toFixed(1)}s`, point.x, point.y - 8);
                        ctx.fillStyle = '#4361ee';
                    }
                });
            }

            drawTheoreticalTrajectory(ctx, canvas, vx, vy, gravity, scale) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                
                const maxTime = (2 * vy) / gravity;
                for (let t = 0; t <= maxTime; t += 0.1) {
                    const x = 50 + vx * t * scale;
                    const y = canvas.height - 80 - (vy * t - 0.5 * gravity * t * t) * scale;
                    
                    if (t === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
            }

            drawProjectile(ctx, x, y, vx, vy) {
                // 主体抛体
                const gradient = ctx.createRadialGradient(x - 4, y - 4, 0, x, y, 10);
                gradient.addColorStop(0, '#ff8888');
                gradient.addColorStop(1, '#ff4444');
                
                ctx.fillStyle = gradient;
                        ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                        ctx.fill();

                // 运动轨迹效果
                const speed = Math.sqrt(vx * vx + vy * vy);
                ctx.fillStyle = `rgba(255, 68, 68, ${Math.min(0.5, speed * 0.02)})`;
                ctx.beginPath();
                ctx.arc(x - vx * 0.5, y + vy * 0.5, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#cc0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.stroke();
            }

            drawVelocityComponents(ctx, x, y, vx, vy) {
                const scale = 5;
                
                // 总速度矢量
                        ctx.strokeStyle = '#ff6b35';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                ctx.lineTo(x + vx * scale, y - vy * scale);
                        ctx.stroke();
                this.drawArrowHead(ctx, x + vx * scale, y - vy * scale, Math.atan2(-vy, vx), '#ff6b35');
                
                // 水平分量
                ctx.strokeStyle = '#35ff6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + vx * scale, y);
                ctx.stroke();
                this.drawArrowHead(ctx, x + vx * scale, y, 0, '#35ff6b');
                
                // 垂直分量
                ctx.strokeStyle = '#6b35ff';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y - vy * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, x, y - vy * scale, -Math.PI/2, '#6b35ff');
                ctx.setLineDash([]);
                
                // 速度标签
                ctx.fillStyle = '#333';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`v=${Math.sqrt(vx*vx+vy*vy).toFixed(1)}`, x + vx * scale + 5, y - vy * scale - 5);
                ctx.fillText(`vₓ=${vx.toFixed(1)}`, x + vx * scale + 5, y + 12);
                ctx.fillText(`vᵧ=${vy.toFixed(1)}`, x - 40, y - vy * scale);
            }

            drawArrowHead(ctx, x, y, angle, color) {
                ctx.fillStyle = color;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-8, -3);
                ctx.lineTo(-8, 3);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            drawTangentAndNormal(ctx, x, y, vx, vy) {
                if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) return;
                
                const speed = Math.sqrt(vx * vx + vy * vy);
                const unitX = vx / speed;
                const unitY = vy / speed;
                
                // 切线方向
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([2, 4]);
                ctx.beginPath();
                ctx.moveTo(x - unitX * 30, y + unitY * 30);
                ctx.lineTo(x + unitX * 30, y - unitY * 30);
                ctx.stroke();
                
                // 法线方向（垂直于切线）
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.moveTo(x - unitY * 20, y - unitX * 20);
                ctx.lineTo(x + unitY * 20, y + unitX * 20);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            simulatePendulum() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const length = parseFloat(document.getElementById('pendulum-length').value);
                const initialAngle = parseFloat(document.getElementById('pendulum-angle').value) * Math.PI / 180;
                const gravity = 9.8;

                let angle = initialAngle;
                let angularVelocity = 0;
                const dt = 0.01;
                const scale = 200; // 像素/米
                const damping = 0.995; // 阻尼系数

                const centerX = canvas.width / 2;
                const centerY = 100;
                
                // 用于绘制相位图的数据
                const phaseData = [];
                const energyData = [];
                let time = 0;
                
                // 理论周期计算
                const theoreticalPeriod = 2 * Math.PI * Math.sqrt(length / gravity);
                const theoreticalFrequency = 1 / theoreticalPeriod;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制背景网格和坐标系
                    this.drawPendulumBackground(ctx, canvas, centerX, centerY, length, scale);

                    // 计算摆球位置
                    const bobX = centerX + length * scale * Math.sin(angle);
                    const bobY = centerY + length * scale * Math.cos(angle);

                    // 绘制摆线
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(bobX, bobY);
                    ctx.stroke();

                    // 绘制固定点
                    ctx.fillStyle = '#666';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // 绘制摆球（增强效果）
                    this.drawPendulumBob(ctx, bobX, bobY, angularVelocity);

                    // 绘制运动轨迹
                    this.drawPendulumTrajectory(ctx, centerX, centerY, length * scale, angle);

                    // 绘制力的分析
                    this.drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity);

                    // 绘制速度矢量
                    this.drawAngularVelocity(ctx, canvas, bobX, bobY, angularVelocity, length);

                    // 绘制相位图
                    this.drawPhasePortrait(ctx, canvas, phaseData);

                    // 绘制能量图表
                    this.drawEnergyPlot(ctx, canvas, energyData, time);

                    // 物理计算（非线性单摆方程）
                    const angularAcceleration = -(gravity / length) * Math.sin(angle);
                    angularVelocity += angularAcceleration * dt;
                    angularVelocity *= damping; // 应用阻尼
                    angle += angularVelocity * dt;

                    // 记录相位数据
                    if (time % 0.1 < dt) {
                        phaseData.push({angle: angle, velocity: angularVelocity});
                        if (phaseData.length > 200) phaseData.shift();
                        
                        // 能量计算
                        const kineticEnergy = 0.5 * length * length * angularVelocity * angularVelocity;
                        const potentialEnergy = gravity * length * (1 - Math.cos(angle));
                        const totalEnergy = kineticEnergy + potentialEnergy;
                        
                        energyData.push({
                            time: time,
                            ke: kineticEnergy,
                            pe: potentialEnergy,
                            total: totalEnergy
                        });
                        if (energyData.length > 300) energyData.shift();
                    }

                    // 计算实际周期（通过零点检测）
                    const currentPeriod = this.calculatePeriod(angle, angularVelocity, time);
                    const actualFrequency = currentPeriod > 0 ? 1 / currentPeriod : 0;

                    // 更新信息
                    const ke = 0.5 * length * length * angularVelocity * angularVelocity;
                    const pe = gravity * length * (1 - Math.cos(angle));
                    const totalEnergy = ke + pe;
                    const maxAngle = Math.acos(1 - totalEnergy / (gravity * length));
                    
                    document.getElementById('mechanics-info').innerHTML = `
                        <strong>单摆运动分析:</strong><br>
                        时间: ${time.toFixed(2)}s<br>
                        角度: ${(angle * 180 / Math.PI).toFixed(2)}°<br>
                        角速度: ${angularVelocity.toFixed(3)} rad/s<br>
                        角加速度: ${(-(gravity/length)*Math.sin(angle)).toFixed(3)} rad/s²<br>
                        <strong>能量分析:</strong><br>
                        动能: ${ke.toFixed(4)}J<br>
                        势能: ${pe.toFixed(4)}J<br>
                        总能量: ${totalEnergy.toFixed(4)}J<br>
                        最大角度: ±${(maxAngle * 180 / Math.PI).toFixed(1)}°<br>
                        <strong>周期分析:</strong><br>
                        理论周期: ${theoreticalPeriod.toFixed(3)}s<br>
                        实际周期: ${currentPeriod.toFixed(3)}s<br>
                        频率: ${actualFrequency.toFixed(3)}Hz<br>
                        阻尼比: ${((1 - damping) * 1000).toFixed(1)}‰
                    `;

                    time += dt;
                    this.animations.mechanics = requestAnimationFrame(animate);
                };

                animate();
            }

            drawPendulumBackground(ctx, canvas, centerX, centerY, length, scale) {
                // 绘制摆动范围圆弧
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, length * scale, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 绘制垂直参考线
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX, centerY + length * scale + 20);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 绘制角度标记
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.6)';
                ctx.lineWidth = 1;
                for (let i = -60; i <= 60; i += 15) {
                    const angleRad = i * Math.PI / 180;
                    const x1 = centerX + (length * scale - 10) * Math.sin(angleRad);
                    const y1 = centerY + (length * scale - 10) * Math.cos(angleRad);
                    const x2 = centerX + (length * scale + 10) * Math.sin(angleRad);
                    const y2 = centerY + (length * scale + 10) * Math.cos(angleRad);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    
                    // 角度标签
                    if (i % 30 === 0 && i !== 0) {
                        ctx.fillStyle = '#666';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${i}°`, x2, y2 - 5);
                    }
                }
            }

            drawPendulumBob(ctx, x, y, angularVelocity) {
                // 主体摆球
                const radius = 20;
                const gradient = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, radius);
                gradient.addColorStop(0, '#88ccff');
                gradient.addColorStop(1, '#4361ee');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();

                // 运动模糊效果
                if (Math.abs(angularVelocity) > 0.1) {
                    ctx.fillStyle = `rgba(67, 97, 238, ${Math.min(0.4, Math.abs(angularVelocity) * 0.5)})`;
                    ctx.beginPath();
                    ctx.arc(x - angularVelocity * 50, y, radius * 1.2, 0, 2 * Math.PI);
                    ctx.fill();
                }

                // 边框
                ctx.strokeStyle = '#2c5aa0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();

                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x - 7, y - 7, 6, 0, 2 * Math.PI);
                ctx.fill();
            }

            drawPendulumTrajectory(ctx, centerX, centerY, radius, currentAngle) {
                // 绘制摆动轨迹弧线
                ctx.strokeStyle = 'rgba(67, 97, 238, 0.8)';
                ctx.lineWidth = 4;
                ctx.setLineDash([]);
                
                const startAngle = -Math.PI/3; // -60度
                const endAngle = Math.PI/3; // 60度
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.stroke();
                
                // 高亮当前位置
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, currentAngle - 0.05, currentAngle + 0.05);
                ctx.stroke();
            }

            drawForceAnalysis(ctx, bobX, bobY, angle, length, gravity) {
                const scale = 20;
                const mg = gravity; // 简化显示
                
                // 重力 (向下)
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(bobX, bobY + mg * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, bobX, bobY + mg * scale, Math.PI/2, '#ff4444');
                
                // 重力的切向分量
                const tangentialForce = mg * Math.sin(angle);
                const tangentX = bobX - tangentialForce * scale * Math.cos(angle);
                const tangentY = bobY - tangentialForce * scale * Math.sin(angle);
                
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(tangentX, tangentY);
                ctx.stroke();
                this.drawArrowHead(ctx, tangentX, tangentY, angle - Math.PI/2, '#ff8800');
                
                // 重力的径向分量
                const radialForce = mg * Math.cos(angle);
                const radialX = bobX - radialForce * scale * Math.sin(angle);
                const radialY = bobY - radialForce * scale * Math.cos(angle);
                
                ctx.strokeStyle = '#8844ff';
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(radialX, radialY);
                ctx.stroke();
                this.drawArrowHead(ctx, radialX, radialY, angle + Math.PI, '#8844ff');
                ctx.setLineDash([]);
                
                // 力的标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('mg', bobX + 5, bobY + mg * scale);
                ctx.fillText('mg sin θ', tangentX + 5, tangentY);
                ctx.fillText('mg cos θ', radialX + 5, radialY);
            }

            drawAngularVelocity(ctx, canvas, bobX, bobY, angularVelocity, length) {
                if (Math.abs(angularVelocity) < 0.01) return;
                
                const scale = 100;
                const velocityMagnitude = Math.abs(angularVelocity) * length * scale;
                const direction = angularVelocity > 0 ? 1 : -1;
                
                // 切向速度矢量
                const vx = bobX + velocityMagnitude * direction * Math.cos(Math.atan2(bobY - 100, bobX - canvas.width/2) + Math.PI/2);
                const vy = bobY + velocityMagnitude * direction * Math.sin(Math.atan2(bobY - 100, bobX - canvas.width/2) + Math.PI/2);
                
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bobX, bobY);
                ctx.lineTo(vx, vy);
                ctx.stroke();
                
                const angle = Math.atan2(vy - bobY, vx - bobX);
                this.drawArrowHead(ctx, vx, vy, angle, '#00ff88');
                
                // 速度标签
                ctx.fillStyle = '#00aa66';
                ctx.font = 'bold 10px Arial';
                ctx.fillText(`v=${Math.abs(angularVelocity * length).toFixed(2)}m/s`, vx + 5, vy);
            }

            drawPhasePortrait(ctx, canvas, phaseData) {
                if (phaseData.length < 2) return;
                
                const plotX = canvas.width - 200;
                const plotY = 50;
                const plotWidth = 140;
                const plotHeight = 140;
                
                // 绘制相位图背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 坐标轴
                ctx.beginPath();
                ctx.moveTo(plotX + plotWidth/2, plotY);
                ctx.lineTo(plotX + plotWidth/2, plotY + plotHeight);
                ctx.moveTo(plotX, plotY + plotHeight/2);
                ctx.lineTo(plotX + plotWidth, plotY + plotHeight/2);
                ctx.stroke();
                
                // 绘制相位轨迹
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                phaseData.forEach((point, index) => {
                    const x = plotX + plotWidth/2 + (point.angle / Math.PI) * plotWidth * 0.4;
                    const y = plotY + plotHeight/2 - point.velocity * plotHeight * 0.1;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('相位图', plotX + plotWidth/2, plotY - 5);
                ctx.fillText('θ', plotX + plotWidth + 5, plotY + plotHeight/2);
                ctx.save();
                ctx.translate(plotX - 10, plotY + plotHeight/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('ω', 0, 0);
                ctx.restore();
            }

            drawEnergyPlot(ctx, canvas, energyData, currentTime) {
                if (energyData.length < 2) return;
                
                const plotX = 50;
                const plotY = canvas.height - 150;
                const plotWidth = 300;
                const plotHeight = 100;
                
                // 绘制能量图背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 找出最大能量用于归一化
                const maxEnergy = Math.max(...energyData.map(d => d.total));
                
                // 绘制能量曲线
                const colors = {ke: '#ff6b35', pe: '#4361ee', total: '#333'};
                const labels = {ke: '动能', pe: '势能', total: '总能量'};
                
                Object.keys(colors).forEach(energyType => {
                    ctx.strokeStyle = colors[energyType];
                    ctx.lineWidth = energyType === 'total' ? 3 : 2;
                    ctx.setLineDash(energyType === 'total' ? [5, 5] : []);
                    ctx.beginPath();
                    
                    energyData.forEach((point, index) => {
                        const x = plotX + (index / energyData.length) * plotWidth;
                        const y = plotY + plotHeight - (point[energyType] / maxEnergy) * plotHeight;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                });
                ctx.setLineDash([]);
                
                // 图例
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                Object.keys(colors).forEach((energyType, index) => {
                    ctx.fillStyle = colors[energyType];
                    ctx.fillRect(plotX + 10, plotY + 10 + index * 15, 10, 2);
                    ctx.fillStyle = '#333';
                    ctx.fillText(labels[energyType], plotX + 25, plotY + 15 + index * 15);
                });
                
                ctx.textAlign = 'center';
                ctx.fillText('能量-时间图', plotX + plotWidth/2, plotY - 5);
            }

            calculatePeriod(angle, angularVelocity, time) {
                // 简化的周期计算：检测角度零点
                if (!this.lastZeroCrossing) this.lastZeroCrossing = 0;
                if (!this.zeroCrossings) this.zeroCrossings = [];
                
                if (Math.abs(angle) < 0.01 && angularVelocity > 0) {
                    if (time - this.lastZeroCrossing > 1) { // 避免噪音
                        this.zeroCrossings.push(time);
                        this.lastZeroCrossing = time;
                        
                        if (this.zeroCrossings.length >= 3) {
                            const period = 2 * (this.zeroCrossings[this.zeroCrossings.length - 1] - 
                                            this.zeroCrossings[this.zeroCrossings.length - 3]);
                            return period;
                        }
                    }
                }
                
                return 0;
            }

            resetMechanicsSimulation() {
                this.isRunning.mechanics = false;
                if (this.animations.mechanics) {
                    cancelAnimationFrame(this.animations.mechanics);
                }
                this.contexts.mechanics.clearRect(0, 0, this.canvases.mechanics.width, this.canvases.mechanics.height);
                document.getElementById('mechanics-info').textContent = '点击开始模拟查看实时数据';
            }

            pauseMechanicsSimulation() {
                this.isRunning.mechanics = !this.isRunning.mechanics;
                if (this.isRunning.mechanics) {
                    const type = document.getElementById('mechanics-type').value;
                    if (type === 'projectile') {
                        this.simulateProjectileMotion();
                    } else if (type === 'pendulum') {
                        this.simulatePendulum();
                    } else if (type === 'collision') {
                        this.simulateCollision();
                    } else if (type === 'spring') {
                        this.simulateSpring();
                    }
                }
            }

            simulateCollision() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const m1 = parseFloat(document.getElementById('mass1').value);
                const m2 = parseFloat(document.getElementById('mass2').value);
                let v1 = parseFloat(document.getElementById('velocity1').value);
                let v2 = parseFloat(document.getElementById('velocity2').value);
                const e = parseFloat(document.getElementById('restitution').value);

                // 初始化多个碰撞球体
                const balls = [
                    {
                        id: 1,
                        x: 150,
                        y: canvas.height / 2,
                        vx: v1,
                        vy: 0,
                        mass: m1,
                        radius: Math.max(15, Math.min(35, m1 * 12)),
                        color: '#ff4444',
                        trail: []
                    },
                    {
                        id: 2,
                        x: canvas.width - 150,
                        y: canvas.height / 2,
                        vx: -v2,
                        vy: 0,
                        mass: m2,
                        radius: Math.max(15, Math.min(35, m2 * 12)),
                        color: '#4444ff',
                        trail: []
                    }
                ];

                let time = 0;
                let collisionOccurred = false;
                let collisionTime = 0;
                const dt = 0.016; // 60 FPS
                
                // 保存初始动量和能量
                const initialMomentum = {
                    x: m1 * v1 + m2 * (-v2),
                    y: 0
                };
                const initialKE = 0.5 * m1 * v1 * v1 + 0.5 * m2 * v2 * v2;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制实验室坐标系
                    this.drawLabFrame(ctx, canvas);

                    // 绘制质心坐标系
                    this.drawCenterOfMassFrame(ctx, canvas, balls);

                    // 更新球体位置
                    balls.forEach(ball => {
                        ball.x += ball.vx * dt * 60; // 像素/秒转换
                        ball.y += ball.vy * dt * 60;
                        
                        // 记录轨迹
                        if (time % 0.1 < dt) {
                            ball.trail.push({x: ball.x, y: ball.y, time: time});
                            if (ball.trail.length > 100) ball.trail.shift();
                        }

                    // 边界反弹
                        if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
                            ball.vx *= -0.9; // 轻微能量损失
                            ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
                        }
                        if (ball.y - ball.radius <= 0 || ball.y + ball.radius >= canvas.height) {
                            ball.vy *= -0.9;
                            ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));
                        }
                    });

                    // 检测和处理碰撞
                    this.handleCollisions(balls, e, ctx);

                    // 绘制轨迹
                    balls.forEach(ball => {
                        this.drawTrail(ctx, ball.trail, ball.color);
                    });

                    // 绘制球体
                    balls.forEach(ball => {
                        this.drawCollisionBall(ctx, ball);
                    });

                    // 绘制速度矢量
                    balls.forEach(ball => {
                        this.drawVelocityVector2D(ctx, ball);
                    });

                    // 绘制动量守恒分析
                    this.drawMomentumAnalysis(ctx, canvas, balls, initialMomentum);

                    // 绘制能量分析图表
                    this.drawEnergyConservationChart(ctx, canvas, balls, initialKE, time);

                    // 计算当前物理量
                    const currentMomentum = {
                        x: balls.reduce((sum, ball) => sum + ball.mass * ball.vx, 0),
                        y: balls.reduce((sum, ball) => sum + ball.mass * ball.vy, 0)
                    };
                    const currentKE = balls.reduce((sum, ball) => 
                        sum + 0.5 * ball.mass * (ball.vx * ball.vx + ball.vy * ball.vy), 0);
                    
                    const momentumMagnitude = Math.sqrt(currentMomentum.x * currentMomentum.x + currentMomentum.y * currentMomentum.y);
                    const initialMomentumMagnitude = Math.sqrt(initialMomentum.x * initialMomentum.x + initialMomentum.y * initialMomentum.y);
                    
                    // 计算质心
                    const totalMass = balls.reduce((sum, ball) => sum + ball.mass, 0);
                    const cmVx = currentMomentum.x / totalMass;
                    const cmVy = currentMomentum.y / totalMass;
                    
                    document.getElementById('mechanics-info').innerHTML = `
                        <strong>碰撞实验分析:</strong><br>
                        时间: ${time.toFixed(2)}s<br>
                        <strong>球体1:</strong> v = ${Math.sqrt(balls[0].vx*balls[0].vx + balls[0].vy*balls[0].vy).toFixed(2)} m/s<br>
                        <strong>球体2:</strong> v = ${Math.sqrt(balls[1].vx*balls[1].vx + balls[1].vy*balls[1].vy).toFixed(2)} m/s<br>
                        <strong>守恒定律验证:</strong><br>
                        动量守恒: ${((Math.abs(momentumMagnitude - initialMomentumMagnitude) < 0.1) ? '✓' : '✗')}<br>
                        初始动量: ${initialMomentumMagnitude.toFixed(3)} kg⋅m/s<br>
                        当前动量: ${momentumMagnitude.toFixed(3)} kg⋅m/s<br>
                        <strong>能量分析:</strong><br>
                        初始动能: ${initialKE.toFixed(3)} J<br>
                        当前动能: ${currentKE.toFixed(3)} J<br>
                        能量损失: ${((initialKE - currentKE) / initialKE * 100).toFixed(1)}%<br>
                        <strong>质心运动:</strong><br>
                        质心速度: (${cmVx.toFixed(2)}, ${cmVy.toFixed(2)}) m/s<br>
                        恢复系数: ${e}
                    `;

                    time += dt;
                    this.animations.mechanics = requestAnimationFrame(animate);
                };

                animate();
            }

            drawLabFrame(ctx, canvas) {
                // 绘制实验室坐标系网格
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                for (let x = 0; x <= canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // 绘制坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.moveTo(50, 0);
                ctx.lineTo(50, canvas.height);
                ctx.stroke();

                // 坐标轴标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('实验室坐标系', canvas.width / 2, 20);
                ctx.fillText('x', canvas.width - 20, canvas.height / 2 - 10);
                ctx.fillText('y', 60, 20);
            }

            drawCenterOfMassFrame(ctx, canvas, balls) {
                // 计算质心位置
                const totalMass = balls.reduce((sum, ball) => sum + ball.mass, 0);
                const cmX = balls.reduce((sum, ball) => sum + ball.mass * ball.x, 0) / totalMass;
                const cmY = balls.reduce((sum, ball) => sum + ball.mass * ball.y, 0) / totalMass;

                // 绘制质心
                ctx.fillStyle = '#ff6b35';
                ctx.strokeStyle = '#cc4400';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                ctx.arc(cmX, cmY, 8, 0, 2 * Math.PI);
                ctx.fill();
                    ctx.stroke();

                // 质心标签
                ctx.fillStyle = '#cc4400';
                ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                ctx.fillText('CM', cmX, cmY - 15);

                // 绘制质心坐标系（相对于质心的虚线）
                ctx.strokeStyle = 'rgba(255, 107, 53, 0.5)';
                ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                ctx.moveTo(cmX - 100, cmY);
                ctx.lineTo(cmX + 100, cmY);
                ctx.moveTo(cmX, cmY - 50);
                ctx.lineTo(cmX, cmY + 50);
                    ctx.stroke();
                    ctx.setLineDash([]);
            }

            handleCollisions(balls, restitution, ctx) {
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        const ball1 = balls[i];
                        const ball2 = balls[j];
                        
                        const dx = ball2.x - ball1.x;
                        const dy = ball2.y - ball1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < ball1.radius + ball2.radius) {
                            // 碰撞检测成功，进行2D弹性碰撞计算
                            
                            // 单位法向量
                            const nx = dx / distance;
                            const ny = dy / distance;
                            
                            // 单位切向量
                            const tx = -ny;
                            const ty = nx;
                            
                            // 投影速度到法向和切向
                            const v1n = ball1.vx * nx + ball1.vy * ny;
                            const v1t = ball1.vx * tx + ball1.vy * ty;
                            const v2n = ball2.vx * nx + ball2.vy * ny;
                            const v2t = ball2.vx * tx + ball2.vy * ty;
                            
                            // 2D弹性碰撞公式
                            const v1nNew = ((ball1.mass - restitution * ball2.mass) * v1n + 
                                           ball2.mass * (1 + restitution) * v2n) / (ball1.mass + ball2.mass);
                            const v2nNew = ((ball2.mass - restitution * ball1.mass) * v2n + 
                                           ball1.mass * (1 + restitution) * v1n) / (ball1.mass + ball2.mass);
                            
                            // 切向速度保持不变
                            const v1tNew = v1t;
                            const v2tNew = v2t;
                            
                            // 转换回直角坐标系
                            ball1.vx = v1nNew * nx + v1tNew * tx;
                            ball1.vy = v1nNew * ny + v1tNew * ty;
                            ball2.vx = v2nNew * nx + v2tNew * tx;
                            ball2.vy = v2nNew * ny + v2tNew * ty;
                            
                            // 分离重叠的球体
                            const overlap = ball1.radius + ball2.radius - distance;
                            ball1.x -= overlap * 0.5 * nx;
                            ball1.y -= overlap * 0.5 * ny;
                            ball2.x += overlap * 0.5 * nx;
                            ball2.y += overlap * 0.5 * ny;
                            
                            // 碰撞特效
                            this.createCollisionEffect(ctx, (ball1.x + ball2.x) / 2, (ball1.y + ball2.y) / 2);
                        }
                    }
                }
            }

            drawTrail(ctx, trail, color) {
                if (trail.length < 2) return;
                
                ctx.strokeStyle = color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                
                trail.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
            }

            drawCollisionBall(ctx, ball) {
                // 主体球
                const gradient = ctx.createRadialGradient(
                    ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0,
                    ball.x, ball.y, ball.radius
                );
                gradient.addColorStop(0, ball.color.replace('44', '88'));
                gradient.addColorStop(1, ball.color);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                ctx.fill();

                // 边框
                ctx.strokeStyle = ball.color.replace('44', '22');
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                ctx.stroke();

                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.2, 0, 2 * Math.PI);
                ctx.fill();

                // 球体标签
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${ball.id}`, ball.x, ball.y + 4);
                ctx.fillText(`${ball.mass}kg`, ball.x, ball.y + ball.radius + 15);
            }

            drawVelocityVector2D(ctx, ball) {
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (speed < 0.1) return;
                
                const scale = 20;
                const vx = ball.vx * scale;
                const vy = ball.vy * scale;
                
                // 速度矢量
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + vx, ball.y + vy);
                ctx.stroke();
                
                // 箭头
                const angle = Math.atan2(vy, vx);
                this.drawArrowHead(ctx, ball.x + vx, ball.y + vy, angle, '#00ff88');
                
                // 速度分量
                ctx.strokeStyle = '#88ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                
                // x分量
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + vx, ball.y);
                ctx.stroke();
                
                // y分量
                    ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x, ball.y + vy);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 速度标签
                ctx.fillStyle = '#006644';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`v=${speed.toFixed(1)}m/s`, ball.x + vx + 5, ball.y + vy - 5);
                ctx.fillText(`vₓ=${ball.vx.toFixed(1)}`, ball.x + vx + 5, ball.y + 10);
                ctx.fillText(`vᵧ=${ball.vy.toFixed(1)}`, ball.x - 40, ball.y + vy);
            }

            drawMomentumAnalysis(ctx, canvas, balls, initialMomentum) {
                const plotX = canvas.width - 250;
                const plotY = 50;
                const plotWidth = 200;
                const plotHeight = 150;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 标题
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('动量分析', plotX + plotWidth/2, plotY + 20);
                
                // 计算当前总动量
                const currentMomentum = {
                    x: balls.reduce((sum, ball) => sum + ball.mass * ball.vx, 0),
                    y: balls.reduce((sum, ball) => sum + ball.mass * ball.vy, 0)
                };
                
                const scale = 5;
                const centerX = plotX + plotWidth/2;
                const centerY = plotY + plotHeight/2 + 20;
                
                // 绘制坐标轴
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                            ctx.beginPath();
                ctx.moveTo(plotX + 20, centerY);
                ctx.lineTo(plotX + plotWidth - 20, centerY);
                ctx.moveTo(centerX, plotY + 30);
                ctx.lineTo(centerX, plotY + plotHeight - 20);
                            ctx.stroke();

                // 初始动量矢量
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                            ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + initialMomentum.x * scale, centerY - initialMomentum.y * scale);
                            ctx.stroke();
                this.drawArrowHead(ctx, centerX + initialMomentum.x * scale, centerY - initialMomentum.y * scale,
                                  Math.atan2(-initialMomentum.y, initialMomentum.x), '#ff6b35');
                
                // 当前动量矢量
                ctx.strokeStyle = '#4361ee';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + currentMomentum.x * scale, centerY - currentMomentum.y * scale);
                ctx.stroke();
                this.drawArrowHead(ctx, centerX + currentMomentum.x * scale, centerY - currentMomentum.y * scale,
                                  Math.atan2(-currentMomentum.y, currentMomentum.x), '#4361ee');
                
                // 图例
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ff6b35';
                ctx.fillText('初始动量', plotX + 10, plotY + plotHeight - 25);
                ctx.fillStyle = '#4361ee';
                ctx.fillText('当前动量', plotX + 10, plotY + plotHeight - 10);
            }

            drawEnergyConservationChart(ctx, canvas, balls, initialKE, time) {
                const plotX = 50;
                const plotY = canvas.height - 120;
                const plotWidth = 400;
                const plotHeight = 80;
                
                // 背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
                
                // 计算当前能量
                const currentKE = balls.reduce((sum, ball) => 
                    sum + 0.5 * ball.mass * (ball.vx * ball.vx + ball.vy * ball.vy), 0);
                
                // 能量条形图
                const barWidth = 60;
                const maxEnergy = Math.max(initialKE, currentKE);
                
                // 初始动能
                const initialHeight = (initialKE / maxEnergy) * (plotHeight - 40);
                ctx.fillStyle = '#ff6b35';
                ctx.fillRect(plotX + 50, plotY + plotHeight - 20 - initialHeight, barWidth, initialHeight);
                
                // 当前动能
                const currentHeight = (currentKE / maxEnergy) * (plotHeight - 40);
                ctx.fillStyle = '#4361ee';
                ctx.fillRect(plotX + 150, plotY + plotHeight - 20 - currentHeight, barWidth, currentHeight);
                
                // 损失的能量
                const lossHeight = ((initialKE - currentKE) / maxEnergy) * (plotHeight - 40);
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(plotX + 250, plotY + plotHeight - 20 - lossHeight, barWidth, lossHeight);
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('初始', plotX + 80, plotY + plotHeight - 5);
                ctx.fillText('当前', plotX + 180, plotY + plotHeight - 5);
                ctx.fillText('损失', plotX + 280, plotY + plotHeight - 5);
                
                ctx.font = 'bold 12px Arial';
                ctx.fillText('能量守恒分析', plotX + plotWidth/2, plotY + 15);
            }

            createCollisionEffect(ctx, x, y) {
                // 创建爆炸式粒子效果
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    const distance = Math.random() * 30 + 10;
                    const particleX = x + Math.cos(angle) * distance;
                    const particleY = y + Math.sin(angle) * distance;
                    
                    ctx.fillStyle = `hsl(${Math.random() * 60 + 15}, 100%, 60%)`;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, Math.random() * 3 + 1, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // 冲击波效果
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                        ctx.beginPath();
                ctx.arc(x, y, 25, 0, 2 * Math.PI);
                        ctx.stroke();
                    }

            createBounceEffect(ctx, x, y) {
                // 反弹效果
                for (let i = 0; i < 8; i++) {
                    const angle = Math.PI + (Math.PI * i) / 8;
                    const distance = Math.random() * 15 + 5;
                    const particleX = x + Math.cos(angle) * distance;
                    const particleY = y + Math.sin(angle) * distance;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 - Math.random() * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, Math.random() * 2 + 1, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            drawGrid(ctx, canvas) {
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                // 垂直线
                for (let x = 0; x <= canvas.width; x += 40) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // 水平线
                for (let y = 0; y <= canvas.height; y += 40) {
                        ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                }
                
                ctx.setLineDash([]);
            }

            simulateSpring() {
                const canvas = this.canvases.mechanics;
                const ctx = this.contexts.mechanics;
                
                const k = parseFloat(document.getElementById('spring-k').value);
                const mass = parseFloat(document.getElementById('spring-mass').value);
                const damping = parseFloat(document.getElementById('damping').value);
                let displacement = parseFloat(document.getElementById('spring-displacement').value);
                
                let velocity = 0;
                let time = 0;
                const dt = 0.02;
                const equilibriumY = canvas.height / 2;
                const scale = 100; // 像素/米
                
                // 弹簧参数
                const springX = canvas.width / 2;
                const springTopY = 50;
                const naturalLength = 200;

                const animate = () => {
                    if (!this.isRunning.mechanics) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制背景网格
                    this.drawGrid(ctx, canvas);

                    // 计算当前位置
                    const massY = equilibriumY + displacement * scale;
                    const springLength = massY - springTopY;
                    
                    // 绘制固定点
                    ctx.fillStyle = '#666';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                        ctx.beginPath();
                    ctx.arc(springX, springTopY, 8, 0, 2 * Math.PI);
                    ctx.fill();
                        ctx.stroke();
                    
                    // 绘制弹簧 - 增强可视化
                    this.drawSpring(ctx, springX, springTopY, springX, massY, springLength, naturalLength);
                    
                    // 绘制质量块 - 3D效果
                    const massSize = Math.max(20, Math.min(40, mass * 15));
                    this.drawMass(ctx, springX, massY, massSize, velocity);
                    
                    // 绘制速度和加速度矢量
                    let acceleration = (-k * displacement - damping * velocity) / mass;
                    this.drawVector(ctx, springX + massSize + 10, massY, velocity * 50, '#ff6b35', 'v', '速度');
                    this.drawVector(ctx, springX + massSize + 60, massY, acceleration * 200, '#35ff6b', 'a', '加速度');
                    
                    // 绘制能量图表
                    this.drawEnergyChart(ctx, displacement, velocity, k, mass);
                    
                    // 物理计算 - 阻尼简谐运动
                    const force = -k * displacement - damping * velocity;
                    acceleration = force / mass;
                    velocity += acceleration * dt;
                    displacement += velocity * dt;
                    
                    // 计算能量
                    const kineticEnergy = 0.5 * mass * velocity * velocity;
                    const potentialEnergy = 0.5 * k * displacement * displacement;
                    const totalEnergy = kineticEnergy + potentialEnergy;
                    const omega = Math.sqrt(k / mass);
                    const period = 2 * Math.PI / omega;
                    
                    // 更新信息
                    document.getElementById('mechanics-info').innerHTML = `
                        <strong>简谐运动数据:</strong><br>
                        时间: ${time.toFixed(2)}s<br>
                        位移: ${displacement.toFixed(3)}m<br>
                        速度: ${velocity.toFixed(3)}m/s<br>
                        加速度: ${acceleration.toFixed(3)}m/s²<br>
                        <strong>能量分析:</strong><br>
                        动能: ${kineticEnergy.toFixed(3)}J<br>
                        势能: ${potentialEnergy.toFixed(3)}J<br>
                        总能量: ${totalEnergy.toFixed(3)}J<br>
                        <strong>系统参数:</strong><br>
                        角频率: ${omega.toFixed(2)} rad/s<br>
                        周期: ${period.toFixed(2)}s<br>
                        阻尼系数: ${damping}
                    `;

                    time += dt;
                    this.animations.mechanics = requestAnimationFrame(animate);
                };

                animate();
            }

            drawSpring(ctx, x1, y1, x2, y2, currentLength, naturalLength) {
                const coils = 12;
                const amplitude = 15;
                const compression = currentLength / naturalLength;
                const actualAmplitude = amplitude * Math.max(0.3, Math.min(1.5, compression));
                
                ctx.strokeStyle = compression > 1 ? '#ff4444' : '#4361ee';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);

                    ctx.beginPath();
                ctx.moveTo(x1, y1);
                
                for (let i = 0; i <= coils; i++) {
                    const t = i / coils;
                    const y = y1 + t * (y2 - y1);
                    const x = x1 + Math.sin(i * Math.PI) * actualAmplitude;
                    ctx.lineTo(x, y);
                }
                
                    ctx.stroke();

                // 弹簧端点连接
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                    ctx.beginPath();
                ctx.moveTo(x1 - 20, y1);
                ctx.lineTo(x1 + 20, y1);
                ctx.moveTo(x2 - 20, y2);
                ctx.lineTo(x2 + 20, y2);
                    ctx.stroke();
            }

            drawMass(ctx, x, y, size, velocity) {
                // 主体
                const gradient = ctx.createRadialGradient(x - size/3, y - size/3, 0, x, y, size);
                gradient.addColorStop(0, '#8888ff');
                gradient.addColorStop(1, '#4361ee');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x - size/2, y - size/2, size, size);
                
                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillRect(x - size/2 + 2, y - size/2 + 2, size/3, size/3);
                
                // 边框
                ctx.strokeStyle = velocity > 0 ? '#ff4444' : velocity < 0 ? '#44ff44' : '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - size/2, y - size/2, size, size);
                
                // 运动模糊效果
                if (Math.abs(velocity) > 0.1) {
                    ctx.fillStyle = `rgba(67, 97, 238, ${Math.min(0.3, Math.abs(velocity) * 0.1)})`;
                    const blurSize = Math.abs(velocity) * 20;
                    ctx.fillRect(x - size/2 - blurSize/2, y - size/2, size + blurSize, size);
                }
            }

            drawVector(ctx, x, y, magnitude, color, label, description) {
                if (Math.abs(magnitude) < 2) return;
                
                const maxLength = 80;
                const length = Math.min(maxLength, Math.abs(magnitude));
                const direction = magnitude > 0 ? 1 : -1;
                
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 3;
                
                // 矢量主体
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + length * direction);
                ctx.stroke();
                
                // 箭头
                const arrowSize = 8;
                ctx.beginPath();
                ctx.moveTo(x, y + length * direction);
                ctx.lineTo(x - arrowSize/2, y + length * direction - arrowSize * direction);
                ctx.lineTo(x + arrowSize/2, y + length * direction - arrowSize * direction);
                ctx.closePath();
                ctx.fill();
                
                // 标签
                ctx.fillStyle = color;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, y + length * direction + 20 * direction);
                
                // 数值
                ctx.font = '10px Arial';
                ctx.fillText(`${(magnitude/50).toFixed(2)}`, x + 15, y + length * direction / 2);
            }

            drawEnergyChart(ctx, displacement, velocity, k, mass) {
                const chartX = 50;
                const chartY = 50;
                const chartWidth = 150;
                const chartHeight = 80;
                
                // 图表背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(chartX, chartY, chartWidth, chartHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(chartX, chartY, chartWidth, chartHeight);
                
                // 计算能量
                const kineticEnergy = 0.5 * mass * velocity * velocity;
                const potentialEnergy = 0.5 * k * displacement * displacement;
                const totalEnergy = kineticEnergy + potentialEnergy;
                const maxEnergy = Math.max(totalEnergy, 1);
                
                // 动能条
                const keHeight = (kineticEnergy / maxEnergy) * (chartHeight - 20);
                ctx.fillStyle = '#ff6b35';
                ctx.fillRect(chartX + 10, chartY + chartHeight - 10 - keHeight, 30, keHeight);
                
                // 势能条
                const peHeight = (potentialEnergy / maxEnergy) * (chartHeight - 20);
                ctx.fillStyle = '#4361ee';
                ctx.fillRect(chartX + 50, chartY + chartHeight - 10 - peHeight, 30, peHeight);
                
                // 总能量线
                const teHeight = (totalEnergy / maxEnergy) * (chartHeight - 20);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(chartX + 5, chartY + chartHeight - 10 - teHeight);
                ctx.lineTo(chartX + chartWidth - 5, chartY + chartHeight - 10 - teHeight);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 标签
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('KE', chartX + 25, chartY + chartHeight + 12);
                ctx.fillText('PE', chartX + 65, chartY + chartHeight + 12);
                ctx.fillText('能量图', chartX + chartWidth/2, chartY - 5);
            }
        }

        // 初始化模拟器
        document.addEventListener('DOMContentLoaded', () => {
            new PhysicsSimulator();
        });
    </script>
</body>
</html> 