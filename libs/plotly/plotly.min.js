/* Enhanced Offline Plotly Fallback */
window.Plotly = window.Plotly || {};

// Tooltip functions
function createTooltip() {
  const tooltip = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  tooltip.setAttribute('class', 'plotly-tooltip');
  tooltip.setAttribute('visibility', 'hidden');
  tooltip.setAttribute('pointer-events', 'none');
  
  const rect = createSVGElement('rect', {
    rx: '4', ry: '4',
    fill: 'rgba(0,0,0,0.8)',
    stroke: '#fff', 'stroke-width': '1'
  });
  
  const text = createSVGElement('text', {
    fill: '#fff', 'font-size': '12',
    x: '8', y: '16'
  });
  
  tooltip.appendChild(rect);
  tooltip.appendChild(text);
  return tooltip;
}

function showTooltip(tooltip, event, label, value) {
  const text = tooltip.querySelector('text');
  const rect = tooltip.querySelector('rect');
  
  text.textContent = `${label}: ${value}`;
  const bbox = text.getBBox();
  
  rect.setAttribute('width', bbox.width + 16);
  rect.setAttribute('height', bbox.height + 12);
  rect.setAttribute('x', '-8');
  rect.setAttribute('y', `-${bbox.height + 8}`);
  
  tooltip.setAttribute('transform', `translate(${event.clientX}, ${event.clientY - 20})`);
  tooltip.setAttribute('visibility', 'visible');
}

function hideTooltip(tooltip) {
  tooltip.setAttribute('visibility', 'hidden');
}

// Helper function to create SVG elements
function createSVGElement(tag, attrs = {}) {
    if (typeof attrs !== 'object' || attrs === null) {
        attrs = {};
    }
    const elem = document.createElementNS('http://www.w3.org/2000/svg', tag);
    Object.keys(attrs || {}).forEach(key => elem.setAttribute(key, attrs[key]));
    return elem;
}

// Simple plotting function with basic chart rendering
Plotly.newPlot = function(element, data, layout, config) {
  if (typeof element === 'string') {
    element = document.getElementById(element);
  }
  
  if (!element) {
    console.error('Invalid element for plotting');
    return;
  }
  
  console.log('Local Plotly fallback creating placeholder visualization');
  
  // Create placeholder visualization
  element.innerHTML = '';
  element.style.position = 'relative';
  element.style.width = (layout && layout.width) ? layout.width + 'px' : '100%';
  element.style.height = (layout && layout.height) ? layout.height + 'px' : '400px';
  element.style.border = '1px solid #ddd';
  element.style.borderRadius = '8px';
  element.style.backgroundColor = '#f9f9f9';
  element.style.overflow = 'hidden';
  
  // Add title if available
  if (layout && layout.title) {
    var title = document.createElement('div');
    title.style.textAlign = 'center';
    title.style.padding = '10px';
    title.style.fontWeight = 'bold';
    title.style.fontSize = '16px';
    title.textContent = typeof layout.title === 'object' ? layout.title.text : layout.title;
    element.appendChild(title);
  }
  
  // Add message
  var message = document.createElement('div');
  message.style.position = 'absolute';
  message.style.top = '50%';
  message.style.left = '50%';
  message.style.transform = 'translate(-50%, -50%)';
  message.style.textAlign = 'center';
  message.style.width = '80%';
  message.style.color = '#666';
  
  // Create SVG chart container
  const svgWidth = element.clientWidth || 600;
  const svgHeight = element.clientHeight || 400;
  const margin = { top: 40, right: 30, bottom: 40, left: 60 };
  const chartWidth = svgWidth - margin.left - margin.right;
  const chartHeight = svgHeight - margin.top - margin.bottom;

  // Create SVG element
  const svg = createSVGElement('svg', {
    width: '100%',
    height: '100%',
    viewBox: `0 0 ${svgWidth} ${svgHeight}`,
    preserveAspectRatio: 'xMidYMid meet'
  });
  element.appendChild(svg);

  // Add title
  if (layout && layout.title) {
    const title = document.createElement('div');
    title.style.position = 'absolute';
    title.style.top = '10px';
    title.style.left = '50%';
    title.style.transform = 'translateX(-50%)';
    title.style.fontWeight = 'bold';
    title.style.fontSize = '16px';
    title.textContent = typeof layout.title === 'object' ? layout.title.text : layout.title;
    element.appendChild(title);
  }

  // Determine chart type and render
  if (data && data.length) {
    if (data[0].type === 'pie') {
      // Render simple pie chart
      const radius = Math.min(chartWidth, chartHeight) / 2;
      const centerX = margin.left + chartWidth / 2;
      const centerY = margin.top + chartHeight / 2;
      const total = data[0].values.reduce((a, b) => a + b, 0);
      let startAngle = 0;

      const pieGroup = createSVGElement('g', { transform: `translate(${centerX}, ${centerY})` });
svg.appendChild(pieGroup);

// Add tooltip
const tooltip = createTooltip();
svg.appendChild(tooltip);

      // Create pie slices
      data[0].values.forEach((value, i) => {
        const sliceAngle = 2 * Math.PI * value / total;
        const endAngle = startAngle + sliceAngle;
        const color = data[0].marker?.colors?.[i] || `hsl(${(i * 75) % 360}, 70%, 60%)`;

        // Calculate path points
        const startX = radius * Math.sin(startAngle);
        const startY = -radius * Math.cos(startAngle);
        const endX = radius * Math.sin(endAngle);
        const endY = -radius * Math.cos(endAngle);
        const largeArcFlag = sliceAngle > Math.PI ? 1 : 0;

        // Create path for slice
        const pathData = [
          `M 0 0`,
          `L ${startX} ${startY}`,
          `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`,
          'Z'
        ].join(' ');

        const slice = createSVGElement('path', {
          d: pathData,
          fill: color,
          stroke: '#fff',
          'stroke-width': '2'
        });
        pieGroup.appendChild(slice);

// Add interactivity
slice.addEventListener('mouseover', (e) => {
  showTooltip(tooltip, e, data[0].labels?.[i] || `数据 ${i+1}`, value);
});
slice.addEventListener('mouseout', () => hideTooltip(tooltip));
slice.addEventListener('click', () => {
  console.log(`Pie slice clicked: ${data[0].labels?.[i] || `数据 ${i+1}`} (${value})`);
});
slice.style.cursor = 'pointer';

        // Add slice label
        const midAngle = startAngle + sliceAngle / 2;
        const labelRadius = radius * 1.2;
        const labelX = labelRadius * Math.sin(midAngle);
        const labelY = -labelRadius * Math.cos(midAngle);

        const label = createSVGElement('text', {
          x: labelX,
          y: labelY,
          'text-anchor': midAngle < Math.PI ? 'start' : 'end',
          'alignment-baseline': 'middle',
          'font-size': '12px'
        });
        label.textContent = data[0].labels?.[i] || `数据 ${i+1}`;
        pieGroup.appendChild(label);

        startAngle = endAngle;
      });
    } else if (data[0].type === 'bar') {
      // Render simple bar chart
      const xAxis = createSVGElement('line', {
        x1: margin.left,
        y1: margin.top + chartHeight,
        x2: margin.left + chartWidth,
        y2: margin.top + chartHeight,
        stroke: '#333',
        'stroke-width': '1'
      });
      svg.appendChild(xAxis);

      const yAxis = createSVGElement('line', {
        x1: margin.left,
        y1: margin.top,
        x2: margin.left,
        y2: margin.top + chartHeight,
        stroke: '#333',
        'stroke-width': '1'
      });
      svg.appendChild(yAxis);

      const barGroup = createSVGElement('g');
      svg.appendChild(barGroup);

// Add tooltip
const tooltip = createTooltip();
svg.appendChild(tooltip);

      const maxValue = Math.max(...data[0].y);
      const barWidth = chartWidth / data[0].y.length * 0.6;

      // Create bars
      data[0].y.forEach((value, i) => {
        const barHeight = (value / maxValue) * chartHeight;
        const x = margin.left + (i * chartWidth / data[0].y.length) + (chartWidth / data[0].y.length - barWidth) / 2;
        const y = margin.top + chartHeight - barHeight;

        const bar = createSVGElement('rect', {
          x: x,
          y: y,
          width: barWidth,
          height: barHeight,
          fill: data[0].marker?.color || `hsl(${(i * 50) % 360}, 70%, 60%)`,
          stroke: '#333',
          'stroke-width': '1'
        });
        barGroup.appendChild(bar);

// Add interactivity
bar.addEventListener('mouseover', (e) => {
  showTooltip(tooltip, e, data[0].x?.[i] || `项目 ${i+1}`, value);
});
bar.addEventListener('mouseout', () => hideTooltip(tooltip));
bar.addEventListener('click', () => {
  console.log(`Bar clicked: ${data[0].x?.[i] || `项目 ${i+1}`} (${value})`);
});
bar.style.cursor = 'pointer';

        // Add bar label
        const label = createSVGElement('text', {
          x: x + barWidth / 2,
          y: y - 5,
          'text-anchor': 'middle',
          'font-size': '12px'
        });
        label.textContent = data[0].x?.[i] || `项目 ${i+1}`;
        barGroup.appendChild(label);
      });
    }
  } else {
    // Show empty state message
    message.innerHTML = '<div style="margin-bottom: 10px; font-size: 14px;">无数据可显示</div>' +
                      '<div style="font-size: 12px;">请检查数据源或刷新页面</div>';
    element.appendChild(message);
  }
  
  element.appendChild(message);
  
  // Add simplified legend if we have data
  if (data && data.length) {
    var legend = document.createElement('div');
    legend.style.position = 'absolute';
    legend.style.bottom = '10px';
    legend.style.right = '10px';
    legend.style.backgroundColor = 'rgba(255,255,255,0.8)';
    legend.style.padding = '5px';
    legend.style.borderRadius = '4px';
    legend.style.fontSize = '12px';
    
    var legendContent = '<div style="font-weight: bold; margin-bottom: 5px;">数据集:</div>';
    for (var i = 0; i < data.length; i++) {
      var color = data[i].marker ? (data[i].marker.color || '#1f77b4') : '#1f77b4';
      var name = data[i].name || '数据 ' + (i + 1);
      legendContent += '<div style="margin: 3px 0;">' +
                       '<span style="display: inline-block; width: 10px; height: 10px; margin-right: 5px; background-color: ' + color + ';"></span>' +
                       name +
                       '</div>';
    }
    
    legend.innerHTML = legendContent;
    element.appendChild(legend);
  }
  
  // Return mock object with common methods
  return {
    element: element,
    data: data,
    layout: layout,
    _context: config,
    
    on: function() { return this; },
    removeListener: function() { return this; },
    
    relayout: function() { 
      console.log('Plotly.relayout called (fallback)'); 
      return Promise.resolve(this); 
    },
    
    restyle: function() { 
      console.log('Plotly.restyle called (fallback)'); 
      return Promise.resolve(this); 
    },
    
    update: function() { 
      console.log('Plotly.update called (fallback)'); 
      return Promise.resolve(this); 
    },
    
    purge: function() {
      if (element) element.innerHTML = '';
    }
  };
};

// Add additional Plotly functions 
Plotly.restyle = function() { console.log('Plotly.restyle called (fallback)'); return Promise.resolve(); };
Plotly.relayout = function() { console.log('Plotly.relayout called (fallback)'); return Promise.resolve(); };
Plotly.update = function() { console.log('Plotly.update called (fallback)'); return Promise.resolve(); };
Plotly.addTraces = function() { console.log('Plotly.addTraces called (fallback)'); return Promise.resolve(); };
Plotly.deleteTraces = function() { console.log('Plotly.deleteTraces called (fallback)'); return Promise.resolve(); };
Plotly.purge = function(element) { if (element) element.innerHTML = ''; };

console.log('Local Plotly loaded with interactive features');