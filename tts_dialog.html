<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>对话语音转换 - 学习助手</title>
    <link rel="icon" href="assets/icons/alex.ico" type="image/x-icon">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/utilities.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #f8fafc 0%, #e0c3fc 100%);
            background-attachment: fixed;
            font-family: 'Poppins', 'PingFang SC', 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .main-content {
            padding: 2rem 0;
            min-height: calc(100vh - 200px);
        }
        .section-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .section-header h1 {
            color: #7209b7;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(90deg, #7209b7, #4361ee, #4cc9f0);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 2px;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(76,201,240,0.08);
        }
        .section-header p {
            color: #666;
            font-size: 1.15rem;
            letter-spacing: 1px;
        }
        .assistant-container {
            background: rgba(255,255,255,0.85);
            border-radius: 2rem;
            box-shadow: 0 8px 32px 0 rgba(76,201,240,0.12), 0 1.5px 8px 0 rgba(114,9,183,0.08);
            backdrop-filter: blur(2px);
            max-width: 1100px;
            margin: 0 auto;
            padding: 2.5rem 2rem 2rem 2rem;
        }
        .form-group {
            margin-bottom: 24px;
            position: relative;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #7209b7;
        }
        textarea {
            width: 100%;
            padding: 1.1rem 1rem;
            border: 1.5px solid #e0c3fc;
            border-radius: 1.1rem;
            min-height: 300px;
            font-size: 1.13rem;
            box-sizing: border-box;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 2px 8px rgba(76,201,240,0.06);
            outline: none;
            transition: border 0.2s;
            resize: vertical;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        textarea:focus {
            border: 1.5px solid #7209b7;
            background: #f8fafc;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1.1rem;
            margin-bottom: 24px;
        }
        .control-group {
            flex: 1 1 180px;
            min-width: 150px;
            background: rgba(236,222,255,0.7);
            border-radius: 0.9rem;
            padding: 0.7rem 1rem 0.7rem 1rem;
            margin-bottom: 0;
            border: 1.5px solid #e0c3fc;
            box-shadow: 0 1px 4px rgba(76,201,240,0.04);
        }
        select, input[type="range"] {
            width: 100%;
            padding: 0.9rem;
            border: 1.5px solid #e0c3fc;
            border-radius: 0.9rem;
            font-size: 1.08rem;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 1px 4px rgba(76,201,240,0.05);
            transition: border 0.2s;
        }
        select:focus, input[type="range"]:focus {
            border: 1.5px solid #7209b7;
        }
        button {
            background: linear-gradient(90deg, #7209b7, #4361ee 80%);
            color: #fff;
            border: none;
            padding: 0.9rem 1.5rem;
            border-radius: 0.9rem;
            cursor: pointer;
            font-size: 1.13rem;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(76,201,240,0.08);
            transition: opacity 0.3s, background 0.2s;
            width: 100%;
        }
        button:hover {
            opacity: 0.92;
            background: linear-gradient(90deg, #4361ee, #7209b7 80%);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .audio-container {
            margin-top: 30px;
            text-align: center;
            display: none;
        }
        .audio-container.visible {
            display: block;
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            display: none;
        }
        .status.error {
            background-color: #ffebee;
            color: #c62828;
            display: block;
        }
        .status.loading {
            background-color: #e3f2fd;
            color: #1565c0;
            display: block;
        }
        .status.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            display: block;
            animation: fadeInOut 3s forwards;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        .audio-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }
        .audio-actions button {
            padding: 8px 15px;
            font-size: 14px;
            border-radius: 4px;
            width: auto;
        }
        .btn-download {
            background-color: #28a745;
        }
        .btn-download:hover {
            background-color: #218838;
        }
        .dialog-info {
            margin-top: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 1.2rem;
            border: 2px solid #e0c3fc;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(76,201,240,0.13);
            display: none;
        }
        .dialog-info.visible {
            display: block;
            animation: fadeIn 0.5s;
        }
        .role-list {
            margin-top: 15px;
        }
        .role-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #e0c3fc;
        }
        .role-name {
            font-weight: 500;
            flex: 3; /* Increased from 1 to 3 to make it wider */
        }
        .role-voice-select {
            min-width: 180px; /* Reduced from 200px */
            max-width: 220px; /* Added max-width to prevent excessive width */
            flex: 1;
        }
        .example-btn {
            display: inline-block;
            padding: 6px 12px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #4361ee;
            background: rgba(236,222,255,0.7);
            border: 1px solid #e0c3fc;
            border-radius: 6px;
            cursor: pointer;
        }
        .example-btn:hover {
            background: rgba(236,222,255,0.9);
        }
        
        .example-select {
            padding: 8px 14px;
            font-size: 0.95rem;
            color: #4361ee;
            background: rgba(236,222,255,0.7);
            border: 1px solid #e0c3fc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            max-width: 300px;
            outline: none;
        }
        
        .example-select:hover {
            background: rgba(236,222,255,0.9);
        }
        
        .example-select:focus {
            border-color: #7209b7;
            box-shadow: 0 0 0 2px rgba(114, 9, 183, 0.1);
        }
        
        .example-controls {
            display: flex;
            margin-top: 10px;
            margin-bottom: 5px;
            flex-direction: column;
            gap: 10px;
        }
        
        .filter-dropdowns {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .filter-select {
            padding: 8px 14px;
            font-size: 0.9rem;
            color: #4361ee;
            background: rgba(236,222,255,0.5);
            border: 1px solid #e0c3fc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            outline: none;
        }
        
        .filter-select:hover {
            background: rgba(236,222,255,0.7);
        }
        
        .filter-select:focus {
            border-color: #7209b7;
            box-shadow: 0 0 0 2px rgba(114, 9, 183, 0.1);
        }
        
        .filter-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #7209b7;
            font-size: 0.8rem;
            width: 20px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            margin-right: 5px;
            background: linear-gradient(90deg, #4361ee, #7209b7);
            color: white;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .helper-text {
            margin-top: 8px;
            font-size: 0.85rem;
            color: #666;
            font-style: italic;
        }

        /* 返回首页链接样式 */
        .back-to-home {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            text-decoration: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .back-to-home:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            background: rgba(255, 255, 255, 1);
            color: #7209b7;
            text-decoration: none;
        }

        .back-to-home i {
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .back-to-home:hover i {
            transform: translateX(-2px);
        }
        
        @media (max-width: 768px) {
            .back-to-home {
                top: 15px;
                left: 15px;
                padding: 8px 12px;
                font-size: 13px;
            }
            
            .back-to-home i {
                font-size: 14px;
            }
            .assistant-container {
                padding: 1.5rem 1.2rem;
                border-radius: 1.5rem;
                max-width: 100%;
                margin: 0 0.8rem;
            }
            .section-header {
                padding: 1rem 0;
            }
            .section-header h1 {
                font-size: 1.8rem;
                margin-bottom: 0.5rem;
            }
            .section-header p {
                font-size: 1rem;
            }
            .form-group label, .control-group label {
                font-size: 1.01rem;
            }
            textarea {
                font-size: 1.01rem;
                min-height: 200px;
                border-radius: 0.8rem;
                padding: 0.8rem;
            }
            
            /* Filter dropdowns responsive styles */
            .filter-dropdowns {
                flex-direction: column;
                gap: 8px;
            }
            
            .filter-arrow {
                display: none; /* Hide arrow on mobile */
            }
            
            .filter-select, .example-select {
                width: 100%;
                max-width: 100%;
                font-size: 0.9rem;
                padding: 6px 12px;
            }
            
            .example-controls {
                gap: 8px;
            }
            
            .helper-text {
                font-size: 0.8rem;
            }
            
            .controls {
                gap: 0.6rem;
                flex-direction: column;
            }
            
            .control-group {
                flex: 1 1 100%;
                border-radius: 0.8rem;
            }
            
            .role-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                padding: 12px;
            }
            
            .role-name {
                width: 100%;
                margin-bottom: 4px;
            }
            
            .role-voice-select {
                width: 100%;
                min-width: 100%;
                max-width: 100%;
            }
            
            /* Mobile menu styles */
            .mobile-menu-toggle {
                display: block;
                background: none;
                border: none;
                padding: 0.5rem;
                cursor: pointer;
                z-index: 1001;
                width: auto;
                margin-left: auto;
            }
            
            .mobile-menu-toggle span {
                display: block;
                width: 24px;
                height: 2px;
                background-color: #333;
                margin: 5px 0;
                transition: all 0.3s ease;
            }
            
            .main-nav {
                display: none;
            }
            
            body.mobile-menu-open .main-nav {
                display: flex;
                flex-direction: column;
                position: absolute;
                top: 100%;
                left: 0;
                width: 100%;
                background-color: white;
                padding: 1rem;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
                z-index: 1000;
            }
            
            body.mobile-menu-open .main-nav ul {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            body.mobile-menu-open .main-nav a {
                display: block;
                padding: 1rem;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <!-- 返回首页链接 -->
    <a href="index.html" class="back-to-home">
        <i class="fas fa-arrow-left"></i>
        <span>返回首页</span>
    </a>

    <main class="main-content" style="padding-top: 1rem;">
        <div class="container">
            <div class="section-header">
                <h1>对话<span class="gradient-text">语音</span>转换</h1>
                <p>为不同角色自动选择不同的声音，让对话更生动</p>
            </div>
            <div class="assistant-container">
                <div class="form-group">
                    <label for="dialog-input">输入对话文本（每个角色的台词以"角色名: "开头）：</label>
                    <textarea id="dialog-input" placeholder="例如：
Mom: Wake up, sweetheart! It's time for school. 
妈妈：醒醒，宝贝！该上学了。 
Child: Just five more minutes, please! 
孩子：再睡五分钟嘛，求你了！"></textarea>
                    <div class="example-controls">
                        <div class="filter-dropdowns">
                            <select id="grade-filter" class="filter-select">
                                <option value="">选择年级...</option>
                                <!-- SUB_TYPE1 options will be populated from DB -->
                            </select>
                            <div class="filter-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <select id="scene-filter" class="filter-select">
                                <option value="">选择情景...</option>
                                <!-- SCENE options will be populated from DB -->
                            </select>
                        </div>
                        <select id="dialog-examples" class="example-select">
                            <option value="">选择对话...</option>
                            <!-- Options will be populated from DB -->
                        </select>
                    </div>
                    <div class="helper-text">
                        先选择年级，再选择相应的情景，最后从下拉列表中选择对话模板加载到文本框中。
                    </div>
                </div>
                
                <button id="analyze-btn" class="mb-4">分析对话</button>
                
                <div id="dialog-info" class="dialog-info">
                    <h3>角色配音设置</h3>
                    <p>我们已识别出以下角色，您可以为每个角色选择不同的声音：</p>
                    
                    <div id="role-list" class="role-list">
                        <!-- Roles will be inserted here by JS -->
                    </div>
                    
                    <div class="form-group" style="margin-top: 15px;">
                        <label>检测到的语言：</label>
                        <span id="detected-languages"></span>
                        
                        <div id="language-selection" style="margin-top: 10px; display: none;">
                            <label>请选择输出语言：</label>
                            <div style="margin-top: 8px;">
                                <label style="display: inline-block; margin-right: 15px; cursor: pointer;">
                                    <input type="radio" name="language-preference" value="english" checked> 
                                    <span style="margin-left: 5px;">英语</span>
                                </label>
                                <label style="display: inline-block; margin-right: 15px; cursor: pointer;">
                                    <input type="radio" name="language-preference" value="chinese"> 
                                    <span style="margin-left: 5px;">中文</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <button id="generate-btn" style="margin-top: 20px; display: none;">生成对话语音</button>
                
                <div class="status" id="status"></div>
                
                <div class="audio-container" id="audio-container">
                    <audio id="audio-player" controls style="width: 100%; border-radius: 1.1rem;"></audio>
                    <div class="audio-actions">
                        <button id="download-btn" class="btn-download">
                            <i class="fas fa-download"></i> 下载音频
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="main-footer">
        <div class="container">
            <div class="footer-bottom">
                <p style="margin: 0;">所有内容源于AI。study-llm.me域名为Alex所有。</p>
            </div>
        </div>
    </footer>

    <script src="js/common.js"></script>
    <script src="js/navigation.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const dialogInput = document.getElementById('dialog-input');
            const analyzeBtn = document.getElementById('analyze-btn');
            const generateBtn = document.getElementById('generate-btn');
            const dialogInfo = document.getElementById('dialog-info');
            const roleList = document.getElementById('role-list');
            const audioContainer = document.getElementById('audio-container');
            const audioPlayer = document.getElementById('audio-player');
            const downloadBtn = document.getElementById('download-btn');
            const status = document.getElementById('status');
            const detectedLanguagesEl = document.getElementById('detected-languages');
            const languageSelectionEl = document.getElementById('language-selection');
            const dialogExamplesSelect = document.getElementById('dialog-examples');
            const gradeFilterSelect = document.getElementById('grade-filter');
            const sceneFilterSelect = document.getElementById('scene-filter');
            
            let currentAudioBlob = null;
            let identifiedRoles = [];
            let detectedLanguages = {
                hasEnglish: false,
                hasChinese: false
            };
            let allDialogData = []; // Store all dialog data for filtering
            
            // Fetch dialog data and populate dropdowns
            fetchDialogData();
            
            // Event listeners for filter dropdowns
            gradeFilterSelect.addEventListener('change', () => {
                // First update scene dropdown based on selected grade
                updateSceneDropdown();
                // Then filter dialog options based on both filters
                filterDialogOptions();
            });
            
            sceneFilterSelect.addEventListener('change', filterDialogOptions);
            
            // Event listener for dialog examples dropdown
            dialogExamplesSelect.addEventListener('change', async () => {
                if (dialogExamplesSelect.value) {
                    const selectedType = dialogExamplesSelect.value;
                    showLoading(`正在加载「${selectedType}」对话模板...`);
                    
                    try {
                        const dialogContent = getDialogContentByType(selectedType);
                        if (dialogContent) {
                            dialogInput.value = dialogContent;
                            showStatus(`「${selectedType}」对话模板已加载`, 'success');
                        } else {
                            showError(`无法获取「${selectedType}」对话模板内容`);
                        }
                    } catch (error) {
                        console.error('获取对话内容错误:', error);
                        showError('获取对话内容失败: ' + error.message);
                    }
                }
            });
            
            // Function to fetch all dialog data and populate all dropdowns
            async function fetchDialogData() {
                try {
                    showLoading('正在加载对话数据...');
                    const response = await fetch('/api/db/query/english_dialog');
                    
                    if (!response.ok) {
                        throw new Error('获取对话数据失败');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success && Array.isArray(data.data)) {
                        allDialogData = data.data;
                        
                        // Populate grade filter (SUB_TYPE1)
                        const grades = [...new Set(data.data.map(item => item.SUB_TYPE1))].filter(Boolean);
                        grades.sort().forEach(grade => {
                            const option = document.createElement('option');
                            option.value = grade;
                            option.textContent = grade;
                            gradeFilterSelect.appendChild(option);
                        });
                        
                        // Initialize scene dropdown with all scenes initially
                        updateSceneDropdown();
                        
                        // Populate types dropdown with all types initially
                        populateDialogTypesDropdown();
                        clearStatus();
                    }
                } catch (error) {
                    console.error('获取对话数据错误:', error);
                    showError('加载对话数据失败: ' + error.message);
                }
            }
            
            // Function to populate the dialog types dropdown based on filters
            function populateDialogTypesDropdown(filteredData = null) {
                // Clear existing options except the first one
                while (dialogExamplesSelect.options.length > 1) {
                    dialogExamplesSelect.remove(1);
                }
                
                // Use filtered data or all data
                const dataToUse = filteredData || allDialogData;
                
                // Extract unique dialog types
                const types = [...new Set(dataToUse.map(item => item.TYPE))].filter(Boolean);
                
                // Populate select with unique types
                types.sort().forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    dialogExamplesSelect.appendChild(option);
                });
                
                // Update helper text if no results
                if (types.length === 0) {
                    document.querySelector('.helper-text').textContent = 
                        '当前筛选条件下没有对话模板，请调整年级或情景选择。';
                } else {
                    document.querySelector('.helper-text').textContent = 
                        '先选择年级，再选择相应的情景，最后从下拉列表中选择对话模板加载到文本框中。';
                }
            }
            
            // Function to filter dialog options based on selected grade and scene
            function filterDialogOptions() {
                const selectedGrade = gradeFilterSelect.value;
                const selectedScene = sceneFilterSelect.value;
                
                // Filter the data based on selections
                let filteredData = allDialogData;
                
                if (selectedGrade) {
                    filteredData = filteredData.filter(item => item.SUB_TYPE1 === selectedGrade);
                }
                
                if (selectedScene) {
                    filteredData = filteredData.filter(item => item.SCENE === selectedScene);
                }
                
                // Repopulate the dialog types dropdown with filtered data
                populateDialogTypesDropdown(filteredData);
            }
            
            // Function to get dialog content by type from the stored data
            function getDialogContentByType(type) {
                const dialog = allDialogData.find(item => item.TYPE === type);
                return dialog && dialog.CONTENT ? dialog.CONTENT : null;
            }
            
            // Voice options for different roles
            const voiceOptions = {
                male: [
                    { value: "male-qn-jingying", label: "精英青年音色" },
                    { value: "male-qn-qingse", label: "青涩青年音色" },
                    { value: "male-qn-badao", label: "霸道青年音色" },
                    { value: "presenter_male", label: "男性主持人" },
                    { value: "audiobook_male_1", label: "男性有声书1" },
                    { value: "audiobook_male_2", label: "男性有声书2" },
                    { value: "junlang_nanyou", label: "俊朗男友" },
                    { value: "Chinese (Mandarin)_Refreshing_Young_Man", label: "舒朗男声" },
                    { value: "Chinese (Mandarin)_Unrestrained_Young_Man", label: "不羁青年" },
                    { value: "Chinese (Mandarin)_Gentleman", label: "温润男声" },
                    { value: "Chinese (Mandarin)_Male_Announcer", label: "播报男声" },
                    { value: "Chinese (Mandarin)_Radio_Host", label: "电台男主播" },
                    { value: "Chinese (Mandarin)_Lyrical_Voice", label: "抒情男声" },
                    { value: "Chinese (Mandarin)_Sincere_Adult", label: "真诚青年" },
                    { value: "Chinese (Mandarin)_Gentle_Youth", label: "温润青年" },
                    { value: "Chinese (Mandarin)_Stubborn_Friend", label: "嘴硬竹马" },
                    { value: "Cantonese_ProfessionalHost（M)", label: "粤语专业男主持" },
                    { value: "Cantonese_PlayfulMan", label: "粤语活泼男声" },
                    { value: "English_Trustworthy_Man", label: "Trustworthy Man" },
                    { value: "English_Gentle-voiced_man", label: "Gentle-voiced man" },
                    { value: "English_Aussie_Bloke", label: "Aussie Bloke" },
                    { value: "Santa_Claus", label: "Santa Claus" },
                    { value: "Rudolph", label: "Rudolph" },
                    { value: "Charming_Santa", label: "Charming Santa" }
                ],
                female: [
                    { value: "female-shaonv", label: "少女音色" },
                    { value: "female-yujie", label: "御姐音色" },
                    { value: "female-chengshu", label: "成熟女性音色" },
                    { value: "female-tianmei", label: "甜美女性音色" },
                    { value: "presenter_female", label: "女性主持人" },
                    { value: "audiobook_female_1", label: "女性有声书1" },
                    { value: "audiobook_female_2", label: "女性有声书2" },
                    { value: "qiaopi_mengmei", label: "俏皮萌妹" },
                    { value: "Chinese (Mandarin)_News_Anchor", label: "新闻女声" },
                    { value: "Chinese (Mandarin)_Kind-hearted_Antie", label: "热心大婶" },
                    { value: "Chinese (Mandarin)_Sweet_Lady", label: "甜美女声" },
                    { value: "Chinese (Mandarin)_Wise_Women", label: "阅历姐姐" },
                    { value: "Chinese (Mandarin)_Warm_Girl", label: "温暖少女" },
                    { value: "Chinese (Mandarin)_Kind-hearted_Elder", label: "花甲奶奶" },
                    { value: "Chinese (Mandarin)_Gentle_Senior", label: "温柔学姐" },
                    { value: "Chinese (Mandarin)_Crisp_Girl", label: "清脆少女" },
                    { value: "Cantonese_ProfessionalHost（F)", label: "粤语专业女主持" },
                    { value: "Cantonese_CuteGirl", label: "粤语可爱女孩" },
                    { value: "English_Graceful_Lady", label: "Graceful Lady" },
                    { value: "English_UpsetGirl", label: "Upset Girl" },
                    { value: "English_Wiselady", label: "Wise Lady" },
                    { value: "Charming_Lady", label: "Charming Lady" },
                    { value: "Sweet_Girl", label: "Sweet Girl" },
                    { value: "Attractive_Girl", label: "Attractive Girl" },
                    { value: "Serene_Woman", label: "Serene Woman" }
                ],
                child: [
                    { value: "clever_boy", label: "聪明男童" },
                    { value: "cute_boy", label: "可爱男童" },
                    { value: "lovely_girl", label: "萌萌女童" },
                    { value: "chunzhen_xuedi", label: "纯真学弟" },
                    { value: "Chinese (Mandarin)_Pure-hearted_Boy", label: "清澈邻家弟弟" },
                    { value: "Chinese (Mandarin)_Straightforward_Boy", label: "率真弟弟" },
                    { value: "Sweet_Girl", label: "Sweet Girl" },
                    { value: "Attractive_Girl", label: "Attractive Girl" },
                    { value: "English_Aussie_Bloke", label: "Aussie Bloke" },
                    { value: "Cute_Elf", label: "Cute Elf" }
                ]
            };
            
            // Common role name mappings
            const roleCategories = {
                male: ["dad", "father", "grandpa", "grandfather", "uncle", "brother", "boy", "man", "mr", "sir", "male"],
                female: ["mom", "mother", "grandma", "grandmother", "aunt", "sister", "girl", "woman", "mrs", "ms", "miss", "lady", "female"],
                child: ["child", "kid", "baby", "boy", "girl", "son", "daughter"]
            };
            
            // Helper function to analyze dialog text
            async function analyzeDialog(dialogText) {
                if (!dialogText) {
                    showError('请输入对话文本');
                    return false;
                }
                
                try {
                    // Call DeepSeek API to analyze the dialog
                    const messages = [
                        {
                            role: "system",
                            content: "你是一个专业的对话分析助手，擅长解析双语对话内容。请帮助从对话中提取所有说话者角色，并从英文部分分析每个角色可能的性别和年龄段。对于每一个角色，仅在角色名称明确指示性别时（如'爸爸'，'妈妈'，'父亲'，'母亲'，'男孩'，'女孩'等）才判断其性别，否则设为'unknown'。同样，仅在角色明确是孩子（如'孩子'，'男孩'，'女孩'等）时才将类型设为'child'，否则设为'unknown'。此外，请检测对话中存在哪些语言（英文/中文）。"
                        },
                        {
                            role: "user",
                            content: `请分析以下对话文本，找出所有说话的角色，并仅在名称明确指示性别和年龄时才判断其性别和类型。结果必须按以下严格的JSON格式返回：
                            
{
  "roles": [
    {
      "name": "角色名称，保持原文中的拼写和大小写",
      "gender": "仅当角色名明确指示性别时（如'爸爸'，'妈妈'等）才设为'male'或'female'，否则设为'unknown'",
      "type": "仅当角色名明确是孩子时（如'孩子'，'男孩'，'女孩'等）才设为'child'，否则设为'unknown'",
      "lines": [
        {
          "english": "该角色的一段英文台词",
          "chinese": "该角色的一段中文台词"
        },
        ...更多台词...
      ]
    },
    ...更多角色...
  ],
  "languages": {
    "hasEnglish": true/false, 根据是否有英文台词,
    "hasChinese": true/false, 根据是否有中文台词
  }
}

具体规则：
1. 仅在以下情况才将gender设为'male'：角色名包含'爸爸'，'父亲'，'Dad'，'Father'，'男孩'，'男生'，'小哥'，'先生'，'男士'等明确指示男性的词语
2. 仅在以下情况才将gender设为'female'：角色名包含'妈妈'，'母亲'，'Mom'，'Mother'，'女孩'，'女生'，'小姐'，'女士'等明确指示女性的词语
3. 仅在以下情况才将type设为'child'：角色名包含'孩子'，'Child'，'小朋友'，'男孩'，'女孩'，'Boy'，'Girl'等明确指示孩子的词语
4. 其他所有情况都应将gender和type设为'unknown'
5. 不要根据对话内容或语气推断性别或年龄，仅看角色名称

对话文本：

${dialogText}`
                        }
                    ];
                    
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ messages })
                    });
                    
                    if (!response.ok) {
                        throw new Error('对话分析请求失败');
                    }
                    
                    const data = await response.json();
                    const assistantMessage = data.choices[0].message.content;
                    
                    // Extract JSON from response
                    const jsonMatch = assistantMessage.match(/```json\n([\s\S]*?)\n```/) || 
                                      assistantMessage.match(/{[\s\S]*?}/);
                    
                    if (!jsonMatch) {
                        throw new Error('未能从响应中提取有效数据');
                    }
                    
                    let jsonStr = jsonMatch[0];
                    if (jsonStr.startsWith('```json')) {
                        jsonStr = jsonMatch[1];
                    }
                    
                    // Parse the JSON response
                    const dialogData = JSON.parse(jsonStr);
                    
                    // Clean role names of invisible Unicode characters
                    if (dialogData.roles && Array.isArray(dialogData.roles)) {
                        dialogData.roles.forEach(role => {
                            if (role.name) {
                                // Remove zero-width spaces and other invisible Unicode characters
                                role.name = role.name.replace(/[\u200B-\u200D\uFEFF\u00A0\u2000-\u200F]/g, '');
                                console.log(`Normalized role name: "${role.name}"`);
                            }
                        });
                    }
                    
                    identifiedRoles = dialogData.roles;
                    
                    // Extract detected languages
                    if (dialogData.languages) {
                        detectedLanguages = dialogData.languages;
                    } else {
                        // Fallback detection if API didn't return languages info
                        detectedLanguages = {
                            hasEnglish: identifiedRoles.some(role => 
                                role.lines.some(line => line.english && line.english.trim().length > 0)
                            ),
                            hasChinese: identifiedRoles.some(role => 
                                role.lines.some(line => line.chinese && line.chinese.trim().length > 0)
                            )
                        };
                    }
                    
                    // Update the detected languages display
                    updateDetectedLanguagesDisplay();
                    
                    // Render the role list
                    renderRoleList(identifiedRoles);
                    
                    // Show the dialog info section
                    dialogInfo.classList.add('visible');
                    generateBtn.style.display = 'block';
                    clearStatus();
                    
                    return true;
                } catch (error) {
                    console.error('Dialog analysis error:', error);
                    showError('对话分析失败: ' + error.message);
                    return false;
                }
            }
            
            // Analyze the dialog text using DeepSeek API
            analyzeBtn.addEventListener('click', async () => {
                const dialogText = dialogInput.value.trim();
                generateBtn.style.display = 'none';
                dialogInfo.classList.remove('visible');
                audioContainer.classList.remove('visible');
                languageSelectionEl.style.display = 'none';
                
                showLoading('正在分析对话文本...');
                await analyzeDialog(dialogText);
            });
            
            // Update the detected languages display
            function updateDetectedLanguagesDisplay() {
                let languagesText = '';
                
                if (detectedLanguages.hasEnglish && detectedLanguages.hasChinese) {
                    languagesText = '<span class="badge">英文</span> <span class="badge">中文</span>';
                    languageSelectionEl.style.display = 'block';
                    // Preselect English by default
                    document.querySelector('input[name="language-preference"][value="english"]').checked = true;
                } else if (detectedLanguages.hasEnglish) {
                    languagesText = '<span class="badge">英文</span>';
                    languageSelectionEl.style.display = 'none';
                } else if (detectedLanguages.hasChinese) {
                    languagesText = '<span class="badge">中文</span>';
                    languageSelectionEl.style.display = 'none';
                } else {
                    languagesText = '<span class="badge">未检测到支持的语言</span>';
                    languageSelectionEl.style.display = 'none';
                }
                
                detectedLanguagesEl.innerHTML = languagesText;
            }
            
            // Render the list of identified roles
            function renderRoleList(roles) {
                roleList.innerHTML = '';
                
                roles.forEach((role, index) => {
                    const roleDiv = document.createElement('div');
                    roleDiv.className = 'role-item';
                    
                    // Determine voice category based on role name and type
                    let voiceCategory = 'male'; // default for unknown gender
                    
                    if (role.gender === 'female' || isInCategory(role.name.toLowerCase(), roleCategories.female)) {
                        voiceCategory = 'female';
                    } else if (role.gender === 'male' || isInCategory(role.name.toLowerCase(), roleCategories.male)) {
                        voiceCategory = 'male';
                    }
                    
                    if (role.type === 'child' || isInCategory(role.name.toLowerCase(), roleCategories.child)) {
                        voiceCategory = 'child';
                    }
                    
                    // Create voice select dropdown that includes all voice options
                    const voiceSelect = document.createElement('select');
                    voiceSelect.className = 'role-voice-select';
                    voiceSelect.id = `voice-${index}`;
                    
                    // Add options group for recommended voices
                    const recommendedGroup = document.createElement('optgroup');
                    recommendedGroup.label = '推荐声音';
                    
                    // Add recommended voice options based on category
                    const voices = voiceOptions[voiceCategory] || voiceOptions.male;
                    voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.value;
                        option.textContent = voice.label;
                        
                        // Pre-select voices for specific roles
                        if ((role.name === 'Mom' || role.name === '妈妈') && 
                            (voice.value === "Chinese (Mandarin)_Sweet_Lady" || voice.value === "female-tianmei")) {
                            option.selected = true;
                        } else if ((role.name === 'Dad' || role.name === '爸爸') && 
                                   (voice.value === "Chinese (Mandarin)_Gentle_Youth" || voice.value === "male-qn-jingying")) {
                            option.selected = true;
                        }
                        
                        recommendedGroup.appendChild(option);
                    });
                    
                    voiceSelect.appendChild(recommendedGroup);
                    
                    // Add the other voice categories if they're different from the recommended one
                    if (voiceCategory !== 'male') {
                        const maleGroup = document.createElement('optgroup');
                        maleGroup.label = '男性声音';
                        voiceOptions.male.forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.value;
                            option.textContent = voice.label;
                            maleGroup.appendChild(option);
                        });
                        voiceSelect.appendChild(maleGroup);
                    }
                    
                    if (voiceCategory !== 'female') {
                        const femaleGroup = document.createElement('optgroup');
                        femaleGroup.label = '女性声音';
                        voiceOptions.female.forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.value;
                            option.textContent = voice.label;
                            femaleGroup.appendChild(option);
                        });
                        voiceSelect.appendChild(femaleGroup);
                    }
                    
                    if (voiceCategory !== 'child') {
                        const childGroup = document.createElement('optgroup');
                        childGroup.label = '儿童声音';
                        voiceOptions.child.forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.value;
                            option.textContent = voice.label;
                            childGroup.appendChild(option);
                        });
                        voiceSelect.appendChild(childGroup);
                    }
                    
                    // Add voice name and role information
                    roleDiv.innerHTML = `
                        <div class="role-name">
                            ${role.name}
                            <div style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                                ${role.lines.length} 句台词
                                ${role.gender !== 'unknown' ? ` • ${role.gender === 'male' ? '男性' : '女性'}` : ''}
                                ${role.type !== 'unknown' ? ` • ${role.type === 'adult' ? '成人' : '儿童'}` : ''}
                            </div>
                        </div>
                    `;
                    roleDiv.appendChild(voiceSelect);
                    roleList.appendChild(roleDiv);
                });
            }
            
            // Check if a name belongs to a category
            function isInCategory(name, categoryTerms) {
                return categoryTerms.some(term => name.includes(term));
            }
            
            // Generate dialog audio with selected voices
            generateBtn.addEventListener('click', async () => {
                if (!identifiedRoles || identifiedRoles.length === 0) {
                    showError('请先分析对话文本');
                    return;
                }
                
                generateBtn.disabled = true;
                showLoading('正在生成对话语音...');
                audioContainer.classList.remove('visible');
                
                // Track if there are issues with invisible Unicode characters
                let hasNormalizationIssues = false;
                
                try {
                    // Check if dialog is in single paragraph format that needs to be reformatted
                    const originalText = dialogInput.value.trim();
                    const lineCount = originalText.split('\n').filter(line => line.trim()).length;
                    
                    // Check for common patterns in single-paragraph dialog
                    const hasMultipleColons = (originalText.match(/:/g) || []).length >= 3;
                    const spaceAfterName = originalText.match(/\w+:\s/g);
                    const hasNames = spaceAfterName && spaceAfterName.length >= 3;
                    
                    // More sophisticated detection logic
                    const speakerPattern = /\b(Mom|Dad|Child|Mother|Father|妈妈|爸爸|孩子)(?=:)/gi;
                    const potentialSpeakers = originalText.match(speakerPattern) || [];
                    const uniqueSpeakers = new Set(potentialSpeakers.map(s => s.toLowerCase()));
                    
                    // If text contains multiple speakers but few line breaks, likely needs reformatting
                    const needsReformatting = lineCount < uniqueSpeakers.size && 
                                             hasMultipleColons && 
                                             hasNames &&
                                             uniqueSpeakers.size >= 2;
                    
                    if (needsReformatting) {
                        showLoading('检测到单段对话格式，正在重新格式化...');
                        
                        // Request reformatting from DeepSeek API
                        const formatMessages = [
                            {
                                role: "system",
                                content: "你是一个专业的文本格式化助手，擅长将单段式对话文本重新格式化为多行对话格式。你需要确保每个角色的对话都正确分隔，特别是中英文混合的对话。"
                            },
                            {
                                role: "user",
                                content: `请将以下单段对话文本重新格式化为多行对话，使每个角色的台词占一行，并严格保持中英文内容。

格式要求：
1. 每个角色的台词应该单独占一行
2. 格式为"角色名: 台词内容"
3. 如果台词同时包含英文和中文，保持原样
4. 不要添加任何额外说明，只返回格式化后的文本

原始文本：
${originalText}

请只返回格式化后的对话文本，不要添加任何其他文字或解释。`
                            }
                        ];
                        
                        const formatResponse = await fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ messages: formatMessages })
                        });
                        
                        if (!formatResponse.ok) {
                            throw new Error('对话格式化请求失败');
                        }
                        
                        const formatData = await formatResponse.json();
                        const formattedText = formatData.choices[0].message.content.trim();
                        
                        console.log('原始对话文本:', originalText);
                        console.log('格式化后文本:', formattedText);
                        
                        // Update the dialog input with formatted text
                        dialogInput.value = formattedText;
                        
                        // Show success message about reformatting
                        showStatus('对话已自动重新格式化为多行格式', 'success');
                        
                        // Re-run the dialog analysis with the formatted text
                        showLoading('正在分析重新格式化的对话...');
                        await analyzeDialog(formattedText);
                    }
                    
                    // Collect voice selections for each role
                    const roleVoices = {};
                    identifiedRoles.forEach((role, index) => {
                        const voiceSelect = document.getElementById(`voice-${index}`);
                        roleVoices[role.name] = voiceSelect.value;
                    });
                    
                    // Debug output
                    console.log('Role voices mapping:', roleVoices);
                    
                    // Create sequence information to ensure dialog order is preserved
                    // This extracts the original dialog sequence from the text input
                    const dialogText = dialogInput.value.trim();
                    const dialogLines = dialogText.split('\n').filter(line => line.trim());
                    
                    // Extract the sequence of roles from the original text
                    const sequenceInfo = [];
                    
                    // Debugging output of original dialog lines
                    console.log('Original dialog lines:', dialogLines.map(l => l.trim()));
                    console.log('Identified roles:', identifiedRoles.map(r => r.name));
                    
                    // Parse the original text to extract the sequence of roles and lines
                    dialogLines.forEach((line, lineIndex) => {
                        // Find role name before the colon
                        const colonIndex = line.indexOf(':');
                        if (colonIndex > 0) {
                            // Get the raw role name and clean it by removing invisible Unicode characters
                            let rawRoleName = line.substring(0, colonIndex).trim();
                            // Remove zero-width spaces and other invisible Unicode characters
                            const cleanRoleName = rawRoleName.replace(/[\u200B-\u200D\uFEFF\u00A0\u2000-\u200F]/g, '');
                            
                            // Detect if the name was changed during cleaning (invisible characters detected)
                            if (rawRoleName !== cleanRoleName) {
                                console.warn(`Invisible Unicode characters detected in role name: "${rawRoleName}" -> "${cleanRoleName}"`);
                                // Set the normalization flag in outer scope
                                hasNormalizationIssues = true;
                            }
                            
                            const lineText = line.substring(colonIndex + 1).trim();
                            
                            // Skip empty lines
                            if (!lineText) return;
                            
                            console.log(`Line ${lineIndex+1}: Role "${cleanRoleName}", Text: "${lineText.substring(0, 20)}..."`);
                            
                            // Find the matching role in identifiedRoles by doing a fuzzy match on role names
                            let roleIndex = identifiedRoles.findIndex(r => {
                                // Direct match
                                if (r.name === cleanRoleName) return true;
                                
                                // Case insensitive match
                                if (r.name.toLowerCase() === cleanRoleName.toLowerCase()) return true;
                                
                                // Check if the name is contained within
                                if (cleanRoleName.includes(r.name) || r.name.includes(cleanRoleName)) return true;
                                
                                return false;
                            });
                            
                            // If not found, try an even more relaxed match
                            if (roleIndex < 0) {
                                roleIndex = identifiedRoles.findIndex(r => {
                                    // Remove all spaces and compare
                                    const normalizedRole = r.name.replace(/\s+/g, '').toLowerCase();
                                    const normalizedInput = cleanRoleName.replace(/\s+/g, '').toLowerCase();
                                    return normalizedRole === normalizedInput;
                                });
                            }
                            
                            if (roleIndex >= 0) {
                                const role = identifiedRoles[roleIndex];
                                
                                // Find the matching line in this role's lines using fuzzy matching
                                // This is more reliable than exact matching
                                let bestMatchIndex = -1;
                                let bestMatchScore = 0;
                                
                                role.lines.forEach((l, i) => {
                                    // Check both English and Chinese text
                                    const englishMatch = l.english && lineText.includes(l.english.substring(0, Math.min(l.english.length, 10)));
                                    const chineseMatch = l.chinese && lineText.includes(l.chinese.substring(0, Math.min(l.chinese.length, 10)));
                                    
                                    // If either matches, this is a candidate
                                    if (englishMatch || chineseMatch) {
                                        // Calculate match score based on text overlap
                                        let score = 0;
                                        if (l.english) {
                                            score += getMatchScore(lineText, l.english);
                                        }
                                        if (l.chinese) {
                                            score += getMatchScore(lineText, l.chinese);
                                        }
                                        
                                        // Update best match if this is better
                                        if (score > bestMatchScore) {
                                            bestMatchScore = score;
                                            bestMatchIndex = i;
                                        }
                                    }
                                });
                                
                                // If we found a good match, add it to the sequence
                                if (bestMatchIndex >= 0) {
                                    console.log(`-> Matched to line index ${bestMatchIndex} (score: ${bestMatchScore})`);
                                    
                                    sequenceInfo.push({
                                        role: cleanRoleName,
                                        line_index: bestMatchIndex,
                                        sequence_position: lineIndex,  // Use the actual line index from the input text
                                        original_line: lineText
                                    });
                                } else {
                                    console.warn(`-> No good match found for line: "${lineText}"`);
                                    
                                    // Fall back to a simple position-based match as last resort
                                    // Try to find a line that hasn't been matched yet
                                    const usedIndices = sequenceInfo
                                        .filter(si => si.role === cleanRoleName)
                                        .map(si => si.line_index);
                                    
                                    for (let i = 0; i < role.lines.length; i++) {
                                        if (!usedIndices.includes(i)) {
                                            console.log(`-> Falling back to position-based match at index ${i}`);
                                            sequenceInfo.push({
                                                role: cleanRoleName,
                                                line_index: i,
                                                sequence_position: lineIndex,  // Use the actual line index from the input text
                                                original_line: lineText,
                                                is_fallback: true
                                            });
                                            break;
                                        }
                                    }
                                }
                            } else {
                                console.warn(`Role "${cleanRoleName}" not found in identified roles.`);
                            }
                        } else {
                            console.warn(`Line doesn't follow "Role: Text" format: "${line}"`);
                        }
                    });
                    
                    // Helper function to calculate text match score
                    function getMatchScore(text1, text2) {
                        // Basic implementation: length of common substring
                        const minLen = Math.min(text1.length, text2.length);
                        let maxCommonLen = 0;
                        
                        for (let i = 0; i < minLen; i++) {
                            // Start from different positions and find common substrings
                            let j = 0;
                            while (i + j < minLen && text1.charAt(i + j) === text2.charAt(j)) {
                                j++;
                            }
                            maxCommonLen = Math.max(maxCommonLen, j);
                        }
                        
                        return maxCommonLen;
                    }
                    
                    // Log the final sequence information
                    console.log(`Final dialog sequence (${sequenceInfo.length} lines):`, sequenceInfo);
                    
                    // Sort sequence by sequence_position to ensure proper order
                    sequenceInfo.sort((a, b) => a.sequence_position - b.sequence_position);
                    
                    // Log the sorted sequence
                    console.log(`Sequence after sorting by position:`);
                    sequenceInfo.forEach((seq, i) => {
                        const role = seq.role;
                        const lineIndex = seq.line_index;
                        const position = seq.sequence_position;
                        console.log(`${i+1}. Position ${position}: ${role} line ${lineIndex}`);
                    });
                    
                    // Verify if all original lines are accounted for
                    if (sequenceInfo.length < dialogLines.length) {
                        console.warn(`Not all lines were matched! Original: ${dialogLines.length}, Matched: ${sequenceInfo.length}`);
                        
                        // Set a flag to tell the API when we're dealing with known problem content
                        let hasNormalizationIssues = false;
                        
                        // To ensure all dialog lines are included, we'll create a mapping of which lines 
                        // from the original text have been matched
                        const matchedLines = new Set();
                        sequenceInfo.forEach(seq => {
                            // Create a key from the role and text to identify matched lines
                            const key = `${seq.role}:${seq.original_line}`;
                            matchedLines.add(key);
                        });
                        
                        // Check original dialog lines again and add any that weren't matched
                        dialogLines.forEach((line, lineIndex) => {
                            const colonIndex = line.indexOf(':');
                            if (colonIndex > 0) {
                                // Clean the role name to remove invisible characters
                                let rawRoleName = line.substring(0, colonIndex).trim();
                                const cleanRoleName = rawRoleName.replace(/[\u200B-\u200D\uFEFF\u00A0\u2000-\u200F]/g, '');
                                const lineText = line.substring(colonIndex + 1).trim();
                                
                                if (!lineText) return; // Skip empty lines
                                
                                const key = `${cleanRoleName}:${lineText}`;
                                const originalKey = `${rawRoleName}:${lineText}`;
                                
                                // Check both original and cleaned keys
                                if (!matchedLines.has(key) && !matchedLines.has(originalKey)) {
                                    console.log(`Adding previously unmatched line: ${key}`);
                                    
                                    // Find the role with fuzzy matching
                                    let roleIndex = identifiedRoles.findIndex(r => {
                                        if (r.name === rawRoleName) return true;
                                        if (r.name.toLowerCase() === rawRoleName.toLowerCase()) return true;
                                        if (rawRoleName.includes(r.name) || r.name.includes(rawRoleName)) return true;
                                        
                                        // Remove all spaces and compare
                                        const normalizedRole = r.name.replace(/\s+/g, '').toLowerCase();
                                        const normalizedInput = rawRoleName.replace(/\s+/g, '').toLowerCase();
                                        return normalizedRole === normalizedInput;
                                    });
                                    
                                    if (roleIndex >= 0) {
                                        // Add as a new entry with best-effort line matching
                                        // Find the first unused line for this role
                                        const role = identifiedRoles[roleIndex];
                                        const usedIndices = sequenceInfo
                                            .filter(si => si.role === cleanRoleName)
                                            .map(si => si.line_index);
                                        
                                        // Find an unused line index or use 0 as fallback
                                        let lineIndexInRole = 0;
                                        for (let i = 0; i < role.lines.length; i++) {
                                            if (!usedIndices.includes(i)) {
                                                lineIndexInRole = i;
                                                break;
                                            }
                                        }
                                        
                                        sequenceInfo.push({
                                            role: cleanRoleName,
                                            line_index: lineIndexInRole,
                                            sequence_position: lineIndex,  // Use the actual line index from the original dialog
                                            original_line: lineText,
                                            is_emergency_fallback: true
                                        });
                                        
                                        // Set flag when we had to do special processing for role names
                                        if (rawRoleName !== cleanRoleName) {
                                            hasNormalizationIssues = true;
                                            console.log('Unicode normalization issues detected in role names');
                                        }
                                    }
                                }
                            }
                        });
                        
                        console.log(`After recovery: ${sequenceInfo.length} lines in sequence`);
                    }
                    
                    // Get language preference
                    let selectedLanguage;
                    if (detectedLanguages.hasEnglish && detectedLanguages.hasChinese) {
                        // Get from selected radio button
                        selectedLanguage = document.querySelector('input[name="language-preference"]:checked').value;
                    } else if (detectedLanguages.hasEnglish) {
                        selectedLanguage = "english";
                    } else if (detectedLanguages.hasChinese) {
                        selectedLanguage = "chinese";
                    } else {
                        selectedLanguage = "english"; // Default fallback
                    }
                    console.log(`Selected language preference: ${selectedLanguage}`);
                    
                    // Prepare the TTS request with role and voice mapping
                    const requestData = {
                        dialog: identifiedRoles,
                        roleVoices: roleVoices,
                        model: "speech-02-hd",
                        // Include the original sequence information
                        original_sequence: sequenceInfo,
                        // Include language preference
                        language_preference: selectedLanguage,
                        // Add flag for normalization issues
                        has_normalization_issues: hasNormalizationIssues || false
                    };
                    
                    // Call the TTS API
                    const response = await fetch('/api/tts-dialog', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    if (!response.ok) {
                        let errorMessage = '语音生成失败';
                        try {
                            const errorData = await response.json();
                            console.error('API Error Response:', errorData);
                            
                            if (errorData.details && typeof errorData.details === 'object') {
                                // Show detailed API error for debugging
                                const detailsStr = JSON.stringify(errorData.details, null, 2);
                                errorMessage = `API错误: ${errorData.error || ''}\n详情: ${detailsStr}`;
                                console.error('Detailed API error:', detailsStr);
                            } else {
                                errorMessage = errorData.error || errorMessage;
                            }
                            
                            // Show special message for credential errors
                            if (errorMessage.includes('credentials') || errorMessage.includes('API key') || 
                                (errorData.details && errorData.details.message && 
                                (errorData.details.message.includes('authorization') || 
                                 errorData.details.message.includes('API key')))) {
                                errorMessage = '语音API凭证无效。请检查API密钥和Group ID设置。';
                            }
                        } catch (e) {
                            errorMessage = `语音生成失败: ${response.status} ${response.statusText}`;
                            console.error('Failed to parse error response:', e);
                        }
                        throw new Error(errorMessage);
                    }
                    
                    // Process the audio response
                    const audioData = await response.arrayBuffer();
                    const audioBlob = new Blob([audioData], { type: 'audio/mp3' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    // Store the blob for download
                    currentAudioBlob = audioBlob;
                    
                    // Update audio player and show it
                    audioPlayer.src = audioUrl;
                    audioContainer.classList.add('visible');
                    clearStatus();
                    
                    // Try to play the audio
                    audioPlayer.play().catch(e => {
                        console.error('Audio playback error:', e);
                        showError('音频播放失败：' + e.message);
                    });
                    
                } catch (error) {
                    console.error('TTS Error:', error);
                    showError(error.message || '语音生成失败，请重试');
                } finally {
                    // Re-enable button
                    generateBtn.disabled = false;
                }
            });
            
            // Download button handler
            downloadBtn.addEventListener('click', () => {
                if (!currentAudioBlob) {
                    showError('没有可下载的音频');
                    return;
                }
                
                const downloadUrl = URL.createObjectURL(currentAudioBlob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = `dialog-${new Date().toISOString().slice(0,10)}.mp3`;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(downloadUrl);
                }, 100);
            });
            
            // Helper functions
            function showError(message) {
                status.textContent = message;
                status.className = 'status error';
            }
            
            function showLoading(message) {
                status.textContent = message;
                status.className = 'status loading';
            }
            
            function showStatus(message, type) {
                status.textContent = message;
                status.className = `status ${type}`;
                
                // Auto-clear success messages after a few seconds
                if (type === 'success') {
                    setTimeout(() => {
                        if (status.textContent === message) {
                            clearStatus();
                        }
                    }, 3000);
                }
            }
            
            function clearStatus() {
                status.textContent = '';
                status.className = 'status';
            }
            
            // Function to update scene dropdown based on selected grade
            function updateSceneDropdown() {
                const selectedGrade = gradeFilterSelect.value;
                
                // Clear existing options except the first one
                while (sceneFilterSelect.options.length > 1) {
                    sceneFilterSelect.remove(1);
                }
                
                // If no grade selected, show all scenes
                if (!selectedGrade) {
                    const allScenes = [...new Set(allDialogData.map(item => item.SCENE))].filter(Boolean);
                    allScenes.sort().forEach(scene => {
                        const option = document.createElement('option');
                        option.value = scene;
                        option.textContent = scene;
                        sceneFilterSelect.appendChild(option);
                    });
                    return;
                }
                
                // Filter scenes based on selected grade
                const filteredData = allDialogData.filter(item => item.SUB_TYPE1 === selectedGrade);
                const availableScenes = [...new Set(filteredData.map(item => item.SCENE))].filter(Boolean);
                
                // Add filtered scenes to dropdown
                availableScenes.sort().forEach(scene => {
                    const option = document.createElement('option');
                    option.value = scene;
                    option.textContent = scene;
                    sceneFilterSelect.appendChild(option);
                });
                
                // Reset scene selection when grade changes
                sceneFilterSelect.value = '';
            }
        });
    </script>
</body>
</html>