<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>对话语音转换 - 学习助手</title>
    <link rel="icon" href="assets/icons/logo_btrfly.ico" type="image/x-icon">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/utilities.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #f8fafc 0%, #e0c3fc 100%);
            background-attachment: fixed;
            font-family: 'Poppins', 'PingFang SC', 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .main-content {
            padding: 2rem 0;
            min-height: calc(100vh - 200px);
        }
        .section-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .section-header h1 {
            color: #7209b7;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(90deg, #7209b7, #4361ee, #4cc9f0);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 2px;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(76,201,240,0.08);
        }
        .section-header p {
            color: #666;
            font-size: 1.15rem;
            letter-spacing: 1px;
        }
        .assistant-container {
            background: rgba(255,255,255,0.85);
            border-radius: 2rem;
            box-shadow: 0 8px 32px 0 rgba(76,201,240,0.12), 0 1.5px 8px 0 rgba(114,9,183,0.08);
            backdrop-filter: blur(2px);
            max-width: 1100px;
            margin: 0 auto;
            padding: 2.5rem 2rem 2rem 2rem;
        }
        .form-group {
            margin-bottom: 24px;
            position: relative;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #7209b7;
        }
        textarea {
            width: 100%;
            padding: 1.1rem 1rem;
            border: 1.5px solid #e0c3fc;
            border-radius: 1.1rem;
            min-height: 300px;
            font-size: 1.13rem;
            box-sizing: border-box;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 2px 8px rgba(76,201,240,0.06);
            outline: none;
            transition: border 0.2s;
            resize: vertical;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        textarea:focus {
            border: 1.5px solid #7209b7;
            background: #f8fafc;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1.1rem;
            margin-bottom: 24px;
        }
        .control-group {
            flex: 1 1 180px;
            min-width: 150px;
            background: rgba(236,222,255,0.7);
            border-radius: 0.9rem;
            padding: 0.7rem 1rem 0.7rem 1rem;
            margin-bottom: 0;
            border: 1.5px solid #e0c3fc;
            box-shadow: 0 1px 4px rgba(76,201,240,0.04);
        }
        select, input[type="range"] {
            width: 100%;
            padding: 0.9rem;
            border: 1.5px solid #e0c3fc;
            border-radius: 0.9rem;
            font-size: 1.08rem;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 1px 4px rgba(76,201,240,0.05);
            transition: border 0.2s;
        }
        select:focus, input[type="range"]:focus {
            border: 1.5px solid #7209b7;
        }
        button {
            background: linear-gradient(90deg, #7209b7, #4361ee 80%);
            color: #fff;
            border: none;
            padding: 0.9rem 1.5rem;
            border-radius: 0.9rem;
            cursor: pointer;
            font-size: 1.13rem;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(76,201,240,0.08);
            transition: opacity 0.3s, background 0.2s;
            width: 100%;
        }
        button:hover {
            opacity: 0.92;
            background: linear-gradient(90deg, #4361ee, #7209b7 80%);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .audio-container {
            margin-top: 30px;
            text-align: center;
            display: none;
        }
        .audio-container.visible {
            display: block;
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            display: none;
        }
        .status.error {
            background-color: #ffebee;
            color: #c62828;
            display: block;
        }
        .status.loading {
            background-color: #e3f2fd;
            color: #1565c0;
            display: block;
        }
        .status.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            display: block;
            animation: fadeInOut 3s forwards;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        .audio-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }
        .audio-actions button {
            padding: 8px 15px;
            font-size: 14px;
            border-radius: 4px;
            width: auto;
        }
        .btn-download {
            background-color: #28a745;
        }
        .btn-download:hover {
            background-color: #218838;
        }
        .dialog-info {
            margin-top: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 1.2rem;
            border: 2px solid #e0c3fc;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(76,201,240,0.13);
            display: none;
        }
        .dialog-info.visible {
            display: block;
            animation: fadeIn 0.5s;
        }
        .role-list {
            margin-top: 15px;
        }
        .role-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #e0c3fc;
        }
        .role-name {
            font-weight: 500;
            flex: 1;
        }
        .role-voice-select {
            min-width: 200px;
        }
        .example-btn {
            display: inline-block;
            padding: 6px 12px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #4361ee;
            background: rgba(236,222,255,0.7);
            border: 1px solid #e0c3fc;
            border-radius: 6px;
            cursor: pointer;
        }
        .example-btn:hover {
            background: rgba(236,222,255,0.9);
        }
        
        .example-select {
            flex: 1;
            padding: 6px 12px;
            font-size: 0.9rem;
            color: #4361ee;
            background: rgba(236,222,255,0.7);
            border: 1px solid #e0c3fc;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            max-width: 250px;
            outline: none;
        }
        
        .example-select:hover {
            background: rgba(236,222,255,0.9);
        }
        
        .example-select:focus {
            border-color: #7209b7;
            box-shadow: 0 0 0 2px rgba(114, 9, 183, 0.1);
        }
        
        .example-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            margin-right: 5px;
            background: linear-gradient(90deg, #4361ee, #7209b7);
            color: white;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .helper-text {
            margin-top: 8px;
            font-size: 0.85rem;
            color: #666;
            font-style: italic;
        }
        
        @media (max-width: 768px) {
            .assistant-container {
                padding: 1.5rem 1.2rem;
                border-radius: 1.5rem;
                max-width: 100%;
                margin: 0 0.8rem;
            }
            .section-header {
                padding: 1rem 0;
            }
            .section-header h1 {
                font-size: 1.8rem;
                margin-bottom: 0.5rem;
            }
            .section-header p {
                font-size: 1rem;
            }
            .form-group label, .control-group label {
                font-size: 1.01rem;
            }
            textarea {
                font-size: 1.01rem;
                min-height: 200px;
                border-radius: 0.8rem;
                padding: 0.8rem;
            }
            .controls {
                gap: 0.6rem;
                flex-direction: column;
            }
            .control-group {
                flex: 1 1 100%;
                border-radius: 0.8rem;
            }
            .role-item {
                flex-direction: column;
                align-items: flex-start;
            }
            .role-voice-select {
                width: 100%;
                min-width: 100%;
            }

            /* Mobile menu styles */
            .mobile-menu-toggle {
                display: block;
                background: none;
                border: none;
                padding: 0.5rem;
                cursor: pointer;
                z-index: 1001;
                width: auto;
                margin-left: auto;
            }
            
            .mobile-menu-toggle span {
                display: block;
                width: 24px;
                height: 2px;
                background-color: #333;
                margin: 5px 0;
                transition: all 0.3s ease;
            }
            
            .main-nav {
                display: none;
            }
            
            body.mobile-menu-open .main-nav {
                display: flex;
                flex-direction: column;
                position: absolute;
                top: 100%;
                left: 0;
                width: 100%;
                background-color: white;
                padding: 1rem;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
                z-index: 1000;
            }
            
            body.mobile-menu-open .main-nav ul {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            body.mobile-menu-open .main-nav a {
                display: block;
                padding: 1rem;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="main-header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <a href="index.html">
                        <i class="fas fa-graduation-cap" style="background: linear-gradient(90deg, #4361ee, #7209b7); -webkit-background-clip: text; background-clip: text; color: transparent;"></i>
                        <span class="gradient-text">Alex的学习助手</span>
                    </a>
                </div>
                <nav class="main-nav">
                    <ul>
                        <li><a href="index.html">首页</a></li>
                        <li><a href="index.html#subjects">科目</a></li>
                        <li><a href="tts.html">语音</a></li>
                        <li><a href="draw.html">绘图</a></li>
                    </ul>
                </nav>
                <button class="mobile-menu-toggle" aria-label="切换菜单">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="section-header">
                <h1>对话<span class="gradient-text">语音</span>转换</h1>
                <p>为不同角色自动选择不同的声音，让对话更生动</p>
            </div>
            <div class="assistant-container">
                <div class="form-group">
                    <label for="dialog-input">输入对话文本（每个角色的台词以"角色名: "开头）：</label>
                    <textarea id="dialog-input" placeholder="例如：
Mom: Wake up, sweetheart! It's time for school. 
妈妈：醒醒，宝贝！该上学了。 
Child: Just five more minutes, please! 
孩子：再睡五分钟嘛，求你了！"></textarea>
                    <div class="example-controls">
                        <button class="example-btn" id="load-example">加载示例对话</button>
                        <select id="dialog-examples" class="example-select">
                            <option value="">选择对话模板...</option>
                            <!-- Options will be populated from DB -->
                        </select>
                    </div>
                    <div class="helper-text">
                        从下拉列表中选择对话类型，系统会自动加载对应的示例对话到文本框中。
                    </div>
                </div>
                
                <button id="analyze-btn" class="mb-4">分析对话</button>
                
                <div id="dialog-info" class="dialog-info">
                    <h3>角色配音设置</h3>
                    <p>我们已识别出以下角色，您可以为每个角色选择不同的声音：</p>
                    
                    <div id="role-list" class="role-list">
                        <!-- Roles will be inserted here by JS -->
                    </div>
                    
                    <div class="form-group" style="margin-top: 15px;">
                        <label>检测到的语言：</label>
                        <span id="detected-languages"></span>
                        
                        <div id="language-selection" style="margin-top: 10px; display: none;">
                            <label>请选择输出语言：</label>
                            <div style="margin-top: 8px;">
                                <label style="display: inline-block; margin-right: 15px; cursor: pointer;">
                                    <input type="radio" name="language-preference" value="english" checked> 
                                    <span style="margin-left: 5px;">英语</span>
                                </label>
                                <label style="display: inline-block; margin-right: 15px; cursor: pointer;">
                                    <input type="radio" name="language-preference" value="chinese"> 
                                    <span style="margin-left: 5px;">中文</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <button id="generate-btn" style="margin-top: 20px; display: none;">生成对话语音</button>
                
                <div class="status" id="status"></div>
                
                <div class="audio-container" id="audio-container">
                    <audio id="audio-player" controls style="width: 100%; border-radius: 1.1rem;"></audio>
                    <div class="audio-actions">
                        <button id="download-btn" class="btn-download">
                            <i class="fas fa-download"></i> 下载音频
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="main-footer">
        <div class="container">
            <div class="footer-bottom">
                <p style="margin: 0;">&copy; 2025 Alex的学习助手。保留所有权利。</p>
            </div>
        </div>
    </footer>

    <script src="js/common.js"></script>
    <script src="js/navigation.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const dialogInput = document.getElementById('dialog-input');
            const analyzeBtn = document.getElementById('analyze-btn');
            const generateBtn = document.getElementById('generate-btn');
            const dialogInfo = document.getElementById('dialog-info');
            const roleList = document.getElementById('role-list');
            const audioContainer = document.getElementById('audio-container');
            const audioPlayer = document.getElementById('audio-player');
            const downloadBtn = document.getElementById('download-btn');
            const status = document.getElementById('status');
            const loadExampleBtn = document.getElementById('load-example');
            const detectedLanguagesEl = document.getElementById('detected-languages');
            const languageSelectionEl = document.getElementById('language-selection');
            const dialogExamplesSelect = document.getElementById('dialog-examples');
            
            let currentAudioBlob = null;
            let identifiedRoles = [];
            let detectedLanguages = {
                hasEnglish: false,
                hasChinese: false
            };
            
            // Fetch dialog examples from the database
            fetchDialogTypes();
            
            // Event listener for dialog examples dropdown
            dialogExamplesSelect.addEventListener('change', async () => {
                if (dialogExamplesSelect.value) {
                    const selectedType = dialogExamplesSelect.value;
                    showLoading(`正在加载「${selectedType}」对话模板...`);
                    
                    try {
                        const dialogContent = await fetchDialogContent(selectedType);
                        if (dialogContent) {
                            dialogInput.value = dialogContent;
                            showStatus(`「${selectedType}」对话模板已加载`, 'success');
                            
                            // Reset dropdown after a short delay
                            setTimeout(() => {
                                dialogExamplesSelect.value = '';
                            }, 1000);
                        } else {
                            showError(`无法获取「${selectedType}」对话模板内容`);
                        }
                    } catch (error) {
                        console.error('获取对话内容错误:', error);
                        showError('获取对话内容失败: ' + error.message);
                        dialogExamplesSelect.value = '';
                    }
                }
            });
            
            // Function to fetch dialog types from database
            async function fetchDialogTypes() {
                try {
                    const response = await fetch('/api/db/query/english_dialog');
                    
                    if (!response.ok) {
                        throw new Error('获取对话类型失败');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success && Array.isArray(data.data)) {
                        // Extract unique dialog types
                        const types = [...new Set(data.data.map(item => item.TYPE))].filter(Boolean);
                        
                        // Populate select with unique types
                        types.sort().forEach(type => {
                            const option = document.createElement('option');
                            option.value = type;
                            option.textContent = type;
                            dialogExamplesSelect.appendChild(option);
                        });
                    }
                } catch (error) {
                    console.error('获取对话类型错误:', error);
                }
            }
            
            // Function to fetch dialog content by type
            async function fetchDialogContent(type) {
                const response = await fetch('/api/db/query/english_dialog');
                
                if (!response.ok) {
                    throw new Error('获取对话内容失败');
                }
                
                const data = await response.json();
                
                if (data.success && Array.isArray(data.data)) {
                    // Find the dialog with the selected type
                    const dialog = data.data.find(item => item.TYPE === type);
                    
                    if (dialog && dialog.CONTENT) {
                        return dialog.CONTENT;
                    }
                }
                
                return null;
            }
            
            // Voice options for different roles
            const voiceOptions = {
                male: [
                    { value: "male-qn-jingying", label: "精英青年音色" },
                    { value: "male-qn-qingse", label: "青涩青年音色" },
                    { value: "male-qn-badao", label: "霸道青年音色" },
                    { value: "presenter_male", label: "男性主持人" },
                    { value: "audiobook_male_1", label: "男性有声书1" },
                    { value: "audiobook_male_2", label: "男性有声书2" },
                    { value: "junlang_nanyou", label: "俊朗男友" },
                    { value: "Chinese (Mandarin)_Refreshing_Young_Man", label: "舒朗男声" },
                    { value: "Chinese (Mandarin)_Unrestrained_Young_Man", label: "不羁青年" },
                    { value: "Chinese (Mandarin)_Gentleman", label: "温润男声" },
                    { value: "Chinese (Mandarin)_Male_Announcer", label: "播报男声" },
                    { value: "Chinese (Mandarin)_Radio_Host", label: "电台男主播" },
                    { value: "Chinese (Mandarin)_Lyrical_Voice", label: "抒情男声" },
                    { value: "Chinese (Mandarin)_Sincere_Adult", label: "真诚青年" },
                    { value: "Chinese (Mandarin)_Gentle_Youth", label: "温润青年" },
                    { value: "Chinese (Mandarin)_Stubborn_Friend", label: "嘴硬竹马" },
                    { value: "Cantonese_ProfessionalHost（M)", label: "粤语专业男主持" },
                    { value: "Cantonese_PlayfulMan", label: "粤语活泼男声" },
                    { value: "English_Trustworthy_Man", label: "Trustworthy Man" },
                    { value: "English_Gentle-voiced_man", label: "Gentle-voiced man" },
                    { value: "English_Aussie_Bloke", label: "Aussie Bloke" },
                    { value: "Santa_Claus", label: "Santa Claus" },
                    { value: "Rudolph", label: "Rudolph" },
                    { value: "Charming_Santa", label: "Charming Santa" }
                ],
                female: [
                    { value: "female-shaonv", label: "少女音色" },
                    { value: "female-yujie", label: "御姐音色" },
                    { value: "female-chengshu", label: "成熟女性音色" },
                    { value: "female-tianmei", label: "甜美女性音色" },
                    { value: "presenter_female", label: "女性主持人" },
                    { value: "audiobook_female_1", label: "女性有声书1" },
                    { value: "audiobook_female_2", label: "女性有声书2" },
                    { value: "qiaopi_mengmei", label: "俏皮萌妹" },
                    { value: "Chinese (Mandarin)_News_Anchor", label: "新闻女声" },
                    { value: "Chinese (Mandarin)_Kind-hearted_Antie", label: "热心大婶" },
                    { value: "Chinese (Mandarin)_Sweet_Lady", label: "甜美女声" },
                    { value: "Chinese (Mandarin)_Wise_Women", label: "阅历姐姐" },
                    { value: "Chinese (Mandarin)_Warm_Girl", label: "温暖少女" },
                    { value: "Chinese (Mandarin)_Kind-hearted_Elder", label: "花甲奶奶" },
                    { value: "Chinese (Mandarin)_Gentle_Senior", label: "温柔学姐" },
                    { value: "Chinese (Mandarin)_Crisp_Girl", label: "清脆少女" },
                    { value: "Cantonese_ProfessionalHost（F)", label: "粤语专业女主持" },
                    { value: "Cantonese_CuteGirl", label: "粤语可爱女孩" },
                    { value: "English_Graceful_Lady", label: "Graceful Lady" },
                    { value: "English_UpsetGirl", label: "Upset Girl" },
                    { value: "English_Wiselady", label: "Wise Lady" },
                    { value: "Charming_Lady", label: "Charming Lady" },
                    { value: "Sweet_Girl", label: "Sweet Girl" },
                    { value: "Attractive_Girl", label: "Attractive Girl" },
                    { value: "Serene_Woman", label: "Serene Woman" }
                ],
                child: [
                    { value: "clever_boy", label: "聪明男童" },
                    { value: "cute_boy", label: "可爱男童" },
                    { value: "lovely_girl", label: "萌萌女童" },
                    { value: "chunzhen_xuedi", label: "纯真学弟" },
                    { value: "Chinese (Mandarin)_Pure-hearted_Boy", label: "清澈邻家弟弟" },
                    { value: "Chinese (Mandarin)_Straightforward_Boy", label: "率真弟弟" },
                    { value: "Sweet_Girl", label: "Sweet Girl" },
                    { value: "Attractive_Girl", label: "Attractive Girl" },
                    { value: "English_Aussie_Bloke", label: "Aussie Bloke" },
                    { value: "Cute_Elf", label: "Cute Elf" }
                ]
            };
            
            // Common role name mappings
            const roleCategories = {
                male: ["dad", "father", "grandpa", "grandfather", "uncle", "brother", "boy", "man", "mr", "sir", "male"],
                female: ["mom", "mother", "grandma", "grandmother", "aunt", "sister", "girl", "woman", "mrs", "ms", "miss", "lady", "female"],
                child: ["child", "kid", "baby", "boy", "girl", "son", "daughter"]
            };
            
            // Load example dialog
            loadExampleBtn.addEventListener('click', () => {
                dialogInput.value = `Mom: Wake up, sweetheart! It's time for school. 
妈妈：醒醒，宝贝！该上学了。 
Child: Just five more minutes, please! 
孩子：再睡五分钟嘛，求你了！ 
Dad: Did you sleep well last night? 
爸爸：昨晚睡得好吗？ 
Child: Yes, but I had a strange dream. 
孩子：是的，不过我做了个奇怪的梦。 
Mom: Hurry up, or you'll be late! 
妈妈：快点，不然你要迟到了！ 
Child: Okay, I'm getting up now! 
孩子：好吧，我起来了！ 
Dad: Did you brush your teeth? 
爸爸：你刷牙了吗？ 
Child: Not yet. I'll do it now! 
孩子：还没有，我现在去刷！ 
Mom: What do you want for breakfast? 
妈妈：你早餐想吃什么？ 
Child: Can I have some pancakes? 
孩子：我可以吃点煎饼吗？ 
Dad: Don't forget to pack your school bag. 
爸爸：别忘了整理你的书包。 
Child: I already did it last night! 
孩子：我昨晚已经整理好了！ 
Mom: Wear your sweater. It's cold outside. 
妈妈：穿上你的毛衣，外面很冷。 
Child: But I don't like sweaters! 
孩子：可是我不喜欢毛衣！ 
Dad: Do you have your lunchbox? 
爸爸：你的午餐盒带了吗？ 
Child: Oh no! I left it in the kitchen! 
孩子：哦不！我把它忘在厨房了！ 
Mom: Give me a hug before you go! 
妈妈：走之前给我一个拥抱！ 
Child: Love you, Mom! 
孩子：爱你，妈妈！ 
Dad: Have a great day at school! 
爸爸：祝你在学校度过美好的一天！ 
Child: Thanks, Dad! See you later! 
孩子：谢谢，爸爸！待会见！`;
            });
            
            // Helper function to analyze dialog text
            async function analyzeDialog(dialogText) {
                if (!dialogText) {
                    showError('请输入对话文本');
                    return false;
                }
                
                try {
                    // Call DeepSeek API to analyze the dialog
                    const messages = [
                        {
                            role: "system",
                            content: "你是一个专业的对话分析助手，擅长解析双语对话内容。请帮助从对话中提取所有说话者角色，并从英文部分分析每个角色可能的性别和年龄段。对于每一个角色，仅基于角色名判断其性别（男性/女性）和类型（成人/孩子/不确定）。此外，请检测对话中存在哪些语言（英文/中文）。"
                        },
                        {
                            role: "user",
                            content: `请分析以下对话文本，找出所有说话的角色，并仅基于英文部分和角色名称判断其可能的性别和类型。结果必须按以下严格的JSON格式返回：
                            
{
  "roles": [
    {
      "name": "角色名称，保持原文中的拼写和大小写",
      "gender": "male或female或unknown，根据角色名判断",
      "type": "adult或child或unknown，根据角色名判断",
      "lines": [
        {
          "english": "该角色的一段英文台词",
          "chinese": "该角色的一段中文台词"
        },
        ...更多台词...
      ]
    },
    ...更多角色...
  ],
  "languages": {
    "hasEnglish": true/false, 根据是否有英文台词,
    "hasChinese": true/false, 根据是否有中文台词
  }
}

对话文本：

${dialogText}`
                        }
                    ];
                    
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ messages })
                    });
                    
                    if (!response.ok) {
                        throw new Error('对话分析请求失败');
                    }
                    
                    const data = await response.json();
                    const assistantMessage = data.choices[0].message.content;
                    
                    // Extract JSON from response
                    const jsonMatch = assistantMessage.match(/```json\n([\s\S]*?)\n```/) || 
                                      assistantMessage.match(/{[\s\S]*?}/);
                    
                    if (!jsonMatch) {
                        throw new Error('未能从响应中提取有效数据');
                    }
                    
                    let jsonStr = jsonMatch[0];
                    if (jsonStr.startsWith('```json')) {
                        jsonStr = jsonMatch[1];
                    }
                    
                    // Parse the JSON response
                    const dialogData = JSON.parse(jsonStr);
                    identifiedRoles = dialogData.roles;
                    
                    // Extract detected languages
                    if (dialogData.languages) {
                        detectedLanguages = dialogData.languages;
                    } else {
                        // Fallback detection if API didn't return languages info
                        detectedLanguages = {
                            hasEnglish: identifiedRoles.some(role => 
                                role.lines.some(line => line.english && line.english.trim().length > 0)
                            ),
                            hasChinese: identifiedRoles.some(role => 
                                role.lines.some(line => line.chinese && line.chinese.trim().length > 0)
                            )
                        };
                    }
                    
                    // Update the detected languages display
                    updateDetectedLanguagesDisplay();
                    
                    // Render the role list
                    renderRoleList(identifiedRoles);
                    
                    // Show the dialog info section
                    dialogInfo.classList.add('visible');
                    generateBtn.style.display = 'block';
                    clearStatus();
                    
                    return true;
                } catch (error) {
                    console.error('Dialog analysis error:', error);
                    showError('对话分析失败: ' + error.message);
                    return false;
                }
            }
            
            // Analyze the dialog text using DeepSeek API
            analyzeBtn.addEventListener('click', async () => {
                const dialogText = dialogInput.value.trim();
                generateBtn.style.display = 'none';
                dialogInfo.classList.remove('visible');
                audioContainer.classList.remove('visible');
                languageSelectionEl.style.display = 'none';
                
                showLoading('正在分析对话文本...');
                await analyzeDialog(dialogText);
            });
            
            // Update the detected languages display
            function updateDetectedLanguagesDisplay() {
                let languagesText = '';
                
                if (detectedLanguages.hasEnglish && detectedLanguages.hasChinese) {
                    languagesText = '<span class="badge">英文</span> <span class="badge">中文</span>';
                    languageSelectionEl.style.display = 'block';
                    // Preselect English by default
                    document.querySelector('input[name="language-preference"][value="english"]').checked = true;
                } else if (detectedLanguages.hasEnglish) {
                    languagesText = '<span class="badge">英文</span>';
                    languageSelectionEl.style.display = 'none';
                } else if (detectedLanguages.hasChinese) {
                    languagesText = '<span class="badge">中文</span>';
                    languageSelectionEl.style.display = 'none';
                } else {
                    languagesText = '<span class="badge">未检测到支持的语言</span>';
                    languageSelectionEl.style.display = 'none';
                }
                
                detectedLanguagesEl.innerHTML = languagesText;
            }
            
            // Render the list of identified roles
            function renderRoleList(roles) {
                roleList.innerHTML = '';
                
                roles.forEach((role, index) => {
                    const roleDiv = document.createElement('div');
                    roleDiv.className = 'role-item';
                    
                    // Determine voice category based on role name and type
                    let voiceCategory = 'male'; // default
                    if (role.gender === 'female' || isInCategory(role.name.toLowerCase(), roleCategories.female)) {
                        voiceCategory = 'female';
                    }
                    if (role.type === 'child' || isInCategory(role.name.toLowerCase(), roleCategories.child)) {
                        voiceCategory = 'child';
                    }
                    
                    // Create voice select dropdown
                    const voiceSelect = document.createElement('select');
                    voiceSelect.className = 'role-voice-select';
                    voiceSelect.id = `voice-${index}`;
                    
                    // Add voice options based on category
                    const voices = voiceOptions[voiceCategory] || voiceOptions.male;
                    voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.value;
                        option.textContent = voice.label;
                        
                        // Pre-select a reliable female voice for Mom
                        if (role.name === 'Mom' && (voice.value === "Chinese (Mandarin)_Young_Girl" || voice.value === "English_Graceful_Lady")) {
                            option.selected = true;
                        }
                        
                        voiceSelect.appendChild(option);
                    });
                    
                    // Create role element
                    roleDiv.innerHTML = `
                        <div class="role-name">
                            ${role.name}
                            <div style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                                ${role.lines.length} 句台词
                                ${role.gender !== 'unknown' ? ` • ${role.gender === 'male' ? '男性' : '女性'}` : ''}
                                ${role.type !== 'unknown' ? ` • ${role.type === 'adult' ? '成人' : '儿童'}` : ''}
                            </div>
                        </div>
                    `;
                    roleDiv.appendChild(voiceSelect);
                    roleList.appendChild(roleDiv);
                });
            }
            
            // Check if a name belongs to a category
            function isInCategory(name, categoryTerms) {
                return categoryTerms.some(term => name.includes(term));
            }
            
            // Generate dialog audio with selected voices
            generateBtn.addEventListener('click', async () => {
                if (!identifiedRoles || identifiedRoles.length === 0) {
                    showError('请先分析对话文本');
                    return;
                }
                
                generateBtn.disabled = true;
                showLoading('正在生成对话语音...');
                audioContainer.classList.remove('visible');
                
                try {
                    // Check if dialog is in single paragraph format that needs to be reformatted
                    const originalText = dialogInput.value.trim();
                    const lineCount = originalText.split('\n').filter(line => line.trim()).length;
                    
                    // Check for common patterns in single-paragraph dialog
                    const hasMultipleColons = (originalText.match(/:/g) || []).length >= 3;
                    const spaceAfterName = originalText.match(/\w+:\s/g);
                    const hasNames = spaceAfterName && spaceAfterName.length >= 3;
                    
                    // More sophisticated detection logic
                    const speakerPattern = /\b(Mom|Dad|Child|Mother|Father|妈妈|爸爸|孩子)(?=:)/gi;
                    const potentialSpeakers = originalText.match(speakerPattern) || [];
                    const uniqueSpeakers = new Set(potentialSpeakers.map(s => s.toLowerCase()));
                    
                    // If text contains multiple speakers but few line breaks, likely needs reformatting
                    const needsReformatting = lineCount < uniqueSpeakers.size && 
                                             hasMultipleColons && 
                                             hasNames &&
                                             uniqueSpeakers.size >= 2;
                    
                    if (needsReformatting) {
                        showLoading('检测到单段对话格式，正在重新格式化...');
                        
                        // Request reformatting from DeepSeek API
                        const formatMessages = [
                            {
                                role: "system",
                                content: "你是一个专业的文本格式化助手，擅长将单段式对话文本重新格式化为多行对话格式。你需要确保每个角色的对话都正确分隔，特别是中英文混合的对话。"
                            },
                            {
                                role: "user",
                                content: `请将以下单段对话文本重新格式化为多行对话，使每个角色的台词占一行，并严格保持中英文内容。

格式要求：
1. 每个角色的台词应该单独占一行
2. 格式为"角色名: 台词内容"
3. 如果台词同时包含英文和中文，保持原样
4. 不要添加任何额外说明，只返回格式化后的文本

原始文本：
${originalText}

请只返回格式化后的对话文本，不要添加任何其他文字或解释。`
                            }
                        ];
                        
                        const formatResponse = await fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ messages: formatMessages })
                        });
                        
                        if (!formatResponse.ok) {
                            throw new Error('对话格式化请求失败');
                        }
                        
                        const formatData = await formatResponse.json();
                        const formattedText = formatData.choices[0].message.content.trim();
                        
                        console.log('原始对话文本:', originalText);
                        console.log('格式化后文本:', formattedText);
                        
                        // Update the dialog input with formatted text
                        dialogInput.value = formattedText;
                        
                        // Show success message about reformatting
                        showStatus('对话已自动重新格式化为多行格式', 'success');
                        
                        // Re-run the dialog analysis with the formatted text
                        showLoading('正在分析重新格式化的对话...');
                        await analyzeDialog(formattedText);
                    }
                    
                    // Collect voice selections for each role
                    const roleVoices = {};
                    identifiedRoles.forEach((role, index) => {
                        const voiceSelect = document.getElementById(`voice-${index}`);
                        roleVoices[role.name] = voiceSelect.value;
                    });
                    
                    // Debug output
                    console.log('Role voices mapping:', roleVoices);
                    
                    // Create sequence information to ensure dialog order is preserved
                    // This extracts the original dialog sequence from the text input
                    const dialogText = dialogInput.value.trim();
                    const dialogLines = dialogText.split('\n').filter(line => line.trim());
                    
                    // Extract the sequence of roles from the original text
                    const sequenceInfo = [];
                    
                    // Debugging output of original dialog lines
                    console.log('Original dialog lines:', dialogLines.map(l => l.trim()));
                    console.log('Identified roles:', identifiedRoles.map(r => r.name));
                    
                    // Parse the original text to extract the sequence of roles and lines
                    dialogLines.forEach((line, lineIndex) => {
                        // Find role name before the colon
                        const colonIndex = line.indexOf(':');
                        if (colonIndex > 0) {
                            const roleName = line.substring(0, colonIndex).trim();
                            const lineText = line.substring(colonIndex + 1).trim();
                            
                            // Skip empty lines
                            if (!lineText) return;
                            
                            console.log(`Line ${lineIndex+1}: Role "${roleName}", Text: "${lineText.substring(0, 20)}..."`);
                            
                            // Find the matching role in identifiedRoles
                            const roleIndex = identifiedRoles.findIndex(r => r.name === roleName);
                            
                            if (roleIndex >= 0) {
                                const role = identifiedRoles[roleIndex];
                                
                                // Find the matching line in this role's lines using fuzzy matching
                                // This is more reliable than exact matching
                                let bestMatchIndex = -1;
                                let bestMatchScore = 0;
                                
                                role.lines.forEach((l, i) => {
                                    // Check both English and Chinese text
                                    const englishMatch = l.english && lineText.includes(l.english.substring(0, Math.min(l.english.length, 10)));
                                    const chineseMatch = l.chinese && lineText.includes(l.chinese.substring(0, Math.min(l.chinese.length, 10)));
                                    
                                    // If either matches, this is a candidate
                                    if (englishMatch || chineseMatch) {
                                        // Calculate match score based on text overlap
                                        let score = 0;
                                        if (l.english) {
                                            score += getMatchScore(lineText, l.english);
                                        }
                                        if (l.chinese) {
                                            score += getMatchScore(lineText, l.chinese);
                                        }
                                        
                                        // Update best match if this is better
                                        if (score > bestMatchScore) {
                                            bestMatchScore = score;
                                            bestMatchIndex = i;
                                        }
                                    }
                                });
                                
                                // If we found a good match, add it to the sequence
                                if (bestMatchIndex >= 0) {
                                    console.log(`-> Matched to line index ${bestMatchIndex} (score: ${bestMatchScore})`);
                                    
                                    sequenceInfo.push({
                                        role: roleName,
                                        line_index: bestMatchIndex,
                                        sequence_position: lineIndex,  // Use the actual line index from the input text
                                        original_line: lineText
                                    });
                                } else {
                                    console.warn(`-> No good match found for line: "${lineText}"`);
                                    
                                    // Fall back to a simple position-based match as last resort
                                    // Try to find a line that hasn't been matched yet
                                    const usedIndices = sequenceInfo
                                        .filter(si => si.role === roleName)
                                        .map(si => si.line_index);
                                    
                                    for (let i = 0; i < role.lines.length; i++) {
                                        if (!usedIndices.includes(i)) {
                                            console.log(`-> Falling back to position-based match at index ${i}`);
                                            sequenceInfo.push({
                                                role: roleName,
                                                line_index: i,
                                                sequence_position: lineIndex,  // Use the actual line index from the input text
                                                original_line: lineText,
                                                is_fallback: true
                                            });
                                            break;
                                        }
                                    }
                                }
                            } else {
                                console.warn(`Role "${roleName}" not found in identified roles.`);
                            }
                        } else {
                            console.warn(`Line doesn't follow "Role: Text" format: "${line}"`);
                        }
                    });
                    
                    // Helper function to calculate text match score
                    function getMatchScore(text1, text2) {
                        // Basic implementation: length of common substring
                        const minLen = Math.min(text1.length, text2.length);
                        let maxCommonLen = 0;
                        
                        for (let i = 0; i < minLen; i++) {
                            // Start from different positions and find common substrings
                            let j = 0;
                            while (i + j < minLen && text1.charAt(i + j) === text2.charAt(j)) {
                                j++;
                            }
                            maxCommonLen = Math.max(maxCommonLen, j);
                        }
                        
                        return maxCommonLen;
                    }
                    
                    // Log the final sequence information
                    console.log(`Final dialog sequence (${sequenceInfo.length} lines):`, sequenceInfo);
                    
                    // Sort sequence by sequence_position to ensure proper order
                    sequenceInfo.sort((a, b) => a.sequence_position - b.sequence_position);
                    
                    // Log the sorted sequence
                    console.log(`Sequence after sorting by position:`);
                    sequenceInfo.forEach((seq, i) => {
                        const role = seq.role;
                        const lineIndex = seq.line_index;
                        const position = seq.sequence_position;
                        console.log(`${i+1}. Position ${position}: ${role} line ${lineIndex}`);
                    });
                    
                    // Verify if all original lines are accounted for
                    if (sequenceInfo.length < dialogLines.length) {
                        console.warn(`Not all lines were matched! Original: ${dialogLines.length}, Matched: ${sequenceInfo.length}`);
                        
                        // To ensure all dialog lines are included, we'll create a mapping of which lines 
                        // from the original text have been matched
                        const matchedLines = new Set();
                        sequenceInfo.forEach(seq => {
                            // Create a key from the role and text to identify matched lines
                            const key = `${seq.role}:${seq.original_line}`;
                            matchedLines.add(key);
                        });
                        
                        // Check original dialog lines again and add any that weren't matched
                        dialogLines.forEach((line, lineIndex) => {
                            const colonIndex = line.indexOf(':');
                            if (colonIndex > 0) {
                                const roleName = line.substring(0, colonIndex).trim();
                                const lineText = line.substring(colonIndex + 1).trim();
                                
                                if (!lineText) return; // Skip empty lines
                                
                                const key = `${roleName}:${lineText}`;
                                if (!matchedLines.has(key)) {
                                    console.log(`Adding previously unmatched line: ${key}`);
                                    
                                    // Find the role
                                    const roleIndex = identifiedRoles.findIndex(r => r.name === roleName);
                                    if (roleIndex >= 0) {
                                        // Add as a new entry with best-effort line matching
                                        // Find the first unused line for this role
                                        const role = identifiedRoles[roleIndex];
                                        const usedIndices = sequenceInfo
                                            .filter(si => si.role === roleName)
                                            .map(si => si.line_index);
                                        
                                        // Find an unused line index or use 0 as fallback
                                        let lineIndexInRole = 0;
                                        for (let i = 0; i < role.lines.length; i++) {
                                            if (!usedIndices.includes(i)) {
                                                lineIndexInRole = i;
                                                break;
                                            }
                                        }
                                        
                                        sequenceInfo.push({
                                            role: roleName,
                                            line_index: lineIndexInRole,
                                            sequence_position: lineIndex,  // Use the actual line index from the original dialog
                                            original_line: lineText,
                                            is_emergency_fallback: true
                                        });
                                    }
                                }
                            }
                        });
                        
                        console.log(`After recovery: ${sequenceInfo.length} lines in sequence`);
                    }
                    
                    // Get language preference
                    let selectedLanguage;
                    if (detectedLanguages.hasEnglish && detectedLanguages.hasChinese) {
                        // Get from selected radio button
                        selectedLanguage = document.querySelector('input[name="language-preference"]:checked').value;
                    } else if (detectedLanguages.hasEnglish) {
                        selectedLanguage = "english";
                    } else if (detectedLanguages.hasChinese) {
                        selectedLanguage = "chinese";
                    } else {
                        selectedLanguage = "english"; // Default fallback
                    }
                    console.log(`Selected language preference: ${selectedLanguage}`);
                    
                    // Prepare the TTS request with role and voice mapping
                    const requestData = {
                        dialog: identifiedRoles,
                        roleVoices: roleVoices,
                        model: "speech-02-hd",
                        // Include the original sequence information
                        original_sequence: sequenceInfo,
                        // Include language preference
                        language_preference: selectedLanguage
                    };
                    
                    // Call the TTS API
                    const response = await fetch('/api/tts-dialog', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    if (!response.ok) {
                        let errorMessage = '语音生成失败';
                        try {
                            const errorData = await response.json();
                            console.error('API Error Response:', errorData);
                            
                            if (errorData.details && typeof errorData.details === 'object') {
                                // Show detailed API error for debugging
                                const detailsStr = JSON.stringify(errorData.details, null, 2);
                                errorMessage = `API错误: ${errorData.error || ''}\n详情: ${detailsStr}`;
                                console.error('Detailed API error:', detailsStr);
                            } else {
                                errorMessage = errorData.error || errorMessage;
                            }
                            
                            // Show special message for credential errors
                            if (errorMessage.includes('credentials') || errorMessage.includes('API key') || 
                                (errorData.details && errorData.details.message && 
                                (errorData.details.message.includes('authorization') || 
                                 errorData.details.message.includes('API key')))) {
                                errorMessage = '语音API凭证无效。请检查API密钥和Group ID设置。';
                            }
                        } catch (e) {
                            errorMessage = `语音生成失败: ${response.status} ${response.statusText}`;
                            console.error('Failed to parse error response:', e);
                        }
                        throw new Error(errorMessage);
                    }
                    
                    // Process the audio response
                    const audioData = await response.arrayBuffer();
                    const audioBlob = new Blob([audioData], { type: 'audio/mp3' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    // Store the blob for download
                    currentAudioBlob = audioBlob;
                    
                    // Update audio player and show it
                    audioPlayer.src = audioUrl;
                    audioContainer.classList.add('visible');
                    clearStatus();
                    
                    // Try to play the audio
                    audioPlayer.play().catch(e => {
                        console.error('Audio playback error:', e);
                        showError('音频播放失败：' + e.message);
                    });
                    
                } catch (error) {
                    console.error('TTS Error:', error);
                    showError(error.message || '语音生成失败，请重试');
                } finally {
                    // Re-enable button
                    generateBtn.disabled = false;
                }
            });
            
            // Download button handler
            downloadBtn.addEventListener('click', () => {
                if (!currentAudioBlob) {
                    showError('没有可下载的音频');
                    return;
                }
                
                const downloadUrl = URL.createObjectURL(currentAudioBlob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = `dialog-${new Date().toISOString().slice(0,10)}.mp3`;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(downloadUrl);
                }, 100);
            });
            
            // Helper functions
            function showError(message) {
                status.textContent = message;
                status.className = 'status error';
            }
            
            function showLoading(message) {
                status.textContent = message;
                status.className = 'status loading';
            }
            
            function showStatus(message, type) {
                status.textContent = message;
                status.className = `status ${type}`;
                
                // Auto-clear success messages after a few seconds
                if (type === 'success') {
                    setTimeout(() => {
                        if (status.textContent === message) {
                            clearStatus();
                        }
                    }, 3000);
                }
            }
            
            function clearStatus() {
                status.textContent = '';
                status.className = 'status';
            }
        });
    </script>
</body>
</html> 