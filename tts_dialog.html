<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>对话语音转换 - Study Assist</title>
  
  <!-- Use a relative path instead of absolute URL to avoid MIME type issues -->
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  
  <!-- Add essential styles directly in the page to ensure it works even if external CSS fails -->
  <style>
    /* Essential styles for the dialog functionality */
    :root {
      --primary-color: #7209b7;
      --secondary-color: #3f37c9;
      --accent-color: #4cc9f0;
      --text-color: #333;
      --bg-color: #f8f9fa;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.6;
      margin: 0;
      padding: 0;
    }
    
    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1, h2, h3 {
      color: var(--primary-color);
    }
    
    .form-group {
      margin-bottom: 20px;
      position: relative;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
    }
    
    textarea, select, input[type="range"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    
    textarea {
      min-height: 100px;
      resize: vertical;
    }
    
    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: var(--secondary-color);
    }
    
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    .status {
      display: inline-block;
      padding: 8px 12px;
      margin: 10px 0;
      border-radius: 4px;
    }
    
    .status.error {
      background-color: #ffebee;
      color: #c62828;
    }
    
    .status.loading {
      background-color: #e3f2fd;
      color: #1565c0;
    }
    
    .analysis-container, .audio-container {
      margin-top: 40px;
      padding: 20px;
      background-color: white;
      border-radius: 8px;
      box-shadow: var(--shadow-md);
    }
    
    .roles-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 15px 0;
    }
    
    .role-badge {
      background-color: #e3f2fd;
      color: #1565c0;
      padding: 4px 10px;
      border-radius: 16px;
      font-size: 0.9em;
    }
    
    .segment-item {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 8px;
    }
    
    .segment-role {
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 8px;
    }
    
    .segment-text {
      margin-bottom: 10px;
    }
    
    .segment-audio {
      width: 100%;
      margin-top: 10px;
    }
    
    audio {
      width: 100%;
      margin: 15px 0;
    }
    
    #download-btn {
      margin-top: 10px;
    }
    
    /* For the resize handle */
    .resize-handle {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Header styles */
    .simple-header {
      background-color: var(--primary-color);
      color: white;
      padding: 10px 20px;
      margin-bottom: 20px;
      box-shadow: var(--shadow-md);
    }
    
    .simple-header a {
      color: white;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
    }
    
    .simple-header a i {
      margin-right: 8px;
    }
    
    .hidden {
      display: none;
    }
    
    .visible {
      display: block;
    }
  </style>
  
  <script src="js/common.js"></script>
  <script src="js/navigation.js"></script>

  <script>
      document.addEventListener('DOMContentLoaded', () => {
          // Hide analysis and audio sections initially
          const dialogAnalysisSection = document.getElementById('dialog-analysis');
          const combinedAudioSection = document.getElementById('combined-audio');
          
          if (dialogAnalysisSection) {
              dialogAnalysisSection.classList.add('hidden');
              dialogAnalysisSection.classList.remove('visible');
          }
          
          if (combinedAudioSection) {
              combinedAudioSection.classList.add('hidden');
              combinedAudioSection.classList.remove('visible');
          }
          
          // Initialize form elements
          const dialogInput = document.getElementById('dialog-input');
          const modelSelect = document.getElementById('model-select');
          const speedControl = document.getElementById('speed-control');
          const speedValue = document.getElementById('speed-value');
          const generateBtn = document.getElementById('generate-btn');
          const statusElement = document.getElementById('status');
          const dialogAnalysis = document.getElementById('dialog-analysis');
          const rolesCount = document.getElementById('roles-count');
          const rolesList = document.getElementById('roles-list');
          const segmentsContainer = document.getElementById('segments-container');
          const combinedAudio = document.getElementById('combined-audio');
          const combinedPlayer = document.getElementById('combined-player');
          const downloadBtn = document.getElementById('download-btn');
          
          let audioSegments = [];
          let combinedAudioBlob = null;
          
          // Update speed value display when slider changes
          if (speedControl && speedValue) {
              speedControl.addEventListener('input', () => {
                  speedValue.textContent = speedControl.value;
              });
          }
          
          // Add custom resize handle for textarea
          const formGroup = document.querySelector('.form-group');
          const textarea = dialogInput;
          
          // Only setup the resize functionality if both formGroup and textarea exist
          if (formGroup && textarea) {
              let isResizing = false;
              let initialHeight = 0;
              let initialY = 0;
              
              // Create a visible resize handle element
              const resizeHandle = document.createElement('div');
              resizeHandle.className = 'resize-handle';
              resizeHandle.style.position = 'absolute';
              resizeHandle.style.width = '18px';
              resizeHandle.style.height = '18px';
              resizeHandle.style.cursor = 'ns-resize';
              resizeHandle.style.zIndex = '20';
              resizeHandle.style.opacity = '0.7';
              resizeHandle.innerHTML = '<i class="fas fa-grip-lines" style="font-size: 12px; color: rgba(114, 9, 183, 0.7);"></i>';
              formGroup.appendChild(resizeHandle);
              
              // Position the resize handle at the bottom right of the textarea
              function updateResizeHandlePosition() {
                  const textareaRect = textarea.getBoundingClientRect();
                  const containerRect = formGroup.getBoundingClientRect();
                  
                  // Calculate position relative to the form group container
                  const bottom = containerRect.height - (textareaRect.bottom - containerRect.top) - 3;
                  const right = containerRect.width - (textareaRect.right - containerRect.left) - 3;
                  
                  resizeHandle.style.bottom = `${bottom}px`;
                  resizeHandle.style.right = `${right}px`;
              }
              
              // Update position initially and when window resizes
              updateResizeHandlePosition();
              window.addEventListener('resize', updateResizeHandlePosition);
              
              // Also update position when textarea height changes
              const resizeObserver = new ResizeObserver(() => {
                  updateResizeHandlePosition();
              });
              resizeObserver.observe(textarea);
              
              // Mouse events for desktop
              resizeHandle.addEventListener('mousedown', (e) => {
                  isResizing = true;
                  initialHeight = textarea.offsetHeight;
                  initialY = e.clientY;
                  e.preventDefault();
              });
              
              document.addEventListener('mousemove', (e) => {
                  if (!isResizing) return;
                  const delta = e.clientY - initialY;
                  const newHeight = initialHeight + delta;
                  if (newHeight >= 48 && newHeight <= 300) {
                      textarea.style.height = newHeight + 'px';
                      updateResizeHandlePosition(); // Update handle position while resizing
                  }
              });
              
              document.addEventListener('mouseup', () => {
                  isResizing = false;
              });
              
              // Touch events for mobile
              resizeHandle.addEventListener('touchstart', (e) => {
                  isResizing = true;
                  initialHeight = textarea.offsetHeight;
                  initialY = e.touches[0].clientY;
                  e.preventDefault();
              });
              
              document.addEventListener('touchmove', (e) => {
                  if (!isResizing) return;
                  const delta = e.touches[0].clientY - initialY;
                  const newHeight = initialHeight + delta;
                  if (newHeight >= 48 && newHeight <= 300) {
                      textarea.style.height = newHeight + 'px';
                      updateResizeHandlePosition(); // Update handle position while resizing
                  }
              });
              
              document.addEventListener('touchend', () => {
                  isResizing = false;
              });
          }
          
          // Generate dialog TTS
          if (generateBtn && dialogInput) {
              generateBtn.addEventListener('click', async () => {
                  const dialogText = dialogInput.value.trim();
                  
                  if (!dialogText) {
                      showError('请输入要转换的对话文本');
                      return;
                  }
                  
                  // Disable button and show loading status
                  generateBtn.disabled = true;
                  showLoading('正在分析对话文本...');
                  
                  if (dialogAnalysis) dialogAnalysis.classList.remove('hidden');
                  if (combinedAudio) combinedAudio.classList.remove('hidden');
                  if (segmentsContainer) segmentsContainer.innerHTML = '';
                  if (rolesList) rolesList.innerHTML = '';
                  
                  try {
                      // Prepare request data
                      const requestData = {
                          dialog_text: dialogText,
                          model: modelSelect ? modelSelect.value : 'default',
                          speed: speedControl ? parseFloat(speedControl.value) : 1.0,
                          pitch: 0,
                          volume: 1.0
                      };
                      
                      // Call the Dialog TTS API
                      const response = await fetch('/api/tts_dialog', {
                          method: 'POST',
                          headers: {
                              'Content-Type': 'application/json'
                          },
                          body: JSON.stringify(requestData)
                      });
                      
                      if (!response.ok) {
                          // Try to parse error message
                          let errorMessage = '对话语音生成失败';
                          try {
                              const errorData = await response.json();
                              errorMessage = errorData.error || errorMessage;
                              console.error('API Error:', errorData);
                          } catch (e) {
                              // If we can't parse JSON, use status text
                              errorMessage = `对话语音生成失败: ${response.status} ${response.statusText}`;
                              console.error('Failed to parse error response:', e);
                          }
                          throw new Error(errorMessage);
                      }
                      
                      // Parse the successful response
                      const responseData = await response.json();
                      console.log('Dialog TTS Response:', responseData);
                      
                      if (!responseData.success || !responseData.analysis || !responseData.audio_segments) {
                          throw new Error('服务器返回了无效的响应格式');
                      }
                      
                      // Display dialog analysis results
                      const analysis = responseData.analysis;
                      audioSegments = responseData.audio_segments;
                      
                      // Update roles count
                      if (rolesCount) rolesCount.textContent = analysis.roles.length;
                      
                      // Display roles
                      if (rolesList) {
                          analysis.roles.forEach((role, index) => {
                              const roleBadge = document.createElement('div');
                              roleBadge.className = 'role-badge';
                              roleBadge.innerHTML = `<i class="fas fa-user"></i> ${role}`;
                              rolesList.appendChild(roleBadge);
                          });
                      }
                      
                      // Display dialog segments with their audio
                      if (segmentsContainer) {
                          audioSegments.forEach((segment, index) => {
                              const segmentItem = document.createElement('div');
                              segmentItem.className = 'segment-item';
                              
                              // Role heading with icon
                              const roleElement = document.createElement('div');
                              roleElement.className = 'segment-role';
                              roleElement.innerHTML = `<i class="fas fa-user-circle"></i> ${segment.role}`;
                              
                              // Text content
                              const textElement = document.createElement('div');
                              textElement.className = 'segment-text';
                              textElement.textContent = segment.text;
                              
                              // Create audio element if audio data is available
                              const audioElement = document.createElement('audio');
                              audioElement.className = 'segment-audio';
                              audioElement.controls = true;
                              
                              if (segment.audio_base64) {
                                  // Create blob from base64
                                  const audioBlob = base64ToBlob(segment.audio_base64, 'audio/mp3');
                                  const audioUrl = URL.createObjectURL(audioBlob);
                                  audioElement.src = audioUrl;
                              }
                              
                              // Add elements to segment
                              segmentItem.appendChild(roleElement);
                              segmentItem.appendChild(textElement);
                              segmentItem.appendChild(audioElement);
                              
                              // Add segment to container
                              segmentsContainer.appendChild(segmentItem);
                          });
                      }
                      
                      // Show the dialog analysis section
                      if (dialogAnalysis) {
                          dialogAnalysis.classList.remove('hidden');
                          dialogAnalysis.classList.add('visible');
                      }
                      clearStatus();
                      
                      // Create combined audio if there are multiple segments
                      if (audioSegments.length > 1 && combinedPlayer && combinedAudio) {
                          showLoading('正在合成完整对话音频...');
                          
                          try {
                              // Combine audio segments using Web Audio API
                              const combinedBuffer = await combineAudioSegments();
                              combinedAudioBlob = await audioBufferToBlob(combinedBuffer);
                              
                              // Set the combined audio source
                              const combinedAudioUrl = URL.createObjectURL(combinedAudioBlob);
                              combinedPlayer.src = combinedAudioUrl;
                              
                              // Show the combined audio player
                              combinedAudio.classList.remove('hidden');
                              combinedAudio.classList.add('visible');
                              clearStatus();
                          } catch (error) {
                              console.error('Error combining audio:', error);
                              showError('无法合成完整对话音频: ' + error.message);
                          }
                      }
                      
                  } catch (error) {
                      console.error('Dialog TTS Error:', error);
                      showError(error.message || '对话语音生成失败，请重试');
                  } finally {
                      // Re-enable button
                      generateBtn.disabled = false;
                  }
              });
          }
          
          // Download combined audio
          if (downloadBtn) {
              downloadBtn.addEventListener('click', () => {
                  if (!combinedAudioBlob) {
                      showError('没有可下载的完整对话音频');
                      return;
                  }
                  
                  // Create a download link
                  const downloadUrl = URL.createObjectURL(combinedAudioBlob);
                  const a = document.createElement('a');
                  a.href = downloadUrl;
                  a.download = `dialog-${new Date().toISOString().slice(0,10)}.mp3`;
                  document.body.appendChild(a);
                  a.click();
                  
                  // Clean up
                  setTimeout(() => {
                      document.body.removeChild(a);
                      URL.revokeObjectURL(downloadUrl);
                  }, 100);
              });
          }
          
          // Helper function to convert base64 to blob
          function base64ToBlob(base64, mimeType) {
              const byteCharacters = atob(base64);
              const byteArrays = [];
              
              for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                  const slice = byteCharacters.slice(offset, offset + 512);
                  
                  const byteNumbers = new Array(slice.length);
                  for (let i = 0; i < slice.length; i++) {
                      byteNumbers[i] = slice.charCodeAt(i);
                  }
                  
                  const byteArray = new Uint8Array(byteNumbers);
                  byteArrays.push(byteArray);
              }
              
              return new Blob(byteArrays, { type: mimeType });
          }
          
          // Helper function to combine audio segments using Web Audio API
          async function combineAudioSegments() {
              if (!audioSegments || audioSegments.length === 0) {
                  throw new Error('No audio segments to combine');
              }
              
              const audioContext = new (window.AudioContext || window.webkitAudioContext)();
              const audioBuffers = [];
              
              // Convert each base64 audio segment to AudioBuffer
              for (const segment of audioSegments) {
                  if (segment.audio_base64) {
                      const audioBlob = base64ToBlob(segment.audio_base64, 'audio/mp3');
                      const arrayBuffer = await audioBlob.arrayBuffer();
                      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                      audioBuffers.push(audioBuffer);
                  }
              }
              
              if (audioBuffers.length === 0) {
                  throw new Error('No valid audio buffers to combine');
              }
              
              // Calculate total duration
              let totalDuration = 0;
              for (const buffer of audioBuffers) {
                  totalDuration += buffer.duration;
              }
              
              // Create a new buffer with the total duration
              const channelCount = audioBuffers[0].numberOfChannels;
              const sampleRate = audioBuffers[0].sampleRate;
              const combinedBuffer = audioContext.createBuffer(
                  channelCount,
                  sampleRate * totalDuration,
                  sampleRate
              );
              
              // Copy each buffer to the combined buffer
              let offset = 0;
              for (const buffer of audioBuffers) {
                  for (let channel = 0; channel < channelCount; channel++) {
                      const combinedChannelData = combinedBuffer.getChannelData(channel);
                      const bufferChannelData = buffer.getChannelData(channel);
                      
                      for (let i = 0; i < bufferChannelData.length; i++) {
                          combinedChannelData[offset + i] = bufferChannelData[i];
                      }
                  }
                  
                  offset += buffer.length;
              }
              
              return combinedBuffer;
          }
          
          // Helper function to convert AudioBuffer to Blob
          async function audioBufferToBlob(audioBuffer) {
              const audioContext = new (window.AudioContext || window.webkitAudioContext)();
              
              // Create an offline context to render the audio buffer
              const offlineContext = new OfflineAudioContext(
                  audioBuffer.numberOfChannels,
                  audioBuffer.length,
                  audioBuffer.sampleRate
              );
              
              // Create a buffer source node
              const source = offlineContext.createBufferSource();
              source.buffer = audioBuffer;
              source.connect(offlineContext.destination);
              
              // Start the source and render
              source.start(0);
              const renderedBuffer = await offlineContext.startRendering();
              
              // Convert to WAV format
              const wavBlob = bufferToWave(renderedBuffer);
              
              return wavBlob;
          }
          
          // Convert AudioBuffer to WAV Blob
          function bufferToWave(audioBuffer) {
              const numOfChan = audioBuffer.numberOfChannels;
              const length = audioBuffer.length * numOfChan * 2 + 44;
              const buffer = new ArrayBuffer(length);
              const view = new DataView(buffer);
              const channels = [];
              let sample, offset = 0;
              let pos = 0;
              
              // Write WAV header
              setUint32(0x46464952); // "RIFF"
              setUint32(length - 8); // file length - 8
              setUint32(0x45564157); // "WAVE"
              setUint32(0x20746d66); // "fmt " chunk
              setUint32(16); // length = 16
              setUint16(1); // PCM
              setUint16(numOfChan);
              setUint32(audioBuffer.sampleRate);
              setUint32(audioBuffer.sampleRate * 2 * numOfChan); // byte rate
              setUint16(numOfChan * 2); // block align
              setUint16(16); // bits per sample
              setUint32(0x61746164); // "data" chunk
              setUint32(length - pos - 4); // chunk length
              
              // Write interleaved data
              for (let i = 0; i < numOfChan; i++) {
                  channels.push(audioBuffer.getChannelData(i));
              }
              
              while (pos < length) {
                  for (let i = 0; i < numOfChan; i++) {
                      sample = Math.max(-1, Math.min(1, channels[i][offset]));
                      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                      view.setInt16(pos, sample, true);
                      pos += 2;
                  }
                  offset++;
                  if (offset >= audioBuffer.length) break;
              }
              
              function setUint16(data) {
                  view.setUint16(pos, data, true);
                  pos += 2;
              }
              
              function setUint32(data) {
                  view.setUint32(pos, data, true);
                  pos += 4;
              }
              
              return new Blob([buffer], { type: "audio/wav" });
          }
          
          // Helper functions for status display
          function showError(message) {
              if (statusElement) {
                  statusElement.textContent = message;
                  statusElement.className = 'status error';
              } else {
                  console.error(message);
              }
          }
          
          function showLoading(message) {
              if (statusElement) {
                  statusElement.textContent = message;
                  statusElement.className = 'status loading';
              } else {
                  console.log(message);
              }
          }
          
          function clearStatus() {
              if (statusElement) {
                  statusElement.textContent = '';
                  statusElement.className = 'status';
              }
          }
      });
  </script>
</head>
<body>
  <!-- Simple navigation header -->
  <div class="simple-header">
    <a href="index.html"><i class="fas fa-arrow-left"></i> 返回首页</a>
  </div>

  <div class="container">
    <h1>对话语音转换</h1>
    <form>
      <div class="form-group">
        <label for="dialog-input">对话文本</label>
        <textarea id="dialog-input" rows="4" cols="50"></textarea>
      </div>
      <div class="form-group">
        <label for="model-select">模型选择</label>
        <select id="model-select">
          <option value="default">默认模型</option>
          <option value="custom">自定义模型</option>
        </select>
      </div>
      <div class="form-group">
        <label for="speed-control">语速</label>
        <input type="range" id="speed-control" min="0.5" max="2.0" step="0.01" value="1.0">
        <span id="speed-value">1.0</span>
      </div>
      <button type="button" id="generate-btn">生成语音</button>
    </form>
    <div class="status-container">
      <span id="status"></span>
    </div>
    <div id="dialog-analysis" class="analysis-container hidden">
      <h2>对话分析</h2>
      <p>角色数量: <span id="roles-count">0</span></p>
      <div id="roles-list" class="roles-list"></div>
      <div id="segments-container" class="segments-container"></div>
    </div>
    <div id="combined-audio" class="audio-container hidden">
      <h2>完整对话音频</h2>
      <audio id="combined-player" controls></audio>
      <button id="download-btn">下载完整对话音频</button>
    </div>
  </div>
</body>
</html> 